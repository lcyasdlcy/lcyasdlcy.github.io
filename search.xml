<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[古诗文收集]]></title>
    <url>%2F2018%2F05%2F14%2Fgushiwen-collection%2F</url>
    <content type="text"><![CDATA[这篇放松一下心情，先不写编程相关的，就抄录一下历代传唱的诗文。下面按照作品的产生朝代记录收集它们，收集的依据主要是耳熟能详或录入中小学课文的，因为我对古诗文了理解也就是中小学生的水平。其中穿插了些个人的不成熟甚至不正确的看法，爱咋咋地。 先秦先秦文学的精华主要集中在春秋战国时期，所谓百花齐放，百家争鸣，但中华文明讲的诸子百家儒术独尊，所以这里抄录的诗文主要是儒家典籍四书五经中的。再加上几篇老庄的，以及历史课本中认为不存在的屈原的。 诗经既然是收集古诗文，先秦必然首推诗经。下面摘抄几首： 关雎 关关雎鸠，在河之洲。窈窕淑女，君子好逑。参差荇菜，左右流之。窈窕淑女，寤寐求之。求之不得，寤寐思服。悠哉悠哉，辗转反侧。参差荇菜，左右采之。窈窕淑女，琴瑟友之。参差荇菜，左右芼之。窈窕淑女，钟鼓乐之。 蒹葭 蒹葭苍苍，白露为霜。所谓伊人，在水一方。溯洄从之，道阻且长。溯游从之，宛在水中央。蒹葭萋萋，白露未晞。所谓伊人，在水之湄。溯洄从之，道阻且跻。溯游从之，宛在水中坻。蒹葭采采，白露未已。所谓伊人，在水之涘。溯洄从之，道阻且右。溯游从之，宛在水中沚。 采薇 采薇采薇，薇亦作止。曰归曰归，岁亦莫止。 靡室靡家，猃狁之故。不遑启居，猃狁之故。采薇采薇，薇亦柔止。曰归曰归，心亦忧止。 忧心烈烈，载饥载渴。我戍未定，靡使归聘。采薇采薇，薇亦刚止。曰归曰归，岁亦阳止。 王事靡盬，不遑启处。忧心孔疚，我行不来！彼尔维何？维常之华。彼路斯何？君子之车。 戎车既驾，四牡业业。岂敢定居？一月三捷。驾彼四牡，四牡骙骙。君子所依，小人所腓。 四牡翼翼，象弭鱼服。岂不日戒？猃狁孔棘！昔我往矣，杨柳依依。今我来思，雨雪霏霏。 行道迟迟，载渴载饥。我心伤悲，莫知我哀！ 桃夭 桃之夭夭，灼灼其华。之子于归，宜其室家。桃之夭夭，有蕡其实。之子于归，宜其家室。桃之夭夭，其叶蓁蓁。之子于归，宜其家人。 屈原把屈原放在孔孟老庄之前，不是因为其名气或者时代，而是因为这篇主要是抄录古诗文的，而孔孟老庄胜在思想，严格说他们的作品不能算古诗文。屈原诗作众多，最有名的当然是离骚了，但是离骚太长了，这里就不抄了。同样的原因后面如孔雀东南飞，长恨歌等也不抄了。下面抄一首中学课本上的： 九章.涉江 余幼好此奇服兮，年既老而不衰。带长铗之陆离兮，冠切云之崔嵬，被明月兮佩宝璐。世混浊而莫余知兮，吾方高驰而不顾。驾青虬兮骖白螭，吾与重华游兮瑶之圃。登昆仑兮食玉英，与天地兮比寿，与日月兮同光。哀南夷之莫吾知兮，旦余济乎江湘。乘鄂渚而反顾兮，欸秋冬之绪风。步余马兮山皋，邸余车兮方林。乘舲船余上沅兮，齐吴榜以击汰。船容与而不进兮，淹回水而疑滞。朝发枉陼兮，夕宿辰阳。苟余心其端直兮，虽僻远之何伤？入溆浦余儃佪兮，迷不知吾所如。深林杳以冥冥兮，乃猿狖之所居。山峻高而蔽日兮，下幽晦以多雨。霰雪纷其无垠兮，云霏霏其承宇。哀吾生之无乐兮，幽独处乎山中。吾不能变心以从俗兮，固将愁苦而终穷。接舆髡首兮，桑扈裸行。忠不必用兮，贤不必以。伍子逢殃兮，比干菹醢。与前世而皆然兮，吾又何怨乎今之人。余将董道而不豫兮，固将重昏而终身。乱曰：鸾鸟凤凰，日以远兮。燕雀乌鹊，巢堂坛兮。露申辛夷，死林薄兮。腥臊并御，芳不得薄兮。阴阳易位，时不当兮。怀信侘傺，忽乎吾将行兮。 孔子千古一圣登场，但孔子是立说不著书的，所谓编春秋修六经也是相传。论语也只是孔子说的，门徒们记录的。说到圣人门徒，子最欣赏的是颜回，颜回应该是深得孔子立说不著书思想的，我是不知道回写过什么。那么，如果来了。 如果颜回不早逝，子肯定是要托孤回的。如果托孤了回，曾子就要靠边站了。曾子靠边站了，还能写出《大学》么。曾子不教子思，子思还能写出《中庸》么。子思如果不写书，孟子应该也不会写《孟子》了。 如此看来，是颜回卒于孔子之前，才导致了儒家典籍的井喷，不然单靠群弟子，记善言的《论语》很难将子推向圣人宝座。说多了，开始摘抄： 论语十二章 子曰：“学而时习之，不亦说乎？有朋自远方来，不亦乐乎？人不知而不愠，不亦君子乎？”《学而》曾子曰：“吾日三省吾身：为人谋而不忠乎？与朋友交而不信乎？传不习乎？”《学而》子曰：“吾十有五而志于学，三十而立，四十而不惑，五十而知天命，六十而耳顺，七十而从心所欲，不逾矩。”《为政》子曰：“温故而知新，可以为师矣。”《为政》子曰：“学而不思则罔，思而不学则殆。”《为政》子曰：“贤哉，回也！一箪食，一瓢饮，在陋巷，人不堪其忧，回也不改其乐。贤哉，回也！”《雍也》子曰：“知之者不如好之者，好之者不如乐之者。”《雍也》子曰：“饭疏食饮水，曲肱而枕之，乐亦在其中矣。不义而富且贵，于我如浮云。”《述而》子曰：“三人行，必有我师焉。择其善者而从之，其不善者而改之。”《述而》子在川上曰：“逝者如斯夫，不舍昼夜。”《子罕》子曰：“三军可夺帅也， 匹夫不可夺志也。”《子罕》子夏曰：“博学而笃志，切问而近思，仁在其中矣。”《子张》 论语十则 子曰：“学而时习之，不亦说乎?有朋自远方来，不亦乐乎?人不知而不愠，不亦君子乎?”（《学而》）曾子曰：“吾日三省吾身：为人谋而不忠乎？与朋友交而不信乎？传不习乎？”（《学而》）子曰：“温故而知新，可以为师矣。”（《为政》）子曰：“学而不思则罔,思而不学则殆。”（《为政》）子曰：“由，诲女知之乎！知之为知之，不知为不知，是知也。”（《为政》）子曰：“见贤思齐焉，见不贤而内自省也。”（《里仁》）子曰：“三人行，必有我师焉。择其善者而从之，其不善者而改之。”（《述而》）曾子曰：“士不可以不弘毅，任重而道远。仁以为己任，不亦重乎？死而后已，不亦远乎？”（《泰伯》）子曰：“岁寒，然后知松柏之后凋也。”（《子罕》）子贡问曰：“有一言而可以终身行之者乎？”子曰：“其恕乎！己所不欲，勿施于人。”（《卫灵公》） 从上看来，如果曾子靠边站了，可能连《论语》也没有了。后世人还谈什么四书五经中华文明。 再抄一篇后世托名孔子所作的一篇。 大道之行也 大道之行也，天下为公，选贤与能，讲信修睦。故人不独亲其亲，不独子其子，使老有所终，壮有所用，幼有所长，矜、寡、孤、独、废疾者皆有所养，男有分，女有归。货恶其弃于地也，不必藏于己；力恶其不出于身也，不必为己。是故谋闭而不兴，盗窃乱贼而不作，故外户而不闭，是谓大同。 曾子上面说到，是子将掌门之位传给曾子后，才有了四书，可以说其对后世两千多年中华文明影响深远。下面摘抄一段曾子作品。 大学摘抄 大学之道，在明明德，在亲民，在止于至善。知止而后有定，定而后能静，静而后能安，安而后能虑，虑而后能得。物有本末，事有终始。知所先后，则近道矣。古之欲明明德于天下者，先治其国。欲治其国者，先齐其家。欲齐其家者，先修其身。欲修其身者，先正其心。欲正其心者，先诚其意。欲诚其意者，先致其知。致知在格物。物格而后知至，知至而后意诚，意诚而后心正，心正而后身修，身修而后家齐，家齐而后国治，国治而后天下平。自天子以至于庶人，一是皆以修身为本。其本乱而末治者否矣。其所厚者薄，而其所薄者厚，未之有也。此谓知本，此谓知之至也。所谓诚其意者，毋自欺也。如恶恶臭，如好好色，此之谓自谦。故君子必慎其独也。小人闲居为不善，无所不至，见君子而后厌然，掩其不善而著其善。 人之视己，如见其肺肝然，则何益矣。此谓诚于中，形于外，故君子必慎其独也。 曾子曰：“十目所视，十手所指，其严乎！”富润屋，德润身，心广体胖，故君子必诚其意。…… 曾子除了著书，立说也不惶多让，除了上面论语节选中提到的，再抄录一些： 论语.曾子相关 曾子曰：“忠者，其孝之本与？孝子不登高，不履危，痹亦弗凭；不苟笑，不苟訾，隐不命，临不指。故不在尤之中也。”曾子曰：“君子立孝，其忠之用，礼之贵。”曾子曰：“孝有三：大孝尊亲，其次不辱，其下能养。”曾子曰：”吾闻诸夫子：’人未有自致者也必也，亲丧乎‘。”曾子曰：”吾闻诸夫子：’孟庄子之孝也，其他可能也，其不改父之臣与父之政，是难能也。”曾子曰：”鸟之将死，其鸣也哀；人之将死，其言也善。君子所贵乎道者三：动容貌，斯远暴慢矣；正颜色，斯近信矣；出辞气，斯远鄙倍矣。笾豆之事，则有司存。”曾子曰：”以能问于不能，以多问于寡，有若无，实若处，犯而不校，昔者吾友尝从事于斯矣。”曾子曰：”君子思不出其位。”曾子曰：”堂堂乎张也！难与并为仁矣。”曾子曰：”可以托六尺之孤，可以寄百里之命，临大节而不可夺也——君子人欤？君子人也。”曾子曰：”慎终追远，民德归厚矣。”曾子曰：”君子以文会友，以友辅仁。”子曰：”参乎！吾道一以贯之。”曾子曰：”唯。”子出，门人问曰：”何谓也？”曾子曰：”夫子之道，忠恕而已矣。“ 我的想法（曾子影响了中华文明）可能太过极端，下面摘一段比较中肯的： 1曾子师从孔子，积极推行儒家主张，传播儒家思想。孔子的孙子孔伋（字子思）师从参公，又传授给孟子。因之，曾参上承孔子之道，下启思孟学派，对孔子的儒学学派思想既有继承，又有发展和建树。曾参是孔子学说的主要继承人和传播者，在儒家文化中具有承上启下的重要地位。曾参以他的建树，终于走进大儒殿堂，与孔子、颜子（颜回）、子思、孟子比肩共称为五大圣人。 孟子孟子就不多说了，历史地位在那摆着，孟子者，七篇止，讲道德，说仁义，直接抄录。 生于忧患，死于安乐 舜发于畎亩之中，傅说举于版筑之间，胶鬲举于鱼盐之中，管夷吾举于士，孙叔敖举于海，百里奚举于市。故天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。人恒过，然后能改；困于心，衡于虑，而后作；征于色，发于声，而后喻。入则无法家拂士，出则无敌国外患者，国恒亡。然后知生于忧患而死于安乐也。 鱼我所欲也 鱼，我所欲也；熊掌，亦我所欲也，二者不可得兼，舍鱼而取熊掌者也。生，亦我所欲也；义，亦我所欲也。二者不可得兼，舍生而取义者也。生亦我所欲，所欲有甚于生者，故不为苟得也。死亦我所恶，所恶有甚于死者，故患有所不辟也。如使人之所欲莫甚于生，则凡可以得生者何不用也。使人之所恶莫甚于死者，则凡可以辟患者何不为也！由是则生而有不用也；由是则可以辟患而有不为也。是故所欲有甚于生者，所恶有甚于死者。非独贤者有是心也，人皆有之，贤者能勿丧耳。一箪食，一豆羹，得之则生，弗得则死。呼尔而与之，行道之人弗受；蹴尔而与之，乞人不屑也。万钟则不辩礼义而受之，万钟于我何加焉！为宫室之美，妻妾之奉，所识穷乏者得我与？乡为身死而不受，今为宫室之美为之；乡为身死而不受，今为妻妾之奉为之；乡为身死而不受，今为所识穷乏者得我而为之：是亦不可以已乎？此之谓失其本心。 得道多助，失道寡助 天时不如地利，地利不如人和。三里之城，七里之郭，环而攻之而不胜。夫环而攻之，必有得天时者矣，然而不胜者，是天时不如地利也。城非不高也，池非不深也，兵革非不坚利也，米粟非不多也，委而去之，是地利不如人和也。故曰，域民不以封疆之界，固国不以山溪之险，威天下不以兵革之利。得道者多助，失道者寡助。寡助之至，亲戚畔之。多助之至，天下顺之。以天下之所顺，攻亲戚之所畔，故君子有不战，战必胜矣。 荀子 提到孟子，不能不提荀子，毕竟司马迁是将二人并列一篇的。至于其地位，直接引用网上对比孔孟的感受一下： 荀子的思想偏向于经验以及人事方面，是从社会脉络方面出发，重视社会秩序，反对神秘主义的思想，重视人为的努力。孔子中心思想为“仁”，孟子中心思想为“义”，荀子继二人后提出“礼”、“法”，重视社会上人们行为的规范。以孔子为圣人，但反对孟子和子思为首的“思孟学派”哲学思想，认为子弓与自己才是继承孔子思想的学者。荀子认为人与生俱来就想满足欲望，若欲望得不到满足便会发生争执，因此主张人性有恶，须要由圣王及礼法的教化，来“化性起伪”使人格提高。与孔、孟相比，荀子的思想则具有更多的现实主义倾向。他在重视礼义道德教育的同时，也强调了政法制度的惩罚作用。 劝学摘抄 君子曰：学不可以已。青，取之于蓝，而青于蓝；冰，水为之，而寒于水。木直中绳，輮以为轮，其曲中规。虽有槁暴，不复挺者，輮使之然也。故木受绳则直，金就砺则利，君子博学而日参省乎己，则知明而行无过矣。吾尝终日而思矣，不如须臾之所学也；吾尝跂而望矣，不如登高之博见也。登高而招，臂非加长也，而见者远；顺风而呼，声非加疾也，而闻者彰。假舆马者，非利足也，而致千里；假舟楫者，非能水也，而绝江河。君子生非异也，善假于物也。积土成山，风雨兴焉；积水成渊，蛟龙生焉；积善成德，而神明自得，圣心备焉。故不积跬步，无以至千里；不积小流，无以成江海。骐骥一跃，不能十步；驽马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。蚓无爪牙之利，筋骨之强，上食埃土，下饮黄泉，用心一也。蟹六跪而二螯，非蛇鳝之穴无可寄托者，用心躁也。 原来这些是从劝学里面四处挑的，难怪上学时背诵的时候感觉不连贯。 一篇不足以编目，那就把荀子的弟子韩非的一篇也在这里抄录一下。 智子疑邻 宋有富人，天雨墙坏。其子曰：“不筑，必将有盗。”其邻人之父亦云。暮而果大亡其财，其家甚智其子，而疑邻人之父。 老庄老庄就是老子和庄子了，他们在道家的地位就好比孔孟在儒家的地位。二人分别都有大作传世–道德经、南华经，道德经很长，大概有五千字故又称五千言文，南华经就更长了，所以这里只能摘抄其中的一小点，感受一下。 道德经.第一章 道可道，非常道；名可名，非常名。无名，万物之始，有名，万物之母。故常无欲，以观其妙，常有欲，以观其徼。此两者，同出而异名，同谓之玄，玄之又玄，众妙之门。 道德经.第四十二章 道生一，一生二，二生三，三生万物。万物负阴而抱阳，冲气以为和。天下之所恶，唯孤、寡、不谷，而王公以为自名也。故物或损之而益，或益之而损。觐殷死，议而教人。强梁者不得其死，我将以为学父。 逍遥游一段 北冥有鱼，其名为鲲。鲲之大，不知其几千里也。化而为鸟，其名为鹏。鹏之背，不知其几千里也，怒而飞，其翼若垂天之云。是鸟也，海运则将徙于南冥。南冥者，天池也。《齐谐》者，志怪者也。《谐》之言曰：“鹏之徙于南冥也，水击三千里，抟扶摇而上者九万里，去以六月息者也。”野马也，尘埃也，生物之以息相吹也。天之苍苍，其正色邪？其远而无所至极邪？其视下也，亦若是则已矣。且夫水之积也不厚，则其负大舟也无力。覆杯水于坳堂之上，则芥为之舟；置杯焉则胶，水浅而舟大也。风之积也不厚，则其负大翼也无力。故九万里，则风斯在下矣，而后乃今培风；背负青天而莫之夭阏者，而后乃今将图南。 其他先秦还有那么多好诗文，这里都要划到其他里了，实在是受传统学校教育的影响，除了儒家其他家的诗文好像也没有什么号召力。下面就摘抄几篇进课本的短文。 两小儿辩日 孔子东游，见两小儿辩日，问其故。一儿曰：“我以日始出时去人近，而日中时远也。”一儿以日初出远，而日中时近也。一儿曰：“日初出大如车盖，及日中则如盘盂，此不为远者小而近者大乎？”一儿曰：“日初出沧沧凉凉，及其日中如探汤，此不为近者热而远者凉乎？”孔子不能决也。两小儿笑曰：“孰为汝多知乎？” 还是孔子，圣人就是不一样。 学弈 弈秋，通国之善弈者也。使弈秋诲二人弈，其一人专心致志，惟弈秋之为听；一人虽听之，一心以为有鸿鹄将至，思援弓缴而射之。虽与之俱学，弗若之矣。为是其智弗若与？曰：非然也。 愚公移山 太行、王屋二山，方七百里，高万仞。本在冀州之南，河阳之北。北山愚公者，年且九十，面山而居。惩山北之塞，出入之迂也。聚室而谋曰：“吾与汝毕力平险，指通豫南，达于汉阴，可乎？”杂然相许。其妻献疑曰：“以君之力，曾不能损魁父之丘，如太行、王屋何？且焉置土石？”杂曰：“投诸渤海之尾，隐土之北。”遂率子孙荷担者三夫，叩石垦壤，箕畚运于渤海之尾。邻人京城氏之孀妻有遗男，始龀，跳往助之。寒暑易节，始一反焉。河曲智叟笑而止之曰：“甚矣，汝之不惠。以残年余力，曾不能毁山之一毛，其如土石何？”北山愚公长息曰：“汝心之固，固不可彻，曾不若孀妻弱子。虽我之死，有子存焉；子又生孙，孙又生子；子又有子，子又有孙；子子孙孙无穷匮也，而山不加增，何苦而不平？”河曲智叟亡以应。操蛇之神闻之，惧其不已也，告之于帝。帝感其诚，命夸娥氏二子负二山，一厝朔东，一厝雍南。自此，冀之南，汉之阴，无陇断焉。 写到这里突然发现，这其他多是成语故事，那么叶公好龙、郑人买履、邯郸学步、狐假虎威、画蛇添足、......有好多，也不知道是不是先秦的作品，还是不抄了吧。另外如曹刿论战、烛之武退秦师、完璧归赵、扁鹊见蔡桓公、唐雎不辱使命等历史事件相关的也不抄了。 先秦诗文就先到这里吧。 两汉怎么算两汉，按人物生活的年代最后一个皇帝退位算，这样曹操就也算两汉的了（他二子不算）。两汉时期的诗文作者，进中小学课本最多的应该是司马迁，因为有史家之绝唱，无韵之离骚压阵。另外，文首推贾生，诗首推孟德。这章还是以人物划分，让我先罗列一下：贾谊、司马迁、曹操、诸葛亮、其他。咦，好像没东汉什么事，算了就这样吧。 贾谊贾谊一生很短，但无碍其历史地位，历来被推崇备至。过秦论、论积贮疏都是课文中要背诵的，但这里抄录还是觉得不合适，因为都太长了。但都把贾生单独列出来了，不能什么都不写吧。那就把后世关于贾生的有名诗文作品抄录一下吧。 滕王阁序一段 嗟乎，时运不齐，命途多舛。冯唐易老，李广难封。屈贾谊于长沙，非无圣主；窜梁鸿于海曲，岂乏明时？所赖君子见机，达人知命。老当益壮，宁移白首之心？穷且益坚，不坠青云之志。酌贪泉而觉爽，处涸辙以犹欢。北海虽赊，扶摇可接；东隅已逝，桑榆非晚。孟尝高洁，空余报国之情；阮籍猖狂，岂效穷途之哭！ 李商隐.贾生 宣室求贤访逐臣，贾生才调更无伦。可怜夜半虚前席，不问苍生问鬼神。 王安石.贾生 一时谋议略施行，谁道君王薄贾生。爵位自高言尽废，古来何啻万公卿。 毛泽东.贾生 贾生才调世无伦，哭泣情怀吊屈文。梁王堕马寻常事，何用哀伤付一生。 司马迁这里该抄什么呢？都那么长。还是抄录一些名句吧。其实名句也太多，抄不完，更详细的见这篇。 司马迁史记名句 前事之不忘，后事之师也。家贫则思良妻，国乱则思良相。一沐三捉发，一饭三吐哺。仓廪实而知礼节，衣食足而知荣辱。士为知己者死，女为说己者容。智者千虑，必有一失；愚者千虑，必有一得。其身正，不令而行；其身不正，虽令不从。鸟之将死，其鸣也哀；人之将死，其言也善。不鸣则已，一鸣惊人。 再节选一点非史记的，感受一下司马公的文采： 报任安书摘抄 夫人情莫不贪生恶死，念父母，顾妻子，至激于义理者不然，乃有所不得已也。今仆不幸，早失父母，无兄弟之亲，独身孤立，少卿视仆于妻子何如哉？且勇者不必死节，怯夫慕义，何处不勉焉！仆虽怯懦，欲苟活，亦颇识去就之分矣，何至自沉溺缧绁之辱哉！且夫臧获婢妾，犹能引决，况仆之不得已乎？所以隐忍苟活，幽于粪土之中而不辞者，恨私心有所不尽，鄙陋没世，而文采不表于后也。古者富贵而名摩灭，不可胜记，唯倜傥非常之人称焉。盖文王拘而演《周易》；仲尼厄而作《春秋》；屈原放逐，乃赋《离骚》；左丘失明，厥有《国语》；孙子膑脚，《兵法》修列；不韦迁蜀，世传《吕览》；韩非囚秦，《说难》《孤愤》；《诗》三百篇，大底圣贤发愤之所为作也。此人皆意有所郁结，不得通其道，故述往事、思来者。乃如左丘无目，孙子断足，终不可用，退而论书策，以舒其愤，思垂空文以自见。 曹操话不多说，直接抄录。 短歌行 对酒当歌，人生几何！譬如朝露，去日苦多。慨当以慷，忧思难忘。何以解忧？唯有杜康。青青子衿，悠悠我心。但为君故，沉吟至今。呦呦鹿鸣，食野之苹。我有嘉宾，鼓瑟吹笙。明明如月，何时可掇？忧从中来，不可断绝。越陌度阡，枉用相存。契阔谈讌，心念旧恩。月明星稀，乌鹊南飞。绕树三匝，何枝可依？山不厌高，水不厌深。周公吐哺，天下归心。 再来两首三句半。 观沧海 东临碣石，以观沧海。水何澹澹，山岛竦峙。树木丛生，百草丰茂。秋风萧瑟，洪波涌起。日月之行，若出其中；星汉灿烂，若出其里。幸甚至哉，歌以咏志。 龟虽寿 神龟虽寿，犹有竟时。腾蛇乘雾，终为土灰。老骥伏枥，志在千里。烈士暮年，壮心不已。盈缩之期，不但在天；养怡之福，可得永年。幸甚至哉，歌以咏志。 诸葛亮单凭一篇出师表，也应该为诸葛亮单列。记得上学时最喜欢背的古文，一是出师表，二是醉翁亭记，两篇都把之乎者也文言句式应用到了极致，而出师表尤甚，背诵时稍有不慎就会出错。但这里还是不想抄出师表，太长了。抄个诸葛武侯的短文： 诫子书 夫君子之行，静以修身，俭以养德。非淡泊无以明志，非宁静无以致远。夫学须静也，才须学也。非学无以广才，非志无以成学。淫慢则不能励精，险躁则不能冶性。年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及！ 下面是诗圣对武侯的歌颂，就是不知道名字对不对，内容也不一定准确（我对杜甫是认真的，别人的我可能会去复制，但杜甫的我都是硬背）： 八阵图 功盖三分国，名成八阵图。江流石不转，遗恨失吞吴。 武侯庙 遗庙丹青落，空山草木长。犹闻辞后主，不复卧南阳。 咏怀古迹 诸葛大名垂宇宙，宗臣遗庙肃清高。三分割据纡筹策，万古云霄一羽毛。伯仲之间见伊吕，指挥若定失萧曹。运移汉祚终难复，志决身坚军务劳。 蜀相 丞相祠堂何处寻，锦官城外柏森森。映阶碧草自春色，隔叶黄鹂空好音。三顾频烦天下计，两朝开济老臣心。出师未捷身先死，长使英雄泪满襟。 我跟英雄没关系吧，怎么一读这首也有热泪盈眶的冲动。 再来一首刘禹锡歌颂其祖上的诗，其中捎带了武侯： 蜀先主庙 天地英雄气，千秋尚凛然。势分三足鼎，业复五铢钱。得相能开国，生儿不像贤。凄凉蜀故妓，来舞魏宫前。 其他写到这里，突然发现问题了：我这明明是抄录古诗文的，即古代的诗歌和文章，但是几乎所有文章都很长，看来就都是诗歌了。算了继续抄诗吧，两汉时期其他的诗文也不少（就叫诗文吧，虽然可能没有文）。 项羽.垓下歌 力拔山兮气盖世。时不利兮骓不逝。骓不逝兮可奈何！虞兮虞兮奈若何！ 刘邦.大风歌 大风起兮云飞扬，威加海内兮归故乡，安得猛士兮守四方！ 青青园中葵 青青园中葵，朝露待日晞。阳春布德泽，万物生光辉。常恐秋节至，焜黄华叶衰。百川东到海，何时复西归？少壮不努力，老大徒伤悲！ 司马相如.凤求凰其一 有美一人兮，见之不忘。一日不见兮，思之如狂。凤飞翱翔兮，四海求凰。无奈佳人兮，不在东墙。将琴代语兮，聊写衷肠。何时见许兮，慰我彷徨。愿言配德兮，携手相将。不得於飞兮，使我沦亡。 卓文君.白头吟 皑如山上雪，皎若云间月。闻君有两意，故来相决绝。今日斗酒会，明旦沟水头。躞蹀御沟上，沟水东西流。凄凄复凄凄，嫁娶不须啼。愿得一人心，白首不相离。竹竿何袅袅，鱼尾何簁簁！男儿重意气，何用钱刀为！ 江南 江南可采莲，莲叶何田田，鱼戏莲叶间。鱼戏莲叶东，鱼戏莲叶西，鱼戏莲叶南，鱼戏莲叶北。 迢迢牵牛星 迢迢牵牛星，皎皎河汉女。纤纤擢素手，札札弄机杼。终日不成章，泣涕零如雨。河汉清且浅，相去复几许。盈盈一水间，脉脉不得语。 上邪 上邪，我欲与君相知，长命无绝衰。山无陵，江水为竭。冬雷震震，夏雨雪。天地合，乃敢与君绝。 北方有佳人 北方有佳人，绝世而独立。一顾倾人城，再顾倾人国。宁不知倾城与倾国？佳人难再得。 好了，两汉诗文就先到这里。 魏晋南北朝这一时期的诗文我觉得没有什么好分组的了，就是陶渊明及其他。是不是身处外族侵略时代，文人们大都写不出什么好作品了。 陶渊明陶潜公诗文双绝，我觉得历史上能称得上诗文双绝的就那么几个：欧阳修、王安石、苏轼，其他如韩、柳这样的百代文宗都不能称诗文双绝，其他人更别想。当然我这里不是说诗文双绝的就比只重诗或文的厉害或地位高（论文学地位高肯定是李杜第一然后其他），只是想说陶潜公能独撑这个时代，如果没有他，这个时代的诗文应该可以直接忽略掉了。话不多说直接开抄： 桃花源记 这里不抄这篇了，回顾上学时学的古文，该篇应该是背的最熟的，虽是古文，但内容通俗易懂，基本不用看翻译。单论这点，陶渊明之前的贾谊、诸葛亮比不了，之后的韩愈、柳宗元也比不了。这里去除史文罗列一下以前课本中的古文看看：过秦论、出师表、陈情表、桃花源记、滕王阁序、陋室铭、阿房宫赋、马说、师说、捕蛇者说、小石潭记、岳阳楼记、醉翁亭记、秋声赋、六国论、石钟山记、赤壁赋、游褒禅山记、卖橘者言、送东阳马生序、项脊轩志、五人墓碑记……想到了这些，说多了。这些都不抄录了。好了后面可能都剩下古诗了，可能会穿插一些古文摘抄。 开始正式抄录陶渊明诗文。 五柳先生传 先生不知何许人也，亦不详其姓字，宅边有五柳树，因以为号焉。闲静少言，不慕荣利。好读书，不求甚解；每有会意，便欣然忘食。性嗜酒，家贫不能常得。亲旧知其如此，或置酒而招之；造饮辄尽，期在必醉。既醉而退，曾不吝情去留。环堵萧然，不蔽风日；短褐穿结，箪瓢屡空，晏如也。常著文章自娱，颇示己志。忘怀得失，以此自终。赞曰：黔娄之妻有言：“不戚戚于贫贱，不汲汲于富贵。”其言兹若人之俦乎？衔觞赋诗，以乐其志，无怀氏之民欤？葛天氏之民欤？ 归去来兮 归去来兮，田园将芜胡不归？既自以心为形役，奚惆怅而独悲？悟已往之不谏，知来者之可追。实迷途其未远，觉今是而昨非。舟遥遥以轻飏，风飘飘而吹衣。问征夫以前路，恨晨光之熹微。乃瞻衡宇，载欣载奔。僮仆欢迎，稚子候门。三径就荒，松菊犹存。携幼入室，有酒盈樽。引壶觞以自酌，眄庭柯以怡颜。倚南窗以寄傲，审容膝之易安。园日涉以成趣，门虽设而常关。策扶老以流憩，时矫首而遐观。云无心以出岫，鸟倦飞而知还。景翳翳以将入，抚孤松而盘桓。归去来兮，请息交以绝游。世与我而相违，复驾言兮焉求？悦亲戚之情话，乐琴书以消忧。农人告余以春及，将有事于西畴。或命巾车，或棹孤舟。既窈窕以寻壑，亦崎岖而经丘。木欣欣以向荣，泉涓涓而始流。善万物之得时，感吾生之行休。已矣乎！寓形宇内复几时。曷不委心任去留？胡为乎遑遑欲何之？富贵非吾愿，帝乡不可期。怀良辰以孤往，或植杖而耘耔。登东皋以舒啸，临清流而赋诗。聊乘化以归尽，乐夫天命复奚疑！ 饮酒 结庐在人境，而无车马喧。问君何能尔？心远地自偏。采菊东篱下，悠然见南山。山气日夕佳，飞鸟相与还。此中有真意，欲辨已忘言。 归园田居 少无适俗韵，性本爱丘山。误落尘网中，一去三十年。羁鸟恋旧林，池鱼思故渊。开荒南野际，守拙归园田。方宅十余亩，草屋八九间。榆柳荫后檐，桃李罗堂前。暧暧远人村，依依墟里烟。狗吠深巷中，鸡鸣桑树颠。户庭无尘杂，虚室有余闲。久在樊笼里，复得返自然。 归园田居 种豆南山下，草盛豆苗稀。晨兴理荒秽，带月荷锄归。道狭草木长，夕露沾我衣。衣沾不足惜，但使愿无违。 杂诗 人生无根蒂，飘如陌上尘。分散逐风转，此已非常身。落地为兄弟，何必骨肉亲！得欢当作乐，斗酒聚比邻。盛年不重来，一日难再晨。及时当勉励，岁月不待人。 读山海经 精卫衔微木，将以填沧海。刑天舞干戚，猛志固常在。同物既无虑，化去不复悔。徒设在昔心，良辰讵可待。 其他陶渊明抄了这么多，其他该抄多少？好像魏晋时期都找不到，就先来两篇曹氏弟兄的吧。 曹植.白马篇 白马饰金羁，连翩西北驰。借问谁家子，幽并游侠儿。少小去乡邑，扬声沙漠垂。宿昔秉良弓，楛矢何参差。控弦破左的，右发摧月支。仰手接飞猱，俯身散马蹄。狡捷过猴猿，勇剽若豹螭。边城多警急，虏骑数迁移。羽檄从北来，厉马登高堤。长驱蹈匈奴，左顾凌鲜卑。弃身锋刃端，性命安可怀？父母且不顾，何言子与妻！名编壮士籍，不得中顾私。捐躯赴国难，视死忽如归！ 曹丕.燕歌行 秋风萧瑟天气凉，草木摇落露为霜，群燕辞归鹄南翔。念君客游思断肠，慊慊思归恋故乡，君何淹留寄他方？贱妾茕茕守空房，忧来思君不敢忘，不觉泪下沾衣裳。援琴鸣弦发清商，短歌微吟不能长。明月皎皎照我床，星汉西流夜未央。牵牛织女遥相望，尔独何辜限河梁。 南北朝时期最有名的肯定是乐府双璧之一的木兰诗了，因为太熟悉这里就不抄录了。来几篇南北朝其他的： 敕勒歌 敕勒川，阴山下。天似穹庐，笼盖四野。天苍苍，野茫茫。风吹草低见牛羊。 谢朓.王孙游 绿草蔓如丝，杂树红英发。无论君不归，君归芳已歇。 王籍.入若耶溪 艅艎何泛泛，空水共悠悠。阴霞生远岫，阳景逐回流。蝉噪林逾静，鸟鸣山更幽。此地动归念，长年悲倦游。 郦道元.三峡 自三峡七百里中，两岸连山，略无阙处。重岩叠嶂，隐天蔽日。自非亭午夜分，不见曦月。至于夏水襄陵，沿溯阻绝。或王命急宣，有时朝发白帝，暮到江陵，其间千二百里，虽乘奔御风，不以疾也。春冬之时，则素湍绿潭，回清倒影。绝巘多生怪柏，悬泉瀑布，飞漱其间，清荣峻茂，良多趣味。每至晴初霜旦，林寒涧肃，常有高猿长啸，属引凄异，空谷传响，哀转久绝。故渔者歌曰：“巴东三峡巫峡长，猿鸣三声泪沾裳。” 吴均.与朱元思书 风烟俱净，天山共色。从流飘荡，任意东西。自富阳至桐庐一百许里，奇山异水，天下独绝。水皆缥碧，千丈见底。游鱼细石，直视无碍。急湍甚箭，猛浪若奔。夹岸高山，皆生寒树，负势竞上，互相轩邈，争高直指，千百成峰。泉水激石，泠泠作响；好鸟相鸣，嘤嘤成韵。蝉则千转不穷，猿则百叫无绝。鸢飞戾天者，望峰息心；经纶世务者，窥谷忘反。横柯上蔽，在昼犹昏；疏条交映，有时见日。 好了，魏晋南北朝就抄到这里吧。后面因为隋朝太短，也没什么可抄的，直接跳过，进入中华诗歌盛世–唐朝。 唐宋元明清]]></content>
  </entry>
  <entry>
    <title><![CDATA[从Python到Django入门]]></title>
    <url>%2F2018%2F05%2F11%2Fpython27-to-django-primer%2F</url>
    <content type="text"><![CDATA[上一篇写socket实例的时候切身感受到了python的简单，于是最近想写一些关于python的文章。那就像之前的那些文章那样，整个入门教程吧。 前言写这篇基本是没有自己的思想的，纯粹是为了学习python，所以下面的内容基本都是从别处搬来的。网上有两篇写的很好的python学习的中文教程，一篇是廖雪峰的，一篇是Vamei的。这两篇对我学习python帮助巨大，但我这篇不想抄他们的。 我要抄的是一本叫做Python Web Development with Django书上的，这本书是外国人写的介绍Django开发Web程序的（书比较老了，写例子时要改成较新的），这里直接照搬其第一部分，作为Python的入门文章，所以有了这篇的题目。 Python练习Python是编程新手的最好的语言，因为它足够简单。 直接上个代码感受下吧。 12345&gt;&gt;&gt; print 'hello, world.'&gt;&gt;&gt; for word in ['capitalize','these','words']:... print word.upper()&gt;&gt;&gt; for i in range(0,5):... print i 基础注释 123# this entire line is a commentfoo = 1 # short comment: assign int 1 to 'foo'print 'Python and %s are number %d' % ('Django,foo) 变量及赋值 12foo = 'bar'foo = 10 运算符：算数运算符+-*/等，赋值运算符+=,-=,*=等（不支持++,–），关系运算符&lt;,&gt;=,==,!=等，逻辑运算符and,or,not 123show_output = Trueif show_output and foo==1: print 'hello' 标准类型布尔型 1234567891011&gt;&gt;&gt; download_complete = False&gt;&gt;&gt; bool(download_complete)False&gt;&gt;&gt; bool(-1.23)True&gt;&gt;&gt; bool(0.0)False&gt;&gt;&gt; bool("")False&gt;&gt;&gt; bool([None,0])True 数值型：两种主要的数值类型int和float 12345678910111213141516171819202122&gt;&gt;&gt; 1/20&gt;&gt;&gt; 1.0/2.00.5&gt;&gt;&gt; 1//20&gt;&gt;&gt; 1.0//2.00&gt;&gt;&gt; int('123')123&gt;&gt;&gt; int(45.67)45&gt;&gt;&gt; round(1.16,1) #四舍五入1.2&gt;&gt;&gt; fload(10)10.0&gt;&gt;&gt; ord('a')97&gt;&gt;&gt; chr(65)A&gt;&gt;&gt; divmod(15,6) #除余(2,3) 序列和迭代 字符串 1234567891011121314151617181920212223242526272829&gt;&gt;&gt; s='Python'&gt;&gt;&gt; s'Python'&gt;&gt;&gt; s[0]'P'&gt;&gt;&gt; s[4]'o'&gt;&gt;&gt; s[-1]'n'&gt;&gt;&gt; s[1:4]'yth'&gt;&gt;&gt; s[2:4]'th'&gt;&gt;&gt; s[:4]'Pyth'&gt;&gt;&gt; s[3:]'hon'&gt;&gt;&gt; s[:]'Python'&gt;&gt;&gt; str(s)'Python'&gt;&gt;&gt; 'Python and'+' '+'Django are cool''Python and Django are cool'&gt;&gt;&gt; '-'*40'----------------------------------------'&gt;&gt;&gt; 'an' in 'Django'True&gt;&gt;&gt; 'xyz' not in 'Django'True 列表 1234567891011121314151617181920212223242526272829303132333435363738&gt;&gt;&gt; book=['Python','Development',8]&gt;&gt;&gt; book.append(2008)&gt;&gt;&gt; book['Python', 'Development', 8, 2008]&gt;&gt;&gt; book.insert(1,'Web')&gt;&gt;&gt; book['Python', 'Web', 'Development', 8, 2008]&gt;&gt;&gt; book.insert(1,'Web')&gt;&gt;&gt; book['Python', 'Web', 'Development', 8, 2008]&gt;&gt;&gt; book[3]8&gt;&gt;&gt; 'Python' in bookTrue&gt;&gt;&gt; 'Django' in bookFalse&gt;&gt;&gt; book.remove(8)&gt;&gt;&gt; book.pop(-1)2008&gt;&gt;&gt; book['Python', 'Web', 'Development']&gt;&gt;&gt; book*2['Python', 'Web', 'Development', 'Python', 'Web', 'Development']&gt;&gt;&gt; book.extend(['with','Django'])&gt;&gt;&gt; book['Python', 'Web', 'Development', 'with', 'Django']&gt;&gt;&gt; book.sort()&gt;&gt;&gt; book['Development', 'Django', 'Python', 'Web', 'with']&gt;&gt;&gt; data=[x+1 for x in range(10)]&gt;&gt;&gt; data[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&gt;&gt;&gt; even_nums=[x for x in range(10) if x%2==0]&gt;&gt;&gt; even_nums[0, 2, 4, 6, 8]&gt;&gt;&gt; even_nums=(x for x in range(10000) if x%2==0)&gt;&gt;&gt; even_nums&lt;generator object &lt;genexpr&gt; at 0x0265FF58&gt; 字符串函数 123456789101112131415161718192021222324252627&gt;&gt;&gt; s='Django is cool'&gt;&gt;&gt; s.split()['Django', 'is', 'cool']&gt;&gt;&gt; words=s.split()&gt;&gt;&gt; ' '.join()&gt;&gt;&gt; ' '.join(words)'Django is cool'&gt;&gt;&gt; '-'.join(words)'Django-is-cool'&gt;&gt;&gt; s.upper()'DJANGO IS COOL'&gt;&gt;&gt; s.upper().isupper()True&gt;&gt;&gt; s.title()'Django Is Cool'&gt;&gt;&gt; s.capitalize()'Django is cool'&gt;&gt;&gt; s.count('o')3&gt;&gt;&gt; s.find('go')4&gt;&gt;&gt; s.find('xxx')-1&gt;&gt;&gt; s.startswith('Python')False&gt;&gt;&gt; s.replace('Django','Python')'Python is cool' 字符串其他 1234567891011121314&gt;&gt;&gt; mystr=u'This is unicode'&gt;&gt;&gt; mystru'This is unicode'&gt;&gt;&gt; print mystrThis is unicode&gt;&gt;&gt; str(mystr)'This is unicode'&gt;&gt;&gt; hi='''hi... there'''&gt;&gt;&gt; hi'hi\nthere'&gt;&gt;&gt; print hihithere 元组 1234567891011121314&gt;&gt;&gt; a=("one","two")&gt;&gt;&gt; a[0]'one'&gt;&gt;&gt; b=("just-one")&gt;&gt;&gt; b[0]'j'&gt;&gt;&gt; b=("just-one",)&gt;&gt;&gt; b[0]'just-one'&gt;&gt;&gt; c='just-one',&gt;&gt;&gt; c('just-one',)&gt;&gt;&gt; c[0]'just-one' 字典 1234567891011121314151617181920212223242526272829303132333435&gt;&gt;&gt; book=&#123;'title':'Python Web Development','year':2008&#125;&gt;&gt;&gt; book&#123;'year': 2008, 'title': 'Python Web Development'&#125;&gt;&gt;&gt; 'year' in bookTrue&gt;&gt;&gt; 2008 in bookFalse&gt;&gt;&gt; book.get('pub','N/A')'N/A'&gt;&gt;&gt; book['pub']='Wesley'&gt;&gt;&gt; book.get('pub','N/A')'Wesley'&gt;&gt;&gt; for key in book:... print key,':',book[key]...year : 2008pub : Wesleytitle : Python Web Development&gt;&gt;&gt; del book['year']&gt;&gt;&gt; book&#123;'pub': 'Wesley', 'title': 'Python Web Development'&#125;&gt;&gt;&gt; len(book)2&gt;&gt;&gt; for k in book.keys():print k...pubtitle&gt;&gt;&gt; for v in book.values():print v...WesleyPython Web Development&gt;&gt;&gt; for i in book.items():print i...('pub', 'Wesley')('title', 'Python Web Development') 流程控制条件判断 1234567data = raw_input('Enter "y" or "n": ')if data[0] == 'y': print 'yes'elif data[0] == 'n': print 'no'else: print 'Invalid key entered' 循环 1234567i = 0while i &lt; 5: print i i += 1data = (123, 'abc', 3.14)for i,value in enumerate(data): print i,value 异常捕获12345678try: process_some_data()except (TypeError, ValueError), e: print "ERROR: you provide invalid data", eexcept ArithmeticError, e: print "ERROR: some math error occurred", eexcept Exception, e: print "ERROR: you provide invalid data", e finally 12345try: get_mutex() do_some_stuff()finally: free_mutex() 省事的写法 123456try: passexcept: passfinally: pass 抛出异常 123456789def foo(must_be_positive_int): """foo() -- take positive integer and process it""" # check if integer if not isinstance(must_be_positive_int, int): raise TypeError("ERROR foo(): must pass in an integer!") # check if positive if must_be_positive_int &lt; 1: raise ValueError("ERROR foo(): integer must be greater than zero!") # normal processing here 文件操作12345678f = open('1.txt', 'w')f.write('foo\n')f.write('bar\n')f.close()f = open('1.txt', 'r')for line in f: print line.rstrip()f.close() 函数函数声明和调用 123def foo(x): print xfoo(12) 一个有用的函数 123456789101112import httplibdef check_web_server(host, port, path): h = httplib.HTTPConnection(host, port) h.request('GET', path) resp = h.getresponse() print 'HTTP Response:' print ' status =', resp.status print ' reason =', resp.reason print 'HTTP Headers:' for hdr in resp.getheaders(): print ' %s: %s' % hdrcheck_web_server(port=80, path='/', host='www.python.org') 一个默认参数的例子 12345678910&gt;&gt;&gt; def func(arg=[]):... arg.append(1)... print arg...&gt;&gt;&gt; func()[1]&gt;&gt;&gt; func()[1, 1]&gt;&gt;&gt; func()[1, 1, 1] 函数引用 12345678def bar(): print 'bar'bar()baz = barbaz()func_list = [bar, baz]for f in func_list: f() 匿名函数 12345&gt;&gt;&gt; starList=[('bruce','li'),('jack','cheng'),('jet','li'),('danniel','yin')]&gt;&gt;&gt; sorted(starList)[('bruce', 'li'), ('danniel', 'yin'), ('jack', 'cheng'), ('jet', 'li')]&gt;&gt;&gt; sorted(starList, key=lambda star:star[1])[('jack', 'cheng'), ('bruce', 'li'), ('jet', 'li'), ('danniel', 'yin')] 可变参数 1234567891011121314151617181920212223242526&gt;&gt;&gt; def fun1(a,b,c):... print a,b,c...&gt;&gt;&gt; fun1(1,2,3)1 2 3&gt;&gt;&gt; l=['a','b','c']&gt;&gt;&gt; fun1(*l)a b c&gt;&gt;&gt; d=&#123;'a':1,'b':2,'c':3&#125;&gt;&gt;&gt; fun1(**d)1 2 3# 上面是传递参数的一种方式不是可变参数# 下面看真正的可变参数&gt;&gt;&gt; def fun2(*args,**kwargs):... print args... print kwargs...&gt;&gt;&gt; fun2(1,2,3)(1, 2, 3)&#123;&#125;&gt;&gt;&gt; fun2(1,2,3,a='1',b='2',c='3')(1, 2, 3)&#123;'a': '1', 'c': '3', 'b': '2'&#125;&gt;&gt;&gt; fun2(*l,**d)('a', 'b', 'c')&#123;'a': 1, 'c': 3, 'b': 2&#125; 装饰器 1234567891011121314151617181920&gt;&gt;&gt; def foo():... print 'foo run'...&gt;&gt;&gt; foo()foo run&gt;&gt;&gt; def log(func):... def wrapper():... print '%s() call begin'%func.__name__... func()... print '%s() call end'%func.__name__... return wrapper...&gt;&gt;&gt; @log... def foo1():... print 'foo1 run'...&gt;&gt;&gt; foo1()foo1() call beginfoo1 runfoo1() call end 面向对象类定义 12345678910111213141516class AddressBookEntry(object): version = 0.1 def __init__(self, name, phone): self.name = name self.phone = phone def update_phone(self, phone): self.phone = phone# 创建对象john = AddressBookEntry('John Doe', '408-555-1212')jane = AddressBookEntry('Jane Doe', '650-555-1212')# 实例调用john.update_phone('510-555-1212')john.phone# 动态实例属性john.xxx = 'abc'john.xxx 类继承 12345class EmployeeAddressBookEntry(AddressBookEntry): def __init__(self, name, phone, id, social): AddressBookEntry.__init__(self, name, phone) self.empid = id self.ssn = social 内部类 123class MyClass(object): class InnerClass: pass 总结以上是Python的入门教程，后面介绍Django入门。 Django快速上手Django声称自己是目前最完美的Web开发框架。本章整一个使用Django建立Blog站点的例子，看看Django到底怎么完美了。 安装我的python版本 12C:\Users\Administrator&gt;python --versionPython 2.7.12 常用安装方式 12&gt; pip install Django #安装最新版本&gt; pip install Django==1.8.2 #安装指定版本 我的网络不行，于是我是这么装的 12#解压安装包Django-1.8.2.tar.gz&gt; python setup.py install 验证安装是否成功 12&gt; python -c "import django;print django.VERSION"(1, 8, 2, 'final', 0) 搭建博客前面一直是在windows下写的，到这里突然发现在windows下来回切换目录还挺费劲，于是转到linux下了。这是我linux的环境： 1234$ python -VPython 2.7.5$ python -c 'import django;print django.get_version()'1.11.6 下面是建立博客站点的过程。 创建工程执行如下命令创建工程mysite： 1$ django-admin startproject mysite 创建成功后看看工程目录结构 12345678$ tree mysitemysite├── manage.py└── mysite ├── __init__.py ├── settings.py ├── urls.py └── wsgi.py 相关文件在后面会用到，这里就不介绍了。 运行开发服务执行命令运行工程。 12$ cd mysite$ python manage.py runserver 执行后会显示如下信息： 1234May 11, 2018 - 08:15:26Django version 1.11.6, using settings &apos;mysite.settings&apos;Starting development server at http://127.0.0.1:8000/Quit the server with CONTROL-C. 创建博客应用执行命令创建博客应用。 1$ python manage.py startapp blog 这时会在工程目录mysite下生成出一个blog应用目录，默认也建立好了几个文件。 创建模型创建模型就是到blog目录下修改models.py文件，修改内容如下： vim blog/models.py12345678910# -*- coding: utf-8 -*-from __future__ import unicode_literalsfrom django.db import models# Create your models here.class BlogPost(models.Model): title = models.CharField(max_length=150) body = models.TextField() timestamp = models.DateTimeField() 设置数据库首先要对mysite/settings.py做一处修改，加入blog应用。 123456789INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'blog',] 然后还是修改该配置文件，修改数据库（这里用的是默认的sqlite3）： 123456DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), &#125;&#125; 创建相关表执行命令： 12$ python manage.py migrate$ python manage.py makemigrations 这样会根据之前创建的模型自动创建数据库表。 admin修改blog/admin.py，修改如下： 1234567891011# -*- coding: utf-8 -*-from __future__ import unicode_literalsfrom django.contrib import adminfrom .models import BlogPost# Register your models here.#admin.site.register(BlogPost)class BlogPostAdmin(admin.ModelAdmin): list_display = ('title', 'timestamp')admin.site.register(BlogPost, BlogPostAdmin) 执行命令创建超级用户： 1$ python manage.py createsuperuser 查看mysite/urls.py下是否有相应记录。 123456from django.conf.urls import urlfrom django.contrib import adminurlpatterns = [ url(r'^admin/', admin.site.urls),] 这样后就可以用创建的用户登录网站进行BlogPost数据表管理了http://localhost:8000/admin。 制作博客显示页在blog目录下创建templates目录，在其下创建模板文件。 base.html12345678910111213&lt;html&gt;&lt;style type="text/css"&gt;body &#123; color: #efd; background: #453; padding: 0 5em; margin: 0 &#125;h1 &#123; padding: 2em 1em; background: #675 &#125;h2 &#123; color: #bf8; border-top: 1px dotted #fff; margin-top: 2em &#125;p &#123; margin: 1em 0 &#125;&lt;/style&gt;&lt;body&gt;&lt;h1&gt;mysite.example.com&lt;/h1&gt;&#123;% block content %&#125;&#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; archive.html12345678&#123;% extends "base.html" %&#125;&#123;% block content %&#125;&#123;% for post in posts %&#125;&lt;h2&gt;&#123;&#123; post.title &#125;&#125;&lt;/h2&gt;&lt;p&gt;&#123;&#123; post.timestamp &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; post.body &#125;&#125;&lt;/p&gt;&#123;% endfor %&#125;&#123;% endblock %&#125; 编写视图方法，修改blog/views.py文件： 1234567891011# -*- coding: utf-8 -*-from __future__ import unicode_literalsfrom django.shortcuts import renderfrom .models import BlogPost# Create your views here.def archive(request): posts = BlogPost.objects.all() ctx = &#123;'posts': posts&#125; return render(request, 'archive.html', ctx) 修改mysite/urls.py，添加访问路径。 1234urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^blog/', include('blog.urls')),] 修改blog/urls.py文件，添加访问路径。 123urlpatterns = [ url(r'^blog/', 'blog.views.archive'),] 好了，可以访问了，输入网址http://localhost:8000/blog/ 开始]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[socket简单实例的不同语言实现]]></title>
    <url>%2F2018%2F05%2F10%2Fsocket%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B%E7%9A%84%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[先描述一个场景：服务端监听8888端口，接收客户端发送来的消息，服务端打印客户端地址后，把接收到的消息原样发回客户端，客户端收到服务端发回的消息后打印出来。使用socket的TCP和UDP分别实现一个。下面看不同语言下都是怎么实现的。 C实现TCP tcp-server.c12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;int main()&#123; int listenfd; int connfd; int len; struct sockaddr_in servaddr; struct sockaddr_in cliaddr; int sin_size; char buf[BUFSIZ]; memset(&amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(8888); listenfd = socket(AF_INET, SOCK_STREAM, 0); bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); listen(listenfd, 10); sin_size = sizeof(cliaddr); connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;sin_size); printf("accept client %s\n", inet_ntoa(cliaddr.sin_addr)); len = recv(connfd, buf, BUFSIZ, 0); send(connfd, buf, len, 0); close(connfd); close(listenfd); return 0;&#125; tcp-client.c123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;int main()&#123; int connfd; int len; struct sockaddr_in servaddr; char buf[BUFSIZ]; memset(&amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = inet_addr("127.0.0.1"); servaddr.sin_port = htons(8888); connfd = socket(AF_INET, SOCK_STREAM, 0); connect(connfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); send(connfd, "hello", strlen("hello"), 0); len = recv(connfd, buf, BUFSIZ, 0); printf("receive: %s\n", buf); close(connfd); return 0;&#125; UDP udp-server.c123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;int main()&#123; int sockfd; int len; struct sockaddr_in servaddr; struct sockaddr_in cliaddr; int sin_size; char buf[BUFSIZ]; memset(&amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(8888); sockfd = socket(AF_INET, SOCK_DGRAM, 0); bind(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); sin_size = sizeof(cliaddr); printf("wait for a packet\n"); len = recvfrom(sockfd, buf, BUFSIZ, 0, (struct sockaddr *)&amp;cliaddr, &amp;sin_size); printf("receive packet from %s\n", inet_ntoa(cliaddr.sin_addr)); sendto(sockfd, buf, len, 0, (struct sockaddr *)&amp;cliaddr, sizeof(cliaddr)); close(sockfd); return 0;&#125; udp-client.c123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;int main()&#123; int sockfd; int len; struct sockaddr_in servaddr; int sin_size; char buf[BUFSIZ]; memset(&amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = inet_addr("127.0.0.1"); servaddr.sin_port = htons(8888); sockfd = socket(AF_INET, SOCK_DGRAM, 0); sin_size = sizeof(servaddr); len = sendto(sockfd, "hello", strlen("hello"), 0, (struct sockaddr *)&amp;servaddr, sin_size); recvfrom(sockfd, buf, BUFSIZ, 0, (struct sockaddr *)&amp;servaddr, &amp;sin_size); printf("receive packet: %s\n", buf); close(sockfd); return 0;&#125; Java实现TCP TcpServer.java12345678910111213141516171819import java.net.*;import java.io.*;public class TcpServer &#123; public static void main(String[] args) throws Exception &#123; ServerSocket server = new ServerSocket(8888); Socket socket = server.accept(); String ip = socket.getInetAddress().getHostAddress(); System.out.println(ip); InputStream is = socket.getInputStream(); byte[] buf = new byte[1024]; is.read(buf, 0, buf.length); String info = new String(buf); OutputStream os = socket.getOutputStream(); byte[] data = info.getBytes(); os.write(data, 0, data.length); socket.close(); server.close(); &#125;&#125; TcpClient.java12345678910111213141516import java.net.*;import java.io.*;public class TcpClient &#123; public static void main(String[] args) throws Exception &#123; Socket socket = new Socket("127.0.0.1", 8888); OutputStream os = socket.getOutputStream(); byte[] data = "hello".getBytes(); os.write(data); InputStream is = socket.getInputStream(); byte[] buf = new byte[1024]; is.read(buf, 0, buf.length); String reply = new String(buf); System.out.println(reply); socket.close(); &#125;&#125; UDP UdpServer.java12345678910111213141516import java.net.*;public class UdpServer &#123; public static void main(String[] args) throws Exception &#123; DatagramSocket server = new DatagramSocket(8888); byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf, buf.length); server.receive(packet); String info = new String(buf, 0, packet.getLength()); InetAddress address = packet.getAddress(); int port = packet.getPort(); byte[] data = info.getBytes(); packet = new DatagramPacket(data, data.length, address, port); server.send(packet); server.close(); &#125;&#125; UdpClient.java1234567891011121314151617import java.net.*;public class UdpClient &#123; public static void main(String[] args) throws Exception &#123; InetAddress address = InetAddress.getByName("127.0.0.1"); int port = 8888; byte[] data = "hello".getBytes(); DatagramPacket packet = new DatagramPacket(data, data.length, address, port); DatagramSocket client = new DatagramSocket(); client.send(packet); byte[] buf = new byte[1024]; packet = new DatagramPacket(buf, buf.length); client.receive(packet); String reply = new String(buf, 0, packet.getLength()); System.out.println(reply); client.close(); &#125;&#125; Python实现TCP tcp-server.py12345678910import sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.bind(('', 8888))s.listen(8)conn,addr = s.accept()print addr[0]buf = conn.recv(1024)conn.send(buf)conn.close()s.close() tcp-client.py1234567import sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect(('127.0.0.1',8888))s.send('hello')data = s.recv(1024)print datas.close() UDP udp-server.py123456import sockets = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)s.bind(('',8888))data,addr = s.recvfrom(1024)s.sendto(data, addr)s.close() udp-client.py123456import sockets = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)s.sendto('hello', ('127.0.0.1',8888))data = s.recv(1024)print datas.close() 总结不同语言实现相同功能，从代码量来看，肯定是python最少。为减轻工作量，有必要学习python。]]></content>
      <categories>
        <category>语言对比</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>c</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gdb学习笔记]]></title>
    <url>%2F2018%2F05%2F09%2Fgdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[接连两篇笔记vim和makefile，vim可以看作是程序的编辑，makefile可以看作程序的编译，那么是时候再整一篇程序调试的文章了。linux下调试c/c++程序的命令是gdb，下面就记录一下gdb的常用操作。 常用调试命令只有用gcc -g生成的程序才能调试。 命令 说明 backtrace(bt) 查看堆栈 finish 运行完当前函数 frame(f) 帧号 选择栈帧 info(i) locals 查看当前栈帧局部变量值 list(l) 行号 列出源码 next(n) 执行下一行 print(p) 打印表达式的值 quit(q) 退出gdb调试环境 set var 修改变量的值 start 执行程序，在main的第一行语句前停下 step(s) 执行下一步（进入函数） kill 终止正在调试的程序 break(b) 行号 断点 break 函数名 断点 break 文件名:行号 断点 continue(c) 从当前位置开始继续执行 delete breakpoints 断点号 删除断点 display 变量名 跟踪某个变量 disable breakpoints 断点号 禁用断点 enable 断点号 启用断点 info(i) breakpoints 查看断点 run(r) 重新运行程序 undisplay 跟踪显示号 取消跟踪 watch 设置观察点 info(i) watchpoints 查看观察点 x x/7b input//从input变量处打印7个存储单元的内容 shell cmd 执行命令 set args 设置参数 show args 查看参数 show paths 查看程序运行路径 set environment varname=val 设置环境变量 show environment varname 查看环境变量 cd 切换目录 pwd 查看当前目录 info program 查看程序状态 clear 行号n 清除第n行上的断点 help 帮助 启动调试方法 gdb gdb core gdb 调试core文件查看系统是否支持dump core功能： 123$ ulimit -c或$ ulimit -a 配置系统使其支持生成core： 1$ ulimit -c unlimited gdb调试core文件： 1$ gdb a.out my.core 总结上面就是个简单的入门，要想深入还是要上网搜。]]></content>
      <categories>
        <category>linux.c</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>笔记</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[makefile学习笔记]]></title>
    <url>%2F2018%2F05%2F09%2Fmakefile%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[linux下开发c/c++程序需要写makefile，makefile是用来组织和构建工程的。其实不只编写c/c++程序要写makefile，所有语言的开发都可以写makefile，甚至所有的事情都可以。本篇就简要记录下写makefile常用操作。 make命令执行命令make时会在当前目录下寻找名称为makefile或Makefile的文件去执行，要指定执行哪个文件，需要执行如下命令： 1$ make -f Makefile.1 可以在运行make命令时定义变量，如：make CFLAGS=-O2 编写规则基本规则makefile由一组规则组成，每条规则的格式是： 123target ...: prerequisites ... command ... 例如： 123目标: 条件1 条件2 命令1 命令2 目标和条件之间的关系是：要更新目标必须先更新它所有的条件。有一个条件更新则目标也要被更新。 命令列表每行必须以tab开头。 常用的目标名： all #执行主要的编译工作，通常为缺省目标； install #执行编译后的安装工作； clean #清理编译结构； 隐含规则如果一个目标分开写多条规则，则只有其中一条规则允许有命令列表，否则以最后一条规则的命令列表执行。 隐含规则可以用make -p命令查看，例如省略了命令列表的规则就利用了隐含规则。 我们写makefile时不利用隐含规则也能完成相应工作，只不过就多写些罢了。 特殊变量 $@ #表示规则中的目标； $&lt; #表示规则中的第一个条件； $^ #表示规则中的所有条件； $? #表示规则中所有比目标新的条件； 实例源码设有如下源码文件： a.h1234#ifndef _A_H_#define _A_H_void hello_a();#endif b.h1234#ifndef _B_H_#define _B_H_void hello_b();#endif a.c123456#include "a.h"#include &lt;stdio.h&gt;void hello_a()&#123; printf("hello,a\n");&#125; b.c123456#include "b.h"#include &lt;stdio.h&gt;void hello_b()&#123; printf("hello,b\n");&#125; main.c12345678#include "a.h"#include "b.h"int main(void)&#123; hello_a(); hello_b(); return 0;&#125; 写makefile上面的源码如何通过makefile组织并构建工程呢？下面是普通写法： 123456main: main.o a.o b.o gcc -o $@ $^.c.o: gcc -c $&lt;clean: rm -f *.o main 上面的写法对c++代码一样有效，就是把gcc换成g++，把.c.o换成.cpp.o就可以。 高级一些的写法： 12345678910111213CC=gccCFLAGS = -Wall -O2CFLAGS += -I./ -L./LFLAGS = -lpthread -lmSRCS = a.c \ b.c \ main.cOBJS=$(SRCS:.c=.o)EXEC=testall:$(OBJS) $(CC) $(CFLAGS) $(OBJS) -o $(EXEC) $(LFLAGS)clean: rm -f $(EXEC) $(OBJS) 总结以上记录的这些作为入门已经够了，要想更深入学习可以网上搜索跟我一起写Makefile，跟高手学习更好。]]></content>
      <categories>
        <category>linux.c</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>笔记</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim使用笔记]]></title>
    <url>%2F2018%2F05%2F09%2Fvim%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[对常在linux下写代码的人来说，编辑器首推vim和emacs。emacs号称神的编辑器，我觉得这是因为它是GNU大神Stallman开发的缘故，我也用过一段时间emacs，但是一般系统安装时都默认不会安装它，于是后来不常用了。而vim一般系统上都会带着，那这篇就记录一下号称编辑器之神的vim的常见使用方法。 常用配置linux下的配置vim ~/.vimrc 123456789syntax on #语法高亮set nocompatible #去掉vi一致性模式set number #显示行号set autoindent #自动对齐set smartindent #智能对齐set cindent #c语言风格对齐set tabstop=4 #设置tab键为4空格set shiftwidth=4 #自动缩进时为4空格set textwidth=0 #设置不自动换行 windows下的配置下面是我在windows下使用vim时的终极配置，主要解决UTF8文件乱码问题。 vim %VIMHOME%/_vimrc 123456789101112set encoding=utf-8set fileencodings=utf-8,gbk,cp936language messages zh_CN.utf-8source $VIMRUNTIME/delmenu.vimsource $VIMRUNTIME/menu.vimset termencoding=cp936#解决终端乱码set nobackupset aiset siset ciset ts=4set sw=4 其它配置其实vim配置文件中是以双引号注释的，我写这篇文章的时候加双引号老是语法高亮，于是我就用了linux下的常用注释方式。 有些配置写在配置文件中不是很合适，因为在文档编辑过程中可能经常修改，这里列出来。 123456789set nu #显示行号set nonu #关闭行号set paste #设为粘贴模式，粘贴时不自动缩进set nopaste #关闭粘贴模式set ff? #显示当前文件格式set ff=unix #将文件转换成unix格式set ff=dos #将文件转换为dos格式set ignorecase|ic #设置查找时忽略大小写set noignorecase|noic #查找时不忽略大小写 常用操作移动光标 操作 说明 hjkl 前下上右 ctrl-f,ctrl-b 向下、向上翻页 0,$ 移动到行的最前、最后 ^ 移动到一行除空白外的最前 G,nG,gg 移动到最后、第n、第一行 zz,zt,zb 光标所在的行居中、上、下 一般模式下输入数字n回车 向下移动n行 搜索和替换 操作 说明 /word 搜索单词word n,N 向下、向上搜 :n1,n2s/w1/w2/g 替换n1-n2行间的w1为w2 :1,$s/w1/w2/g 替换所有 :%s/w1/w2/g 替换所有 :%s/word//gn 统计word出现次数 正则表达式批量注释ctrl+v 进入列编辑模式,向下或向上移动光标,把需要注释的行的开头标记起来,然后按大写的I(shift+i),再插入注释符,比如”//“,再按Esc,就会全部注释了 ctrl+v,进入列编辑模式,横向选中列的个数(如”//“注释符号,需要选中两列),然后按d, 就会删除注释符号 windows下为ctrl+q 批量缩进：v进入可视模式，选择要缩进的代码块，&gt;缩进、&lt;缩回 查找选中的内容 v h/j/k/l y / ctrl-r 0 复制粘贴删除等操作 操作 说明 x,X 向后、向前删除一个字符 nx 向后删除n个字符 dd,ndd 删除1行、n行 yy,nyy 复制1行、n行 p,P 在光标后、前粘贴 u 撤销 ctrl-r 重做 . 重复上个动作 模式切换一般模式到编辑模式使用vim打开一个文件时默认进入一般模式。 操作 说明 i,I 插入 a,A 增加 o,O 新行 r,R 取代模式 按下esc键 退出编辑模式 一般模式到命令模式在一般模式下按下:键即可进入命令模式。命令模式下的常见操作有： 操作 说明 :w,:q,:wq,:q!,:x 保存、退出 :w filename 另存为 :r filename 读入到当前 :e filename 编辑另一个文件 :! cmd 执行命令cmd :set xxx 设置xxx项，如:set tw=0 编程时常用操作 操作 说明 % 括号匹配 ctrl-p 自动补全 :cd /p/p1/ 切换目录 :pwd 当前工作目录 :ls 当前打开的所有文件 :bd 关闭当前文件 shift+v 视图，用于选择文本 ggVGyy 全选复制 ctrl+6 两个打开的文件间切换 :bn 下一个文件 :bp 上一个文件 b1~n 切换至第n个打开的文件 :sp 水平分割窗口 :vsp 垂直分割窗口 :close 关闭分割窗口 ctrl+w+h/j/k/l 切换至前/下/上/后的窗口 ctrl+ww 一次向后切换 = 格式化选中内容 gu,gU 转换成小写、大写 J 合并下一行 :g/^/m0 倒置文件内容 :10,20s#^#//#g 用//注释10到20行 :10,20s#^//##g 删除10到20行的注释// 剪贴板使用将系统剪贴板内容粘贴进当前buffer中：在编辑模式下按shift+insert :reg #查看剪贴板内容 选中文本，”+y复制到系统剪贴板，”+p将系统剪贴板内容粘贴到普通模式下的光标所在处 更多操作 操作 说明 :E 浏览目录 :bn/bp/bl/bf 向后/向前/最后/第一个缓冲区切换 :He(!) 在下（上）面分屏浏览目录 :Ve(!) 在左（右）边分屏浏览目录 :Te tab页浏览文件 gt 下一个tab页 gT 上一个tab页 {i}gt 到第i个tab页 tabs 查看所有tab页编号-名 guu 把一行全部变成小写 gUU 把一行全部变成大写 ga 查看光标处字符的ascii码 g8 查看光标处字符的utf8编码 */# 查找光标处的单词 ctrl-o 向后回退光标移动 ctrl-l 向前追赶光标移动 ‘’ 两个单引号，跳转到光标上次停靠 :cw 在分屏中显示命令结果 gd 高亮显示光标处的单词 ctrl-w,q 退出当前窗口 :edit ++enc=cp936 buffer设为gb2312查看 :edit ++enc=utf-8 buffer设为utf-8查看 cw change word c0 改变当前到行首 c$ 改变当前到行尾 z回车 当前行置顶 z. 当前行置中 z- 当前行置底 H/M/L 移动光标到当前屏的上/中/下 回车 移动光标到下一行首字符 - 移动光标到上一行首字符 ^ 移动光标到第一个非空字符 :resize +10 调整split窗口大小 :vertical resize -10 调整vertical split窗口大小 ci”,( 在“”或（）中输入 f字符 向后条到本行下一个字符]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tinyxml2使用学习]]></title>
    <url>%2F2018%2F05%2F08%2Ftinyxml2%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[平时做c/c++开发时经常需要解析xml文件，linux一般就用libxml2做，但是更多时候写的代码需要在linx下跑也要在windows下跑，即使在windows有可能是vc写的还有可能是qt写的。这时解析xml就不那么方便。这里推荐一个tinyxml2开源库，使用了它，解析xml会轻松很多。 tinyxml2的使用比较简单，从官网指定的github地址上下载两个文件（tinyxml2.h、tinyxml2.cpp），然后项目中用到时加入就行了。 这篇文章直接上一个实例，通过这个实例应该可以学会如何使用tinyxml2进行xml的常用操作。 道生一，一生二，二生三，三生万物 废话少说，直接贴代码。 这是提前写好的xml文件：user.xml 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;users&gt; &lt;user name="aaa" age="33"/&gt; &lt;user name="bbb" age="22"/&gt;&lt;/users&gt; 这是实例代码文件：test1.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include "tinyxml2.h"using namespace tinyxml2;using namespace std;int main()&#123; cout&lt;&lt;"tinyxml2 test1."&lt;&lt;endl; cout&lt;&lt;"--------------------------"&lt;&lt;endl; cout&lt;&lt;"read from file."&lt;&lt;endl; cout&lt;&lt;"--------------------------"&lt;&lt;endl; XMLDocument doc; if (doc.LoadFile("./user.xml") != 0) &#123; cout&lt;&lt;"load xml file failed."&lt;&lt;endl; return 1; &#125; doc.Print(); cout&lt;&lt;"--------------------------"&lt;&lt;endl; cout&lt;&lt;"read from memory."&lt;&lt;endl; cout&lt;&lt;"--------------------------"&lt;&lt;endl; FILE *fp = fopen("user.xml", "r"); if (fp == NULL) &#123; cout&lt;&lt;"open file failed."&lt;&lt;endl; return 1; &#125; fseek(fp, 0, SEEK_END); int len = ftell(fp); cout&lt;&lt;"file length is "&lt;&lt;len&lt;&lt;endl; char *buf = (char*)malloc(len+1); memset(buf, 0, len+1); fseek(fp, 0, SEEK_SET); fread(buf, len, 1, fp); //printf("%s\n", buf); XMLDocument doc1; doc1.Parse(buf); free(buf); doc1.Print(); cout&lt;&lt;"--------------------------"&lt;&lt;endl; cout&lt;&lt;"get xml declaration"&lt;&lt;endl; cout&lt;&lt;"--------------------------"&lt;&lt;endl; XMLNode *decl = doc1.FirstChild(); XMLDeclaration *declaration = decl-&gt;ToDeclaration(); cout&lt;&lt;declaration-&gt;Value()&lt;&lt;endl; cout&lt;&lt;"--------------------------"&lt;&lt;endl; cout&lt;&lt;"add xml element"&lt;&lt;endl; cout&lt;&lt;"--------------------------"&lt;&lt;endl; XMLElement *root = doc1.RootElement(); XMLElement *userNode = doc1.NewElement("user"); userNode-&gt;SetAttribute("name", "ccc"); userNode-&gt;SetAttribute("age", "11"); root-&gt;InsertEndChild(userNode); userNode = doc1.NewElement("user"); userNode-&gt;SetAttribute("name", "xiaoming"); userNode-&gt;SetAttribute("age", "22"); XMLElement *descNode = doc1.NewElement("description"); XMLText *descText = doc1.NewText("xiaoming is a good boy"); descNode-&gt;InsertEndChild(descText); userNode-&gt;InsertEndChild(descNode); root-&gt;InsertEndChild(userNode); doc1.Print(); cout&lt;&lt;"--------------------------"&lt;&lt;endl; cout&lt;&lt;"find xml element"&lt;&lt;endl; cout&lt;&lt;"--------------------------"&lt;&lt;endl; XMLElement *userNode1 = root-&gt;FirstChildElement("user"); while (userNode1 != NULL) &#123; const char *name = userNode1-&gt;Attribute("name"); cout&lt;&lt;name&lt;&lt;endl; if (strcmp(name, "xiaoming") == 0) &#123; XMLElement *descNode1 = userNode1-&gt;FirstChildElement("description"); cout&lt;&lt;descNode1-&gt;GetText()&lt;&lt;endl; &#125; userNode1 = userNode1-&gt;NextSiblingElement(); &#125; cout&lt;&lt;"--------------------------"&lt;&lt;endl; cout&lt;&lt;"save xml element to file"&lt;&lt;endl; cout&lt;&lt;"--------------------------"&lt;&lt;endl; doc1.SaveFile("user1.xml"); cout&lt;&lt;"save ok"&lt;&lt;endl; return 0;&#125; 因为这个例子是一点点写成的，每修改一点就调用g++编译还比较费劲，就写了个makefile 12test1: test1.cpp tinyxml2.cpp g++ -o $@ $^ 这是执行测试程序后生出来的user1.xml 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;users&gt; &lt;user name="aaa" age="33"/&gt; &lt;user name="bbb" age="22"/&gt; &lt;user name="ccc" age="11"/&gt; &lt;user name="xiaoming" age="22"&gt; &lt;description&gt;xiaoming is a good boy&lt;/description&gt; &lt;/user&gt;&lt;/users&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[主流开发语言如何实现回调]]></title>
    <url>%2F2018%2F05%2F03%2Fcallback%E4%B8%BB%E6%B5%81%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[回调函数是很多流行开发语言都支持的，本文介绍一下各种语言都是怎么支持回调函数的。 什么是回调函数关于回调函数是什么，直接上一段引用： A callback function is a function passed into another function as an argument, which is then invoked inside the outer function to complete some kind of routine or action. 英语不好的我也大概知道什么意思：回调函数是一个函数，这个函数能作为参数传给另一个函数，另一个函数内部可以执行它。这个定义应该是javascript对回调函数的定义，其他语言也一个意思。 下面就介绍一下各种开发语言如何实现回调函数的。 Javascript回调函数，js肯定首当其冲，不多说，直接上代码。 1234567function callback_fun() &#123; alert('hello, world.');&#125;function func1(cbf) &#123; cbf();&#125;func1(callback_fun); 回调函数有什么用处？我觉得就是用于应用解耦，便于遵循开闭原则进行代码开发。 做js开发的肯定用过jquery，jquery对回调函数应用到了令人发指的地步，可以说是无处不回调。看代码： 12345$(document).ready(function() &#123; $('#hello').click(function() &#123; alert('hello, world.'); &#125;);&#125;); 三行代码，连用两个回调函数，不知道jquery除了回调还会什么。 Python说js最擅长回调，python肯定第一个不服，就上面的例子，代码写的跟js一样多就算我输。 12345def callback_fun(): print 'hello, world.'def func1(cbf): cbf()func1(callback_fun) 怎么样，是不是比js少。 C/C++对于回调，C语言同样不甘示弱，但为什么有人对C的回调函数不理解呢？先看代码： 123456789void callback_fun(int n) &#123; printf("hello, world. %d\n", n);&#125;void func1(void cbf(int)) &#123; cbf(2);&#125;main() &#123; func1(callback_fun);&#125; 上面例子除了由于c语言定义变量时要指定类型外，其他没有什么麻烦的，无非就是记住回调函数作为参数时的写法。但事实真的是这样么？接着修改例子func1： 12345void func1(void cbf(int)) &#123; void (*f)(int); f = cbf; f(2);&#125; 必须写成这样，如果写成void f(int)是不行的。这是由于c语言中函数在定义的时候默认就是指针，但在声明变量时需要显式说明（这样描述我自己都理解不了，以后再说吧）。所以正规的回调函数写法应该这样： 123void func1(void (*cbf)(int)) &#123; (*cbf)(2);&#125; 但是这样写出来的回调函数却不符合我们平时写c代码的思维习惯，一般都是变量类型 变量名的形式。下面写一个符合正常习惯的回调例子。 1234567891011typedef void (*CALLBACK)(int);void cb_fun(int n) &#123; printf("%d\n", n);&#125;void func2(CALLBACK cbf) &#123; CALLBACK f = cbf; (*f)(4);&#125;main() &#123; func2(cb_fun);&#125; 用了一下typedef就使代码顺畅多了。 JavaJava是不支持函数回调的，因为Java中就根本没有函数这一说，在C/C++中函数是必须定义在全局的，类中那是方法，Java是不允许在类之外定义别任何变量，包括函数。但是这不影响java中使用回调，且在java中回调无处不在。写个例子： 123456789101112131415class Callback &#123; public void run() &#123; System.out.println("hello, world."); &#125;&#125;public class Test &#123; public void start(Callback cb) &#123; cb.run(); &#125; public static void main() &#123; Test t = new Test(); Callback cb = new Callback(); t.start(cb); &#125;&#125; 怎么样，想到了什么？多线程类Thread。我们常说的java实现多线程的方式有两种一是继承Thread，二是实现Runnable，其本质就一种就是执行Thread的start方法。只不过一是调用的重写的run而二是回调的实现的run而已。 总结以上是记录了我常用的开发语言的回调，以后用到别的语言再补充吧。]]></content>
  </entry>
  <entry>
    <title><![CDATA[C语言程序调用java代码]]></title>
    <url>%2F2018%2F04%2F26%2Fc-call-java%2F</url>
    <content type="text"><![CDATA[在计算机世界里，有些事是java不能办到的，而没有事是c/c++不能办到的，例如操作硬件设备。所以java调用c/c++是常有的事，而无所不能的c应该不常调用java。但实际情况也不尽然，如android系统（linux系统包装了java界面）里有时会有c程序执行完某功能后要通知java界面。这篇就记录一下c如何调用java。我这篇的代码基本都是抄的这篇，只是我简化修改了下，算是个笔记吧。 java代码 Person.java1234567891011121314public class Person &#123; private static String staticInfo = "this is a person"; private String name = "aaa"; public int age = 20; public static String getStaticInfo() &#123; return staticInfo; &#125; public String getName() &#123; return "aaa"; &#125; public int getAge() &#123; return age; &#125;&#125; 我为了追求例子简单写了这样一个不规范的代码，先说说哪里不规范： 声明成员变量的时候直接赋值了； 没写set方法； 没写构造函数；这样写出来的java代码平时可能没什么不妥，但是如果通过jni操作它，可能就会出现各种问题，有的问题我这篇最后都不知道怎么解决。所以以后写java代码时一定要规范！ 下面记录一个命令，用来查看java类签名：1javap -private -s Person java调用java测试 Main.java12345678public class Main &#123; public static void main(String[] args) &#123; Person p = new Person(); System.out.println(Person.getStaticInfo()); System.out.println(p.getName()); System.out.println(p.getAge()); &#125;&#125; 这里的java代码间的调用，确实没感觉出Person.java代码写的有何不妥。 c调用java测试C调用java的测试代码是这样的： main.c12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;jni.h&gt;int main()&#123; printf("c call java test.\n"); JavaVM *jvm = 0; JNIEnv *env = 0; JavaVMInitArgs jvm_args; JavaVMOption opt[1]; opt[0].optionString = "-Djava.class.path=."; memset(&amp;jvm_args, 0, sizeof(jvm_args)); jvm_args.version = JNI_VERSION_1_6; jvm_args.nOptions = 1; jvm_args.options = opt; long jvm_stat = JNI_CreateJavaVM(&amp;jvm, (void**)&amp;env, &amp;jvm_args); jclass cls = (*env)-&gt;FindClass(env, "Person"); jmethodID static_method = (*env)-&gt;GetStaticMethodID(env, cls, "getStaticInfo", "()Ljava/lang/String;"); jstring staticInfo = (jstring)(*env)-&gt;CallStaticObjectMethod(env, cls, static_method); const char *strInfo = (*env)-&gt;GetStringUTFChars(env, staticInfo, 0); printf("%s\n", strInfo); (*env)-&gt;ReleaseStringUTFChars(env, staticInfo, strInfo); jobject person = (*env)-&gt;AllocObject(env, cls); jmethodID get_name = (*env)-&gt;GetMethodID(env, cls, "getName", "()Ljava/lang/String;"); jstring name = (jstring)(*env)-&gt;CallObjectMethod(env, person, get_name); const char *strName = (*env)-&gt;GetStringUTFChars(env, name, 0); printf("%s\n", strName); (*env)-&gt;ReleaseStringUTFChars(env, name, strName); jfieldID age_field = (*env)-&gt;GetFieldID(env, cls, "name", "I"); (*env)-&gt;SetIntField(env, person, age_field, 33); jmethodID get_age = (*env)-&gt;GetMethodID(env, cls, "getAge", "()I"); jint age = (*env)-&gt;CallIntMethod(env, person, get_age); printf("%ld\n", age); return 0;&#125; 由于我的Person代码写的不正规，导致用c调用的时候有的问题现在也没解决，如上面代码中最后打印的age是0。如果是正规的java代码是好解决的。 makefilejava代码间调用是没必要写makefile的，但是c调用java的代码在编译运行的时候要设好几个地方，还是直接上一个makefile吧。 makefile123456789JDKHOME = /opt/jdk1.7.0_79LIBJVM = $(JDKHOME)/jre/lib/amd64/server/libjvm.soINCS = -I$(JDKHOME)/include -I$(JDKHOME)/include/linuxmain: gcc $(INCS) main.c $(LIBJVM) -Wl,-rpath=$(JDKHOME)/jre/lib/amd64/server javac *.javaclean: rm a.out *.o *.class *.log 其他jni的文章先写到这里吧。以后要深入学习可以看这篇：https://blog.csdn.net/honjane/article/details/53959587]]></content>
      <categories>
        <category>Jni</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jni调用已有的c语言库]]></title>
    <url>%2F2018%2F04%2F25%2Fjni%E8%B0%83%E7%94%A8%E5%B7%B2%E6%9C%89%E7%9A%84c%E8%AF%AD%E8%A8%80%E5%BA%93%2F</url>
    <content type="text"><![CDATA[上一篇写了jni如何操作java对象，但是实际应用中一般不会这样干。我们使用jni的主要用途是调用现成的c语言好的动态库或静态库，那本文以linux下的c语言库为例子，介绍一下jni如何调用已经写好的c语言库。 c语言库下面是一个c语言库的例子，直接贴代码。 mystr.h123void print_str();char* get_info();char* hello(char *name); mystr.c12345678910111213141516171819202122#include "mystr.h"#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void print_str()&#123; printf("中华人民共和国万岁，世界人民大团结万岁！\n");&#125;char* get_info()&#123; static char info[100]; strcpy(info, "我是中国人！"); return info;&#125;char* hello(char *name)&#123; char *s = "你好啊，"; char *buf = (char*)malloc(strlen(name)+strlen(s)+1); strcpy(buf, s); strcat(buf, name); return buf;&#125; mynum.h1int get_num1(); mynum.c12345#include "mynum.h"int get_num1()&#123; return 1;&#125; 生成动态库12$ gcc -fPIC -c mystr.c mynum.c$ gcc -shared -o libtest3.so mystr.o mynum.o 这个是分解动作，可以合成一个命令，看后面的makefile怎么写吧。 生成静态库12$ gcc -c mystr.c mynum.c$ ar cr libtest3.a mystr.o mynum.o 这是两个不同的命令，ar其实就是把.o文件打包（解包命令是这样的：ar -x libtest3.a），但是这样打出来的.a文件是不能被jni调用的（我现在是不会）。什么样的静态库文件能被jni调用呢？还是看后面的makefile文件。 Jni直接贴代码。 MyJni.java123456public class MyJni &#123; public native void printStr(); public native int getNum1(); public native String getInfo(); public native String hello(String name);&#125; MyJniImpl.c123456789101112131415161718192021222324252627282930#include "MyJni.h"#include "mystr.h"#include "mynum.h"#include &lt;stdlib.h&gt;JNIEXPORT void JNICALL Java_MyJni_printStr(JNIEnv *e, jobject o)&#123; print_str();&#125;JNIEXPORT jint JNICALL Java_MyJni_getNum1(JNIEnv *e, jobject o)&#123; return get_num1();&#125;JNIEXPORT jstring JNICALL Java_MyJni_getInfo(JNIEnv *env, jobject obj)&#123; char *info = get_info(); return (*env)-&gt;NewStringUTF(env, info);&#125;JNIEXPORT jstring JNICALL Java_MyJni_hello(JNIEnv *env, jobject obj, jstring name)&#123; const jbyte *strName = (*env)-&gt;GetStringUTFChars(env, name, 0); char *helloInfo = hello((char*)strName); (*env)-&gt;ReleaseStringUTFChars(env, name, strName); jstring info = (*env)-&gt;NewStringUTF(env, helloInfo); free(helloInfo); return info;&#125; 说明几点个人看法（不一定对） java只能加载jni动态库 jni遵循自己的内存自己释放的原则，但是需要手动调用，所以写jni代码的时候应该GetStringUTFChars和ReleaseStringUTFChars要成对出现 上面例子中故意没有遵循谁申请谁释放原则，在jni实现中调了free 测试直接贴代码。 main.c1234567891011#include "mystr.h"#include "mynum.h"#include &lt;stdio.h&gt;int main()&#123; print_str(); printf("%d\n", get_num1()); printf("%s\n", get_info()); printf("%s\n", hello("小明")); return 0;&#125; Main.java123456789101112public class Main &#123; static &#123; System.loadLibrary("myjni"); &#125; public static void main(String[] args) &#123; MyJni mj = new MyJni(); mj.printStr(); System.out.println(mj.getNum1()); System.out.println(mj.getInfo()); System.out.println(mj.hello("小明")); &#125;&#125; 正常情况这两个c和java的代码输出应该是一样的。 makefile123456789101112131415161718JDKHOME = $(JAVA_HOME)JNIINC = -I$(JDKHOME)/include -I$(JDKHOME)/include/linuxmain: lib_a jni_lib gcc main.c -L. -ltest3 javac Main.javalib_so: gcc -fPIC -shared -o libtest3.so mystr.c mynum.clib_a: gcc -fPIC -c mystr.c mynum.c ar cr libtest3.a mystr.o mynum.o rm mystr.o mynum.ojni_h: javac MyJni.java javah MyJnijni_lib: gcc $(JNIINC) -fPIC -shared -o libmyjni.so MyJniImpl.c -L. -ltest3clean: rm *.class *.o a.out libmyjni.so libtest3.so libtest3.a 把上面的main依赖的lib_a改成lib_so，可以分别测试jni调用c的静态库和动态库，如果不行就把静态库编译时也加上-fPIC重新编译下再说哦。因为别的我还不会(^o^)]]></content>
      <categories>
        <category>Jni</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jni操作Java对象]]></title>
    <url>%2F2018%2F04%2F24%2Fjni-operate-java-object%2F</url>
    <content type="text"><![CDATA[上一篇写了一下java使用jni的入门，这篇写一下如何通过jni操作java对象。用eclipse开发的不一定会开发java，就像上篇例子那样，离开eclipse只能写个helloworld，如果写个大型的java工程可能就不行了。本文也顺带记录一下不用eclipse怎么组织一个java工程。 工程结构这篇想手敲还挺费劲，由于命令较多，搞不好会有遗漏，还是写个makefile直接粘贴吧。工程结构很简单，如下：12345678910111213141516171819/root/devel/java/test2├── classes│ ├── a│ │ ├── b│ │ │ ├── c│ │ │ │ └── PersonJni.class│ │ │ └── Person.class│ │ └── Hello.class│ ├── a_b_c_PersonJni.h│ └── libperson.so└── src ├── a │ ├── b │ │ ├── c │ │ │ └── PersonJni.java │ │ └── Person.java │ └── Hello.java ├── makefile └── PersonJniImpl.c 我这个组织结构不一定合理，我的原则是需要手敲的所谓代码都放到src目录下，所有生成的东西都放到classes目录下。 写makefile123456789101112JDKHOME = /opt/jdk1.7.0_79INCS = -I$(JDKHOME)/include -I$(JDKHOME)/include/linuxall: #javac a/Hello.java -d ../classes #javac a/b/Person.java -d ../classes find . -name &apos;*.java&apos; -exec javac &#123;&#125; -d ../classes \; cd ../classes &amp;&amp; javah a.b.c.PersonJni gcc $(INCS) -fPIC -shared -o ../classes/libperson.so PersonJniImpl.cclean: #find . -name &apos;*.class&apos; | xargs -I&#123;&#125; rm &#123;&#125; find ../classes -name &apos;*.class&apos; -exec rm &#123;&#125; \; rm ../classes/libperson.so -f 这里的makefile是为了方便写这篇文章组织的，没有按照规范写，以后再写makefile的东西吧。 写java代码不多说了，直接贴代码 Person.java123456789101112131415161718192021222324252627package a.b;public class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; public String toString() &#123; return name + ":" + age; &#125; public static String getInfo() &#123; return "这是一个人"; &#125;&#125; PersonJni.java12345678910package a.b.c;import a.b.Person;public class PersonJni &#123; public native void test(); public native String getName(Person p); public native int getAge(Person p); public native String getInfo(); public native Person constructPerson(String name, int age); public native void setNameAge(Person p, String name, int age);&#125; Hello.java123456789101112131415161718192021package a;import a.b.Person;import a.b.c.PersonJni;public class Hello &#123; static &#123; System.loadLibrary("person"); &#125; public static void main(String[] args) &#123; Person p1 = new Person("小明", 22); System.out.println("hello, " + p1); PersonJni pj = new PersonJni(); pj.test(); System.out.println(pj.getName(p1)); System.out.println(pj.getAge(p1)); System.out.println(pj.getInfo()); Person p2 = (Person)pj.constructPerson("小红", 20); System.out.println("hello, " + p2); pj.setNameAge(p2, "小刚", 33); System.out.println("hello, " + p2); &#125;&#125; 写c代码写c代码之前要先make一下，这样能生成对应jni的头文件，然后就可以编写PersonJniImpl.c了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include "../classes/a_b_c_PersonJni.h"JNIEXPORT void JNICALL Java_a_b_c_PersonJni_test(JNIEnv *env, jobject obj)&#123; printf("this is jni test.\n");&#125;JNIEXPORT jstring JNICALL Java_a_b_c_PersonJni_getName(JNIEnv *env, jobject o, jobject p)&#123; jclass personClass = (*env)-&gt;GetObjectClass(env, p); jmethodID getName = (*env)-&gt;GetMethodID(env, personClass, "getName", "()Ljava/lang/String;"); jstring name = (jstring)(*env)-&gt;CallObjectMethod(env, p, getName); //const char *str = (*env)-&gt;GetStringUTFChars(env, name, 0); //return (*env)-&gt;NewStringUTF(env, str); return name;&#125;JNIEXPORT jint JNICALL Java_a_b_c_PersonJni_getAge(JNIEnv *env, jobject o, jobject p)&#123; jclass personClass = (*env)-&gt;GetObjectClass(env, p); jmethodID getAge = (*env)-&gt;GetMethodID(env, personClass, "getAge", "()I"); jint age = (*env)-&gt;CallIntMethod(env, p, getAge); return age;&#125;JNIEXPORT jstring JNICALL Java_a_b_c_PersonJni_getInfo(JNIEnv *env, jobject o)&#123; jclass personClass = (*env)-&gt;FindClass(env, "a/b/Person"); jmethodID getInfo = (*env)-&gt;GetStaticMethodID(env, personClass, "getInfo", "()Ljava/lang/String;"); jstring info = (jstring)(*env)-&gt;CallStaticObjectMethod(env, personClass, getInfo); return info;&#125;JNIEXPORT jobject JNICALL Java_a_b_c_PersonJni_constructPerson(JNIEnv *env, jobject o, jstring name, jint age)&#123; jclass personClass = (*env)-&gt;FindClass(env, "a/b/Person"); jmethodID personConstructMethod = (*env)-&gt;GetMethodID(env, personClass, "&lt;init&gt;", "(Ljava/lang/String;I)V"); jobject person = (*env)-&gt;NewObject(env, personClass, personConstructMethod, name, age); return person;&#125;JNIEXPORT void JNICALL Java_a_b_c_PersonJni_setNameAge(JNIEnv *env, jobject o, jobject p, jstring name, jint age)&#123; jclass personClass = (*env)-&gt;GetObjectClass(env, p); jmethodID setName = (*env)-&gt;GetMethodID(env, personClass, "setName", "(Ljava/lang/String;)V"); (*env)-&gt;CallVoidMethod(env, p, setName, name); jmethodID setAge = (*env)-&gt;GetMethodID(env, personClass, "setAge", "(I)V"); (*env)-&gt;CallVoidMethod(env, p, setAge, age);&#125; 这里需要强调一下，c和c++的jni实现的写法是不一样的。每个写一行对比一下吧。 c写法：1(*env)-&gt;GetObjectClass(env, p); c++写法：1env-&gt;GetObjectClass(p); 只要牵涉env指针操作的都是这个规律 编译、测试切换到makefile所在的目录，执行如下命令：1234$ make$ cd ../classes$ export LD_LIBRARY_PATH=.$ java a.Hello 测试结果：12345678Picked up _JAVA_OPTIONS: -Xmx2048m -XX:MaxPermSize=512m -Djava.awt.headless=truehello, 小明:22this is jni test.小明22这是一个人hello, 小红:20hello, 小刚:33 咦，结果中第一行是什么鬼？其实它是因为我设了一个_JAVA_OPTIONS的环境变量后出现的，因为我之前编译hadoop相关的的东西时，由于要求jvm内存很大，而默认的不能满足，所以设置了它。先不管，以后有时间再说个中含义吧。 附：打jar包通过上面的操作可以知道怎么组织java工程了，但是，我们平时执行java程序时一般不会拿一堆class文件去执行，一般都会打成个jar包。下面记录一下把上面生成的类文件打成jar包并能正常执行输出测试结果的过程。 假设现在还在makefile文件所在的src目录，执行如下命令：123$ cd ../classes$ tar cf hello.jar a #创建带自动生成的MANIFEST.MF文件的jar，这是执行测试是不行的，提示找不到主类$ tar xf hello.jar #解压包 修改解压出来的META-INF/MANIFEST.MF，修改内容如下（记住最后有个空行）：123Manifest-Version: 1.0Created-By: 1.7.0_79 (Oracle Corporation)Main-Class: a.Hello 前两行是打包时自动生成的，Main-Class: a.Hello是修改时添上的，意在指定主类（即main函数入口类）。 再执行如下命令重新打包，并测试执行：12$ jar cvfm hello1.jar META-INF/MANIFEST.MF a #经过这样打包就能找到主类了$ jar -jar hello1.jar #执行测试程序 经过以上操作，jar打包就完成了。]]></content>
      <categories>
        <category>Jni</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java通过jni调用c入门]]></title>
    <url>%2F2018%2F04%2F23%2Fjava-call-c-by-jni%2F</url>
    <content type="text"><![CDATA[JNI（Java Native Interface）是java平台的一部分，它允许java和其他语言写的代码交互。本篇记录java调用c函数的过程，通过一个helloworld程序说明在不同平台下是如何实现java调用c的。 过程记录编写java本地接口直接上代码：123public class HelloJni &#123; public native void sayHello();&#125; 如果要将一个方法作为本地方法，必须声明该方法为native，且不能实现。编译：javac HelloJni 编写本地接口的实现通过上述操作会生成一个HelloJni.h头文件，内容就不贴上来了。下面是本地接口的c语言实现：12345678/*HelloJniImpl.c*/#include &lt;jni.h&gt;#include "HelloJni.h"JNIEXPORT void JNICALLJava_HelloJni_sayHello(JNIEnv *env, jobject obj)&#123; printf("hello, world.\n");&#125; 生成动态库不同系统的不同编译环境下，生成动态库的方式是不一样的，下面记录几种常用的方式。 windows下用vc生成进入cmd执行命令：1&gt; cl -I%java_home%\include -I%java_home%\include\win32 -LD HelloJni.c -Fehello.dll 生成hello.dll动态库文件，供java本地调用。 windows下用mingw生成进入GitBash执行命令：1$ gcc -Wall -D_JNI_IMPLEMENTATION_ -Wl,--kill-at -I/c/Java/jdk/include -I/c/java/jdk/include/win32 -shared -o hello.dll HelloJni.c 其中-Wall -D_JNI_IMPLEMENTATION_不是必须的，但-Wl,--kill-at是必须的，否则生成的dll无法被java调用。 linux下生成linux下就相对简单一些，跟普通的动态库生成没有区别，上命令：1$ gcc -I$&#123;JAVA_HOME&#125;/include -I$&#123;JAVA_HOME&#125;/include/linux -fPIC -shared -o libhello.so HelloJni.c 注意linux下java根据动态库名字找的时候会拼上前缀lib，所以为了测试代码一致，直接生成libhello.so文件。 编写java测试程序直接上代码：123456789public class HelloWorld &#123; static &#123; System.loadLibrary("hello"); &#125; public static void main(String[] args) &#123; HelloJni hj = new HelloJni(); hj.sayHello(); &#125;&#125; 使用static块加载相应名称的动态库。12$ javac HelloWorld #编译$ java HelloWorld #测试运行 我的环境是64位win7，开始用的是64位jdk，但编译动态库用的是32位mingw，这样运行测试时提示64位环境不能调用32位动态库。换成32位jdk就好了。 另外，windows下是会在程序运行目录下自动寻找动态库，但linux下不会自动寻找程序当前目录，我一般的做法是export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.，这样做是为了让程序也找当前目录。 其他这篇文章是一个java调用c函数的入门，实际用途不大，例如调用的函数sayHello既没有返回值也没有参数，我们编写代码时一般不会写这样的函数。这就涉及到了相关数据类型的对应及转换问题。等再写一篇介绍吧。这里先贴上基本数据类型的对应关系。java|jni|c:—|:—|:—boolean|jboolean|unsigned charbyte|jbyte|charchar|jchar|unsigned shortshort|jshort|shortint|jint|longlong|jlong|__int64float|jfloat|floatdouble|jdouble|double]]></content>
      <categories>
        <category>Jni</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下qt开发环境搭建]]></title>
    <url>%2F2018%2F04%2F23%2Fwin7-qt-env-setup%2F</url>
    <content type="text"><![CDATA[Qt开发可以直接命令行进行，一般步骤是：写代码、编写工程文件.pro、qmake、make。对于习惯了vs、eclipse这样的IDE工具的开发人员，就必要用到qtcreator了。平时linux下用桌面环境很少，那么这篇介绍一下windows下如何搭建qt的IDE开发环境。 环境准备下面是我的环境 操作系统：windows7 64位 调试器：gdb-7.5-i686_WinXP.zip 编译器：MinGW-gcc440_1.zip QtCreator: qt-creator-opensource-windows-x86-4.0.3.exe Qt：qt-win-opensource-4.8.5-mingw.exe 搭建过程下面是我的qt开发环境搭建过程，我按如下顺序来的（不知道其他顺序行不）： 解压gdb-7.5-i686_WinXP.zip到c:\Qt\gdb-7.5-i686_WinXP 解压MinGW-gcc440_1.zip到c:\Qt\mingw 设置环境变量set path=%path%;c:\Qt\mingw\bin 安装qt-creator，路径是C:\Qt\qtcreator-4.0.3 安装qt，路径是C:\Qt\4.8.5，选择mingwc:\Qt\mingw 配置环境 选择菜单工具/选项/构建和运行/qt版本/，添加qmake路径c:/Qt/4.8.5/bin/qmake.exe 编译器路径经过如上步骤后应该能自动检测到，如果没有可以手动添加，选择菜单工具/选项/构建和运行/编译器，添加编译器路径C:\Qt\mingw\bin\g++.exe 不使用自动发现的调试器，手动添加工具/选项/构建和运行/Debuggers，添加调试器路径C:\Qt\gdb-7.5-i686_WinXP\gdb-i686-pc-mingw32.exe CMake选择C:\Qt\qtcreator-4.0.3\bin\jom.exe，据说可以提高编译速度 在构建套件中添加新套件，选择相应的编译器、调试器、qt版本、CMake Tool等 测试常用操作 vi编辑方式alt+vv，左手拇指按住alt键然后连按两次v键]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[REST接口调用客户端开发库例子]]></title>
    <url>%2F2018%2F04%2F13%2Frest-api-call-client%2F</url>
    <content type="text"><![CDATA[最近在写微服务相关的东西，微服务对外公布的rest api如何让不同语言的开发者方便调用呢？本文简单实现了个rest接口客户端调用库，可简单满足vc、qt、java开发者通过指定网关及其代理的微服务名访问具体的rest接口的需求。 vcvc下用的是大名鼎鼎的libcurl库封装rest调用，libcurl怎么用vc编译看上一篇文章，下面直接上代码吧 restcli.h123456789101112131415161718192021222324252627282930313233#ifndef RESTCLI_H#define RESTCLI_H#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class RestClient&#123;public: RestClient(); RestClient(string address, int port, string serviceName); void SetAuth(string appKey, string appSecret); void SetTimeout(int connTimeout, int timeout); bool Get(string path, string &amp;result); bool Post(string path, string &amp;result, string postData="");protected: void genBasePath(); void genAuthParam(); string getUrl(string path);private: string address; int port; string serviceName; string appKey; string appSecret; int connTimeout; int timeout; string basePath; string authParam;&#125;;#endif // RESTCLI_H restcli.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include "restcli.h"#include "curl.h"#include &lt;sstream&gt;static int writer(char *data, size_t size, size_t nmemb, std::string *writerData)&#123; if(writerData == NULL) return 0; writerData-&gt;append(data, size*nmemb); return size * nmemb;&#125;RestClient::RestClient()&#123; this-&gt;address = "localhost"; this-&gt;port = 80; this-&gt;serviceName = ""; this-&gt;appKey = ""; this-&gt;appSecret = ""; this-&gt;connTimeout = -1; this-&gt;timeout = -1; genBasePath(); genAuthParam();&#125;RestClient::RestClient(string address, int port, string serviceName)&#123; this-&gt;address = address; this-&gt;port = port; this-&gt;serviceName = serviceName; this-&gt;appKey = ""; this-&gt;appSecret = ""; this-&gt;connTimeout = -1; this-&gt;timeout = -1; genBasePath(); genAuthParam();&#125;void RestClient::genBasePath()&#123; ostringstream osPort; osPort&lt;&lt;this-&gt;port; this-&gt;basePath = "http://" + this-&gt;address + ":" + osPort.str() + "/"; if (this-&gt;serviceName.size() &gt; 0) this-&gt;basePath += this-&gt;serviceName + string("/");&#125;void RestClient::genAuthParam()&#123; if (appKey.size() &gt; 0) &#123; authParam = "appKey=" + appKey + "&amp;appSecret=" + appSecret; &#125;&#125;string RestClient::getUrl(string path)&#123; string url = basePath + path; if (authParam.size() == 0) return url; int pos = path.find("?"); if (pos &gt;= 0) &#123; url += "&amp;" + authParam; &#125; else &#123; url += "?" + authParam; &#125; return url;&#125;void RestClient::SetAuth(string appKey, string appSecret)&#123; this-&gt;appKey = appKey; this-&gt;appSecret = appSecret;&#125;void RestClient::SetTimeout(int connTimeout, int timeout)&#123; this-&gt;connTimeout = connTimeout; this-&gt;timeout = timeout;&#125;bool RestClient::Get(string path, string &amp;result)&#123; CURLcode code; CURL* curl = curl_easy_init(); if (curl == NULL) return false; string url = getUrl(path); curl_easy_setopt(curl, CURLOPT_URL, url.c_str()); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writer); curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;result); curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1); curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, this-&gt;connTimeout); curl_easy_setopt(curl, CURLOPT_TIMEOUT, this-&gt;timeout); code = curl_easy_perform(curl); curl_easy_cleanup(curl); if(code != CURLE_OK) return false; return true;&#125;bool RestClient::Post(string path, string &amp;result, string postData)&#123; CURLcode code; CURL* curl = curl_easy_init(); if (curl == NULL) return false; curl_easy_setopt(curl, CURLOPT_URL, getUrl(path).c_str()); curl_easy_setopt(curl, CURLOPT_POST, 1); curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postData.c_str()); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writer); curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;result); curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1); curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, this-&gt;connTimeout); curl_easy_setopt(curl, CURLOPT_TIMEOUT, this-&gt;timeout); code = curl_easy_perform(curl); curl_easy_cleanup(curl); if(code != CURLE_OK) return false; return true;&#125; qt之所以用libcurl进行http请求处理的一个重要原因就是为了想在vc下和qt下可以复用一套代码，所以qt的代码和vc的是一样的。具体qt的工程文件x.pro怎么写见上一篇文章 javajava处理http请求就简单多了，如果是springMVC工程下直接用个restTemplate就完成了，下面还是用java下最普遍使用的httpclient库实现。我建立maven工程，引入httpclient依赖4.5.5 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151public class RestClient &#123; String address = "localhost"; int port = 80; String serviceName = ""; String appKey = ""; String appSecret = ""; int connTimeout = -1; int timeout = -1; String basePath = ""; String authParam = ""; public RestClient() &#123; genBasePath(); genAuthParam(); &#125; public RestClient(String address, int port, String serviceName) &#123; this.address = address; this.port = port; this.serviceName = serviceName; genBasePath(); genAuthParam(); &#125; public void SetAuth(String appKey, String appSecret) &#123; this.appKey = appKey; this.appSecret = appSecret; &#125; public void SetTimeout(int connTimeout, int timeout) &#123; this.connTimeout = connTimeout; this.timeout = timeout; &#125; public boolean Get(String path, StringBuilder result) &#123; boolean ret = false; CloseableHttpClient httpClient = HttpClients.createDefault(); RequestConfig requestConfig = RequestConfig.custom() .setConnectTimeout(connTimeout) .setConnectionRequestTimeout(connTimeout) .setSocketTimeout(timeout).setRedirectsEnabled(true).build(); String url = getUrl(path); HttpGet httpGet = new HttpGet(url); httpGet.setConfig(requestConfig); try &#123; HttpResponse httpResponse = httpClient.execute(httpGet); int statusCode = httpResponse.getStatusLine().getStatusCode(); String s = EntityUtils.toString(httpResponse.getEntity(), "UTF-8"); if (statusCode == 200) &#123; result.append(s); ret = true; &#125; else &#123; ret = false; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; httpClient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return ret; &#125; public boolean Post(String path, StringBuilder result, String postData) &#123; boolean ret = false; CloseableHttpClient httpClient = HttpClients.createDefault(); RequestConfig requestConfig = RequestConfig.custom() .setConnectTimeout(connTimeout) .setConnectionRequestTimeout(connTimeout) .setSocketTimeout(timeout).setRedirectsEnabled(true).build(); String url = getUrl(path); HttpPost httpPost = new HttpPost(url); httpPost.setConfig(requestConfig); List&lt;BasicNameValuePair&gt; list = new ArrayList&lt;BasicNameValuePair&gt;(); String[] params = postData.split("&amp;"); for (String param : params) &#123; String[] nv = param.split("="); if (nv.length == 2) &#123; list.add(new BasicNameValuePair(nv[0], nv[1])); &#125; &#125; try &#123; UrlEncodedFormEntity entity = new UrlEncodedFormEntity(list, "UTF-8"); httpPost.setEntity(entity); HttpResponse httpResponse = httpClient.execute(httpPost); int statusCode = httpResponse.getStatusLine().getStatusCode(); String s = EntityUtils.toString(httpResponse.getEntity(), "UTF-8"); if (statusCode == 200) &#123; result.append(s); ret = true; &#125; else &#123; ret = false; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return ret; &#125; private String getUrl(String path) &#123; String url = basePath + path; if (authParam.length() == 0) return url; int pos = path.indexOf("?"); if (pos &gt;= 0) &#123; url += "&amp;" + authParam; &#125; else &#123; url += "?" + authParam; &#125; return url; &#125; private void genAuthParam() &#123; if (appKey.length() &gt; 0) &#123; authParam = "appKey=" + appKey + "&amp;appSecret=" + appSecret; &#125; &#125; private void genBasePath() &#123; if (port == 80) &#123; this.basePath = "http://" + this.address + "/"; &#125; else &#123; this.basePath = "http://" + this.address + ":" + port + "/"; &#125; if (this.serviceName.length() &gt; 0) this.basePath += this.serviceName + "/"; &#125; public static void testGet() throws Exception &#123; CloseableHttpClient httpClient = HttpClients.createDefault(); HttpGet httpGet = new HttpGet("http://www.baidu.com/"); HttpResponse httpRes = httpClient.execute(httpGet); String result = EntityUtils.toString(httpRes.getEntity(), "UTF-8"); System.out.println(result); httpClient.close(); &#125; public static void main(String[] args) throws Exception &#123; // RestClient.testGet(); RestClient rc = new RestClient("www.baidu.com", 80, ""); StringBuilder sb = new StringBuilder(""); boolean b = rc.Get("", sb); System.out.println(b); System.out.println(sb); &#125;&#125; 建maven工程的一个重要原因是想封装的rest访问库只要提供一个jar包就可以，如果普通工程恐怕要附带提供其他如httpclient.jar的包。~标记一下以后写maven的文章~ 参考文章*下面这些文章是我写上面这些时看过的，记录下来以备后看libcurl https://curl.haxx.se/libcurl/c/libcurl-tutorial.html https://blog.csdn.net/mao834099514/article/details/54947853 https://blog.csdn.net/lijinqi1987/article/details/53925835 https://www.cnblogs.com/jikexianfeng/p/6055024.html https://www.cnblogs.com/lidabo/p/4583061.html https://blog.csdn.net/ilovec1/article/details/52039672 https://blog.csdn.net/educast/article/details/47099607 qt https://blog.csdn.net/u012234115/article/details/71295785 httpclient https://www.cnblogs.com/c9999/p/6636415.html https://www.cnblogs.com/wutongin/p/7778996.html https://www.cnblogs.com/veitch-623/p/6259008.html https://blog.csdn.net/micro_hz/article/details/53157738]]></content>
      <categories>
        <category>Curl</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[curl入门教程]]></title>
    <url>%2F2018%2F04%2F12%2Fcurl-primer%2F</url>
    <content type="text"><![CDATA[平时进行文件传输的时候一般首先想到的是搭建文件传输服务器（这里不讨论微信QQ飞鸽），常见的文件传输服务器一般是ftp、http、samba。windows下一般就是登陆上相关服务器Ctrl-C或者右键另存为，但是习惯了linux命令行操作后会想到wget和curl，这里要说的是curl，因为最近写代码时用到了libcurl，再就是wget好像只能下载用。 curl命令用法Curl作为数据传输工具强到令人发指，下面先引用两段： curl是利用URL语法在命令行方式下工作的开源文件传输工具。它被广泛应用在Unix、多种Linux发行版中，并且有DOS和Win32、Win64下的移植版本。百度百科curl命令是一个利用URL规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称curl为下载工具。作为一款强力工具，curl支持包括HTTP、HTTPS、ftp等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。做网页处理流程和数据检索自动化，curl可以祝一臂之力。linux命令大全 curl命令的使用方法就参考上面提到的两篇文章吧。下面记录一下在微服务大行其道的今天如何用curl进行RESTful接口调用 测试REST接口请求方法为get：1$ curl -X GET -i &apos;http://localhost/person?id=1&apos; 请求方法为post：1curl -X POST -i &apos;http://localhost/person?id=1&apos; 带post字段的请求：1curl -X POST -i http://localhost/person --data &apos;name=aaa&amp;age=33&apos; 带http头字段的请求：1curl -X POST -H &apos;Content-Type: application/json&apos; -i http://localhost/person --data &apos;&#123;name:&quot;aaa&quot;,age:33,children:[&quot;x&quot;,&quot;y&quot;,&quot;z&quot;]&#125;&apos; 这些命令用做测试REST足够了，但是要在程序中调用就要用到libcurl了 windows下编译curl我写在简书上的文章 下载curl目前最新版本是7.59.0，要下载其他版本的可以到https://curl.haxx.se/download/?C=M;O=D vc编译我的开发环境是vs2008，对应vc9，在源码curl-7.59.0\projects\Windows\VC9目录下有相关工程文件，用vs2008打开就能编译，这里不写了。 命令行编译方法：12$ cd curl-7.59.0/winbuild$ nmake /f Makefile.vc mode=static vc=9 ENABLE_IDN=no debug=no 成功后在curl-7.59.0/builds/libcurl-vc9-x86-release-static-ipv6-sspi-winssl产生相关文件。 测试curl，curl http://www.baidu.com 测试libcurl： 用vs2008建立vc工程，编写测试代码 引入libcurl_a.lib 增加宏定义CURL_STATICLIB 修改运行时库/md 更多例子代码 mingw编译libcurl以前要单独安装mingw，现在有了git方便多了。123打开GitBash$ cd curl-7.59.0$ mingw32-make mingw32 完成后在lib目录下有3个文件，分别是： libcurl.a 静态库 libcurl.dll 动态库 libcurldll.a 动态倒入库 测试一下抄来的12$ gcc -I../../include -L../../lib simple.c -lcurldll$ gcc -I../../include -L../../lib simple.c -DCURL_STATICLIB -lcurl -lws2_32 -lwldap32 qt下使用libcurl这是我qt工程文件修改的部分：123INCLUDEPATH += D:/aaa_lcy/tmp/my-curl/curl-7.59.0/include/curlLIBS += D:/aaa_lcy/tmp/my-curl/curl-7.59.0/lib/libcurl.a -lws2_32 -lwldap32DEFINES += CURL_STATICLIB 其他linux下就不说了，mingw本身就是模拟linux]]></content>
      <categories>
        <category>Curl</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTTP文件传输]]></title>
    <url>%2F2018%2F04%2F11%2FHTTP%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%2F</url>
    <content type="text"><![CDATA[前言最近在用libcurl写REST接口调用的东西，联想到之前做的HTTP文件传输，又想到在windows下没有搭建成功hexo发布github环境。于是突然有个挺别致的想法：在我的工作机win7下写文章，写好后通过http上传到我的centos7上，然后再在centos上用hexo发布。 怎么样，是不是很别致？写一篇博客文章有N种简单方法，偏偏选这种绕来绕去的方法。算了，权当通过这种方式为近来的工作做笔记了。 搭建HTTP传输服务器要通过http进行文件传输，首先要有文件传输服务器。搭建http服务器第一反应会出现一大堆工具：windows自带的IIS、apache、tomcat、nginx等。这里不想说IIS，一是不想写windows下的工具，再就是图形界面的操作不截图不好说明，不会截图。这里也不想说nginx，因为nginx有别的主要功能，做文件传输服务器太浪费了。（标记一下以后专门写nginx的文章） 一种最简单的方式直接贴命令12$ python -m SimpleHTTPServer #默认开80端口，如果80在用执行下面这个指定一个端口$ python -m SimpleHTTPServer 8000 就一条命令的事，也没有什么配置，想在哪个目录下开服务就在那个目录下执行该命令，实在是简单。 但是，不允许写入文件。 apache httpd在linux下的http服务器首先想到的肯定是apache（也只能想到他），毕竟有大名鼎鼎的LAMP（标记一下以后专门写LAMP的文章）。修改配置文件/etc/httpd/conf/httpd.conf，这是centos7上的配置，其他linux下不知道是不是这个位置。1234567&lt;Directory &quot;/var/www/html/upload&quot;&gt; Dav On AllowOverride None Options All Order allow,deny Allow from all&lt;/Directory&gt; 不知道这些配置都是什么意思，就是从网上抄来的 执行命令chmod 777 /var/www/html/upload，看来777还是比666要管用。777是什么意思呢？就是二进制的111111111，表示所有用户的读写执行权限都开放，所以以后遇到目录读写权限的问题一律777（其实对http文件传输服务器来说666一样好使） apache tomcat用java做web开发肯定第一时间想到的是tomcat了。修改tomcat的conf下的web.xml，在servlet标签下添加如下配置项1234&lt;init-param&gt; &lt;param-name&gt;readonly&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; 意思很明显了，不能只读，我也不知道具体是哪个目录，反正就这样写了。然后建一个web项目，在其WebContent目录下建一个upload目录。（没有亲测，这是从别人那里抄来的） curl命令测试HTTP文件传输测试下载12$ curl -o 1.jpg http://ip/upload/a.jpg #指定名$ curl -O http://ip/upload/a.jpg #原名 测试上传1$ curl -T a.jpg http://localhost/upload/ 我在windows下传到linux下的中文内容的文件怎么处理？1$ iconv -f gbk -t utf-8 1.md &gt; 2.md 我在windows下传到linux下的中文名称的文件怎么处理？12$ convmv -f gbk -t utf-8 *.md #不直接转，只显示给人看$ convmv -f gbk -t utf-8 *.md --notest #直接转了 这个问题参考的这篇 java代码测试HTTP文件上传]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git学习笔记]]></title>
    <url>%2F2018%2F04%2F11%2FGit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言Git是一个开源的分布式的版本管理工具。Hexo依赖的nodejs肯定不能用一篇文章写，但是git作为一个代码管理工具，我觉得这一篇写足够了。所以以后不会再单独写git相关的文章，有需要记录的就像之前的hexo和markdown那样，都在这篇里面追加吧。 git的使用可以通过https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%91%BD%E4%BB%A4%E8%A1%8C学习，但是我使用git时可能就几个常用的操作，每次来这里翻看也麻烦，于是有了这篇。 笔记windows下安装git 下载合适版本 双击666 打开GitBash后发现这个太好了，由于其内置了mingw，里面几乎常用的linux命令都有了，下次再装windows系统的时候不再装gvim、putty、curl等乱七八糟的工具了，直接装git。 常用操作设置用户信息12$ git config --global user.name "John Doe"$ git config --global user.email johndoe@example.com 这一步应该是必须的，不然提交时不行。 帮助1$ git help 其实其他都是多余的，所有操作都能通过帮助解决 初始化仓库$ git init 添加及提交文件12$ git add *.c$ git commit -m &apos;说明&apos; 察看状态12$ git status$ git status -s #简要 忽略文件$ vim .gitignore 移出及移动文件12$ git rm test.txt$ git mv test.txt readme.md]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法笔记]]></title>
    <url>%2F2018%2F04%2F10%2FMarkdown%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[标题123456# H1## H2### H3#### H4##### H5###### H6 列表无序列表123- li- li- li 有序列表1231. li1. li1. li 链接直接连接1&lt;https://lcyasdlcy.github.io/&gt; 隐藏连接地址1[我的博客](https://lcyasdlcy.github.io/) 图片链接1![一张图片](https://lcyasdlcy.github.io/1.jpg) 引用123&gt; 引用1&gt; 引用2&gt; 引用3 强调粗体 **粗体**斜体 *斜体*删除 ~~删除~~分割线--- 表格 left center right 1 2 3 4 5 6 1234left|center|right-----|:---:|----:1|2|34|5|6]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用笔记]]></title>
    <url>%2F2018%2F04%2F10%2FHexo%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言我的博客站点建好了，之前写过一篇文章了。感觉很好，有总比没有强（聊胜于无）。 但是，访问几次我的博客后，自己都感觉不好意思了。 首页就把所有文章的内容都显示出来了，正常应该每篇文章只显示摘要信息吧？ home、archives、recent posts都是什么鬼，我们是中国人！ 正常博客的基本功能分类、标签、评论都去哪里了？ …… 既然用了hexo，就要相信他，上面这些对hexo来说都是小意思。本文会一一解决之。但是hexo毕竟只是个博客建站工具，除此别无他用，所以我计划只用这一篇文章记录hexo的使用，以后不再写相关的文章了，有需要记录的就这篇文章改吧。 下面进入hexo笔记正文。 笔记Hexo是什么 Hexo is a fast, simple &amp; powerful blog framework powered by Node.jshttps://hexo.io/ 在首页只显示每篇文章的摘要信息方式1在编写md文件内容时，在要显示的内容后、要隐藏的信息前加入一行&lt;!-- more --&gt; 方式2在md文件的fron-matter（每篇文章的开头部分）加入一项description，其值就是文章的摘要。 开启/关闭文章评论功能在front-matter中设置comments: true/false 为文章归档在front-matter中设置categories分类、设置tags标签。下面列出本文的front-matter：1234567title: Hexo使用笔记date: 2018-04-10 10:53:00tags: [tag1, tag2, tag3]categories: Hexocomments: truetoc: true #显示文章目录description: 使用Hexo搭建博客过程的问题笔记 怎么说好的toc、description等都不管用？换个主题试试 更改主题及语言下载主题1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 修改_post.yml12theme: nextlanguage: zh_Hans #应该是去找next主题下的zh_Hans.yml nani？评论还是不行，算了不管了，反正我也不是听人意见的人。有空参考一下https://www.zhihu.com/question/38797520这篇吧。 创建分类页、标签页12$ hexo new page categories$ hexo new page tags 修改categories/index.md12title: 分类type: &quot;categories&quot; 修改tags/index.md12title: 标签type: &quot;tags&quot; 最后别忘了hexo clean &amp; hexo g &amp; hexo d next主题设置头像拷贝要当头像的图片到themes/next/source/images目录下1cp drogba.pn themes/next/source/images 修改themes/next/_config.yml文件1avatar: /images/drogba.png next主题样式选择修改themes/next/_config.yml文件1234# Schemes#scheme: Musescheme: Mist#scheme: Pisces next主题菜单栏显示控制修改themes/next/_config.yml文件123456menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive 站内搜索安装相关插件12$ npm install hexo-generator-search --save$ npm install hexo-generator-searchdb --save 修改站配置_config.yml12345search: path: search.xml field: post format: html limit: 10000 修改主题配置themes/next/_config.yml12local_search: enable: true === 其他以后再补充===]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>tag1</tag>
        <tag>tag2</tag>
        <tag>tag3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我在github上的第一篇博文]]></title>
    <url>%2F2018%2F04%2F10%2F%E6%88%91%E5%9C%A8github%E4%B8%8A%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87%2F</url>
    <content type="text"><![CDATA[这是我在github上的第一篇博客文章，相比之前在博客园和CSDN上写的零散几篇，写在这里让我瞬间感觉档次提高不少。以后所有的技术相关的文章就在这里写吧。这篇写点什么呢？这个博客站点是用hexo搭建的，就先写一下搭建过程吧。 博客搭建过程windows下 windows7 64bitnode v8.9.3git version 2.15.1.windows.2 最终以失败告终，最后用hexo d往github上发布的时候出错，大概意思是/dev/tty不存在。不知道怎么处理，或者是自己没耐心。还是老实去linux下玩吧。 linux下linux下就简单了，大概记录一下操作步骤。环境准备： centos 7git是用yum安装的，没关心版本node v0.10.44 那么问题来了，hexo好像不支持这个版本的nodejs，我的nodejs还有别的用呢，怎么办？要不说linux下简单呢。且看如下操作步骤： 安装nodejsnvm是nodejs版本管理器，能任意切换nodejs版本，执行命令安装之。1$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh 或者wget到本地再运行也行，完事记得重启终端。 安装6版本的nodejs：nvm install 6安装8版本的nodejs：nvm install 8使用6版本的nodejs：nvm use 6 安装hexo1$ npm install hexo -g 创建博客站执行命令123$ mkdir myblog$ cd myblog$ hexo init 修改配置_config.yml123deploy: type: git repo: https://github.com/lcyasdlcy/lcyasdlcy.github.io.git 为避免每次发布都要输入用户名密码，可以将repo值写成如下格式：1https://username:password@github.com****** 更安全的方式当然还是用ssh公私钥，这里不说了写文章1$ hexo new post "我的第一篇博文" 或者直接到source/_posts目录下编写xxx.md文档，接下来就是考验markdown语法了。测试1$ hexo s 默认使用4000端口，访问http://localhost:4000看看。如果端口被占用了，使用hexo server -p 5000指定新的端口。 发布博客站到github安装自动部署发布工具hexo-deployer-git1$ npm install hexo-deployer-git --save 发布123$ hexo clean #清理$ hexo g #生成$ hexo d #部署 好了，以后每次想写文章了，重复上面的工作就可以了。]]></content>
  </entry>
</search>
