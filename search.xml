<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java通过jni调用c入门]]></title>
    <url>%2F2018%2F04%2F23%2Fjava-call-c-by-jni%2F</url>
    <content type="text"><![CDATA[JNI（Java Native Interface）是java平台的一部分，它允许java和其他语言写的代码交互。本篇记录java调用c函数的过程，通过一个helloworld程序说明在不同平台下是如何实现java调用c的。 过程记录编写java本地接口直接上代码：123public class HelloJni &#123; public native void sayHello();&#125; 如果要将一个方法作为本地方法，必须声明该方法为native，且不能实现。编译：javac HelloJni 编写本地接口的实现通过上述操作会生成一个HelloJni.h头文件，内容就不贴上来了。下面是本地接口的c语言实现：12345678/*HelloJniImpl.c*/#include &lt;jni.h&gt;#include "HelloJni.h"JNIEXPORT void JNICALLJava_HelloJni_sayHello(JNIEnv *env, jobject obj)&#123; printf("hello, world.\n");&#125; 生成动态库不同系统的不同编译环境下，生成动态库的方式是不一样的，下面记录几种常用的方式。 windows下用vc生成进入cmd执行命令：1&gt; cl -I%java_home%\include -I%java_home%\include\win32 -LD HelloJni.c -Fehello.dll 生成hello.dll动态库文件，供java本地调用。 windows下用mingw生成进入GitBash执行命令：1$ gcc -Wall -D_JNI_IMPLEMENTATION_ -Wl,--kill-at -I/c/Java/jdk/include -I/c/java/jdk/include/win32 -shared -o hello.dll HelloJni.c 其中-Wall -D_JNI_IMPLEMENTATION_不是必须的，但-Wl,--kill-at是必须的，否则生成的dll无法被java调用。 linux下生成linux下就相对简单一些，跟普通的动态库生成没有区别，上命令：1$ gcc -I$&#123;JAVA_HOME&#125;/include -I$&#123;JAVA_HOME&#125;/include/linux -fPIC -shared -o libhello.so HelloJni.c 注意linux下java根据动态库名字找的时候会拼上前缀lib，所以为了测试代码一致，直接生成libhello.so文件。 编写java测试程序直接上代码：123456789public class HelloWorld &#123; static &#123; System.loadLibrary("hello"); &#125; public static void main(String[] args) &#123; HelloJni hj = new HelloJni(); hj.sayHello(); &#125;&#125; 使用static块加载相应名称的动态库。12$ javac HelloWorld #编译$ java HelloWorld #测试运行 我的环境是64位win7，开始用的是64位jdk，但编译动态库用的是32位mingw，这样运行测试时提示64位环境不能调用32位动态库。换成32位jdk就好了。 另外，windows下是会在程序运行目录下自动寻找动态库，但linux下不会自动寻找程序当前目录，我一般的做法是export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.，这样做是为了让程序也找当前目录。 其他这篇文章是一个java调用c函数的入门，实际用途不大，例如调用的函数sayHello既没有返回值也没有参数，我们编写代码时一般不会写这样的函数。这就涉及到了相关数据类型的对应及转换问题。等再写一篇介绍吧。这里先贴上基本数据类型的对应关系。|java|jni|c||:—|:—|:—||boolean|jboolean|unsigned char||byte|jbyte|char||char|jchar|unsigned short||short|jshort|short||int|jint|long||long|jlong|__int64||float|jfloat|float||double|jdouble|double|]]></content>
      <categories>
        <category>Jni</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下qt开发环境搭建]]></title>
    <url>%2F2018%2F04%2F23%2Fwin7-qt-env-setup%2F</url>
    <content type="text"><![CDATA[Qt开发可以直接命令行进行，一般步骤是：写代码、编写工程文件.pro、qmake、make。对于习惯了vs、eclipse这样的IDE工具的开发人员，就必要用到qtcreator了。平时linux下用桌面环境很少，那么这篇介绍一下windows下如何搭建qt的IDE开发环境。 环境准备下面是我的环境 操作系统：windows7 64位 调试器：gdb-7.5-i686_WinXP.zip 编译器：MinGW-gcc440_1.zip QtCreator: qt-creator-opensource-windows-x86-4.0.3.exe Qt：qt-win-opensource-4.8.5-mingw.exe 搭建过程下面是我的qt开发环境搭建过程，我按如下顺序来的（不知道其他顺序行不）： 解压gdb-7.5-i686_WinXP.zip到c:\Qt\gdb-7.5-i686_WinXP 解压MinGW-gcc440_1.zip到c:\Qt\mingw 设置环境变量set path=%path%;c:\Qt\mingw\bin 安装qt-creator，路径是C:\Qt\qtcreator-4.0.3 安装qt，路径是C:\Qt\4.8.5，选择mingwc:\Qt\mingw 配置环境 选择菜单工具/选项/构建和运行/qt版本/，添加qmake路径c:/Qt/4.8.5/bin/qmake.exe 编译器路径经过如上步骤后应该能自动检测到，如果没有可以手动添加，选择菜单工具/选项/构建和运行/编译器，添加编译器路径C:\Qt\mingw\bin\g++.exe 不使用自动发现的调试器，手动添加工具/选项/构建和运行/Debuggers，添加调试器路径C:\Qt\gdb-7.5-i686_WinXP\gdb-i686-pc-mingw32.exe CMake选择C:\Qt\qtcreator-4.0.3\bin\jom.exe，据说可以提高编译速度 在构建套件中添加新套件，选择相应的编译器、调试器、qt版本、CMake Tool等 测试常用操作 vi编辑方式alt+vv，左手拇指按住alt键然后连按两次v键]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[REST接口调用客户端开发库例子]]></title>
    <url>%2F2018%2F04%2F13%2Frest-api-call-client%2F</url>
    <content type="text"><![CDATA[最近在写微服务相关的东西，微服务对外公布的rest api如何让不同语言的开发者方便调用呢？本文简单实现了个rest接口客户端调用库，可简单满足vc、qt、java开发者通过指定网关及其代理的微服务名访问具体的rest接口的需求。 vcvc下用的是大名鼎鼎的libcurl库封装rest调用，libcurl怎么用vc编译看上一篇文章，下面直接上代码吧 restcli.h123456789101112131415161718192021222324252627282930313233#ifndef RESTCLI_H#define RESTCLI_H#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class RestClient&#123;public: RestClient(); RestClient(string address, int port, string serviceName); void SetAuth(string appKey, string appSecret); void SetTimeout(int connTimeout, int timeout); bool Get(string path, string &amp;result); bool Post(string path, string &amp;result, string postData="");protected: void genBasePath(); void genAuthParam(); string getUrl(string path);private: string address; int port; string serviceName; string appKey; string appSecret; int connTimeout; int timeout; string basePath; string authParam;&#125;;#endif // RESTCLI_H restcli.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include "restcli.h"#include "curl.h"#include &lt;sstream&gt;static int writer(char *data, size_t size, size_t nmemb, std::string *writerData)&#123; if(writerData == NULL) return 0; writerData-&gt;append(data, size*nmemb); return size * nmemb;&#125;RestClient::RestClient()&#123; this-&gt;address = "localhost"; this-&gt;port = 80; this-&gt;serviceName = ""; this-&gt;appKey = ""; this-&gt;appSecret = ""; this-&gt;connTimeout = -1; this-&gt;timeout = -1; genBasePath(); genAuthParam();&#125;RestClient::RestClient(string address, int port, string serviceName)&#123; this-&gt;address = address; this-&gt;port = port; this-&gt;serviceName = serviceName; this-&gt;appKey = ""; this-&gt;appSecret = ""; this-&gt;connTimeout = -1; this-&gt;timeout = -1; genBasePath(); genAuthParam();&#125;void RestClient::genBasePath()&#123; ostringstream osPort; osPort&lt;&lt;this-&gt;port; this-&gt;basePath = "http://" + this-&gt;address + ":" + osPort.str() + "/"; if (this-&gt;serviceName.size() &gt; 0) this-&gt;basePath += this-&gt;serviceName + string("/");&#125;void RestClient::genAuthParam()&#123; if (appKey.size() &gt; 0) &#123; authParam = "appKey=" + appKey + "&amp;appSecret=" + appSecret; &#125;&#125;string RestClient::getUrl(string path)&#123; string url = basePath + path; if (authParam.size() == 0) return url; int pos = path.find("?"); if (pos &gt;= 0) &#123; url += "&amp;" + authParam; &#125; else &#123; url += "?" + authParam; &#125; return url;&#125;void RestClient::SetAuth(string appKey, string appSecret)&#123; this-&gt;appKey = appKey; this-&gt;appSecret = appSecret;&#125;void RestClient::SetTimeout(int connTimeout, int timeout)&#123; this-&gt;connTimeout = connTimeout; this-&gt;timeout = timeout;&#125;bool RestClient::Get(string path, string &amp;result)&#123; CURLcode code; CURL* curl = curl_easy_init(); if (curl == NULL) return false; string url = getUrl(path); curl_easy_setopt(curl, CURLOPT_URL, url.c_str()); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writer); curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;result); curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1); curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, this-&gt;connTimeout); curl_easy_setopt(curl, CURLOPT_TIMEOUT, this-&gt;timeout); code = curl_easy_perform(curl); curl_easy_cleanup(curl); if(code != CURLE_OK) return false; return true;&#125;bool RestClient::Post(string path, string &amp;result, string postData)&#123; CURLcode code; CURL* curl = curl_easy_init(); if (curl == NULL) return false; curl_easy_setopt(curl, CURLOPT_URL, getUrl(path).c_str()); curl_easy_setopt(curl, CURLOPT_POST, 1); curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postData.c_str()); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writer); curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;result); curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1); curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, this-&gt;connTimeout); curl_easy_setopt(curl, CURLOPT_TIMEOUT, this-&gt;timeout); code = curl_easy_perform(curl); curl_easy_cleanup(curl); if(code != CURLE_OK) return false; return true;&#125; qt之所以用libcurl进行http请求处理的一个重要原因就是为了想在vc下和qt下可以复用一套代码，所以qt的代码和vc的是一样的。具体qt的工程文件x.pro怎么写见上一篇文章 javajava处理http请求就简单多了，如果是springMVC工程下直接用个restTemplate就完成了，下面还是用java下最普遍使用的httpclient库实现。我建立maven工程，引入httpclient依赖4.5.5 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151public class RestClient &#123; String address = "localhost"; int port = 80; String serviceName = ""; String appKey = ""; String appSecret = ""; int connTimeout = -1; int timeout = -1; String basePath = ""; String authParam = ""; public RestClient() &#123; genBasePath(); genAuthParam(); &#125; public RestClient(String address, int port, String serviceName) &#123; this.address = address; this.port = port; this.serviceName = serviceName; genBasePath(); genAuthParam(); &#125; public void SetAuth(String appKey, String appSecret) &#123; this.appKey = appKey; this.appSecret = appSecret; &#125; public void SetTimeout(int connTimeout, int timeout) &#123; this.connTimeout = connTimeout; this.timeout = timeout; &#125; public boolean Get(String path, StringBuilder result) &#123; boolean ret = false; CloseableHttpClient httpClient = HttpClients.createDefault(); RequestConfig requestConfig = RequestConfig.custom() .setConnectTimeout(connTimeout) .setConnectionRequestTimeout(connTimeout) .setSocketTimeout(timeout).setRedirectsEnabled(true).build(); String url = getUrl(path); HttpGet httpGet = new HttpGet(url); httpGet.setConfig(requestConfig); try &#123; HttpResponse httpResponse = httpClient.execute(httpGet); int statusCode = httpResponse.getStatusLine().getStatusCode(); String s = EntityUtils.toString(httpResponse.getEntity(), "UTF-8"); if (statusCode == 200) &#123; result.append(s); ret = true; &#125; else &#123; ret = false; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; httpClient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return ret; &#125; public boolean Post(String path, StringBuilder result, String postData) &#123; boolean ret = false; CloseableHttpClient httpClient = HttpClients.createDefault(); RequestConfig requestConfig = RequestConfig.custom() .setConnectTimeout(connTimeout) .setConnectionRequestTimeout(connTimeout) .setSocketTimeout(timeout).setRedirectsEnabled(true).build(); String url = getUrl(path); HttpPost httpPost = new HttpPost(url); httpPost.setConfig(requestConfig); List&lt;BasicNameValuePair&gt; list = new ArrayList&lt;BasicNameValuePair&gt;(); String[] params = postData.split("&amp;"); for (String param : params) &#123; String[] nv = param.split("="); if (nv.length == 2) &#123; list.add(new BasicNameValuePair(nv[0], nv[1])); &#125; &#125; try &#123; UrlEncodedFormEntity entity = new UrlEncodedFormEntity(list, "UTF-8"); httpPost.setEntity(entity); HttpResponse httpResponse = httpClient.execute(httpPost); int statusCode = httpResponse.getStatusLine().getStatusCode(); String s = EntityUtils.toString(httpResponse.getEntity(), "UTF-8"); if (statusCode == 200) &#123; result.append(s); ret = true; &#125; else &#123; ret = false; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return ret; &#125; private String getUrl(String path) &#123; String url = basePath + path; if (authParam.length() == 0) return url; int pos = path.indexOf("?"); if (pos &gt;= 0) &#123; url += "&amp;" + authParam; &#125; else &#123; url += "?" + authParam; &#125; return url; &#125; private void genAuthParam() &#123; if (appKey.length() &gt; 0) &#123; authParam = "appKey=" + appKey + "&amp;appSecret=" + appSecret; &#125; &#125; private void genBasePath() &#123; if (port == 80) &#123; this.basePath = "http://" + this.address + "/"; &#125; else &#123; this.basePath = "http://" + this.address + ":" + port + "/"; &#125; if (this.serviceName.length() &gt; 0) this.basePath += this.serviceName + "/"; &#125; public static void testGet() throws Exception &#123; CloseableHttpClient httpClient = HttpClients.createDefault(); HttpGet httpGet = new HttpGet("http://www.baidu.com/"); HttpResponse httpRes = httpClient.execute(httpGet); String result = EntityUtils.toString(httpRes.getEntity(), "UTF-8"); System.out.println(result); httpClient.close(); &#125; public static void main(String[] args) throws Exception &#123; // RestClient.testGet(); RestClient rc = new RestClient("www.baidu.com", 80, ""); StringBuilder sb = new StringBuilder(""); boolean b = rc.Get("", sb); System.out.println(b); System.out.println(sb); &#125;&#125; 建maven工程的一个重要原因是想封装的rest访问库只要提供一个jar包就可以，如果普通工程恐怕要附带提供其他如httpclient.jar的包。~标记一下以后写maven的文章~ 参考文章*下面这些文章是我写上面这些时看过的，记录下来以备后看libcurl https://curl.haxx.se/libcurl/c/libcurl-tutorial.html https://blog.csdn.net/mao834099514/article/details/54947853 https://blog.csdn.net/lijinqi1987/article/details/53925835 https://www.cnblogs.com/jikexianfeng/p/6055024.html https://www.cnblogs.com/lidabo/p/4583061.html https://blog.csdn.net/ilovec1/article/details/52039672 https://blog.csdn.net/educast/article/details/47099607 qt https://blog.csdn.net/u012234115/article/details/71295785 httpclient https://www.cnblogs.com/c9999/p/6636415.html https://www.cnblogs.com/wutongin/p/7778996.html https://www.cnblogs.com/veitch-623/p/6259008.html https://blog.csdn.net/micro_hz/article/details/53157738]]></content>
      <categories>
        <category>Curl</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[curl入门教程]]></title>
    <url>%2F2018%2F04%2F12%2Fcurl-primer%2F</url>
    <content type="text"><![CDATA[平时进行文件传输的时候一般首先想到的是搭建文件传输服务器（这里不讨论微信QQ飞鸽），常见的文件传输服务器一般是ftp、http、samba。windows下一般就是登陆上相关服务器Ctrl-C或者右键另存为，但是习惯了linux命令行操作后会想到wget和curl，这里要说的是curl，因为最近写代码时用到了libcurl，再就是wget好像只能下载用。 curl命令用法Curl作为数据传输工具强到令人发指，下面先引用两段： curl是利用URL语法在命令行方式下工作的开源文件传输工具。它被广泛应用在Unix、多种Linux发行版中，并且有DOS和Win32、Win64下的移植版本。百度百科curl命令是一个利用URL规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称curl为下载工具。作为一款强力工具，curl支持包括HTTP、HTTPS、ftp等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。做网页处理流程和数据检索自动化，curl可以祝一臂之力。linux命令大全 curl命令的使用方法就参考上面提到的两篇文章吧。下面记录一下在微服务大行其道的今天如何用curl进行RESTful接口调用 测试REST接口请求方法为get：1$ curl -X GET -i &apos;http://localhost/person?id=1&apos; 请求方法为post：1curl -X POST -i &apos;http://localhost/person?id=1&apos; 带post字段的请求：1curl -X POST -i http://localhost/person --data &apos;name=aaa&amp;age=33&apos; 带http头字段的请求：1curl -X POST -H &apos;Content-Type: application/json&apos; -i http://localhost/person --data &apos;&#123;name:&quot;aaa&quot;,age:33,children:[&quot;x&quot;,&quot;y&quot;,&quot;z&quot;]&#125;&apos; 这些命令用做测试REST足够了，但是要在程序中调用就要用到libcurl了 windows下编译curl我写在简书上的文章 下载curl目前最新版本是7.59.0，要下载其他版本的可以到https://curl.haxx.se/download/?C=M;O=D vc编译我的开发环境是vs2008，对应vc9，在源码curl-7.59.0\projects\Windows\VC9目录下有相关工程文件，用vs2008打开就能编译，这里不写了。 命令行编译方法：12$ cd curl-7.59.0/winbuild$ nmake /f Makefile.vc mode=static vc=9 ENABLE_IDN=no debug=no 成功后在curl-7.59.0/builds/libcurl-vc9-x86-release-static-ipv6-sspi-winssl产生相关文件。 测试curl，curl http://www.baidu.com 测试libcurl： 用vs2008建立vc工程，编写测试代码 引入libcurl_a.lib 增加宏定义CURL_STATICLIB 修改运行时库/md 更多例子代码 mingw编译libcurl以前要单独安装mingw，现在有了git方便多了。123打开GitBash$ cd curl-7.59.0$ mingw32-make mingw32 完成后在lib目录下有3个文件，分别是： libcurl.a 静态库 libcurl.dll 动态库 libcurldll.a 动态倒入库 测试一下抄来的12$ gcc -I../../include -L../../lib simple.c -lcurldll$ gcc -I../../include -L../../lib simple.c -DCURL_STATICLIB -lcurl -lws2_32 -lwldap32 qt下使用libcurl这是我qt工程文件修改的部分：123INCLUDEPATH += D:/aaa_lcy/tmp/my-curl/curl-7.59.0/include/curlLIBS += D:/aaa_lcy/tmp/my-curl/curl-7.59.0/lib/libcurl.a -lws2_32 -lwldap32DEFINES += CURL_STATICLIB 其他linux下就不说了，mingw本身就是模拟linux]]></content>
      <categories>
        <category>Curl</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTTP文件传输]]></title>
    <url>%2F2018%2F04%2F11%2FHTTP%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%2F</url>
    <content type="text"><![CDATA[前言最近在用libcurl写REST接口调用的东西，联想到之前做的HTTP文件传输，又想到在windows下没有搭建成功hexo发布github环境。于是突然有个挺别致的想法：在我的工作机win7下写文章，写好后通过http上传到我的centos7上，然后再在centos上用hexo发布。 怎么样，是不是很别致？写一篇博客文章有N种简单方法，偏偏选这种绕来绕去的方法。算了，权当通过这种方式为近来的工作做笔记了。 搭建HTTP传输服务器要通过http进行文件传输，首先要有文件传输服务器。搭建http服务器第一反应会出现一大堆工具：windows自带的IIS、apache、tomcat、nginx等。这里不想说IIS，一是不想写windows下的工具，再就是图形界面的操作不截图不好说明，不会截图。这里也不想说nginx，因为nginx有别的主要功能，做文件传输服务器太浪费了。（标记一下以后专门写nginx的文章） 一种最简单的方式直接贴命令12$ python -m SimpleHTTPServer #默认开80端口，如果80在用执行下面这个指定一个端口$ python -m SimpleHTTPServer 8000 就一条命令的事，也没有什么配置，想在哪个目录下开服务就在那个目录下执行该命令，实在是简单。 但是，不允许写入文件。 apache httpd在linux下的http服务器首先想到的肯定是apache（也只能想到他），毕竟有大名鼎鼎的LAMP（标记一下以后专门写LAMP的文章）。修改配置文件/etc/httpd/conf/httpd.conf，这是centos7上的配置，其他linux下不知道是不是这个位置。1234567&lt;Directory &quot;/var/www/html/upload&quot;&gt; Dav On AllowOverride None Options All Order allow,deny Allow from all&lt;/Directory&gt; 不知道这些配置都是什么意思，就是从网上抄来的 执行命令chmod 777 /var/www/html/upload，看来777还是比666要管用。777是什么意思呢？就是二进制的111111111，表示所有用户的读写执行权限都开放，所以以后遇到目录读写权限的问题一律777（其实对http文件传输服务器来说666一样好使） apache tomcat用java做web开发肯定第一时间想到的是tomcat了。修改tomcat的conf下的web.xml，在servlet标签下添加如下配置项1234&lt;init-param&gt; &lt;param-name&gt;readonly&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; 意思很明显了，不能只读，我也不知道具体是哪个目录，反正就这样写了。然后建一个web项目，在其WebContent目录下建一个upload目录。（没有亲测，这是从别人那里抄来的） curl命令测试HTTP文件传输测试下载12$ curl -o 1.jpg http://ip/upload/a.jpg #指定名$ curl -O http://ip/upload/a.jpg #原名 测试上传1$ curl -T a.jpg http://localhost/upload/ 我在windows下传到linux下的中文内容的文件怎么处理？1$ iconv -f gbk -t utf-8 1.md &gt; 2.md 我在windows下传到linux下的中文名称的文件怎么处理？12$ convmv -f gbk -t utf-8 *.md #不直接转，只显示给人看$ convmv -f gbk -t utf-8 *.md --notest #直接转了 这个问题参考的这篇 java代码测试HTTP文件上传]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git学习笔记]]></title>
    <url>%2F2018%2F04%2F11%2FGit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言Git是一个开源的分布式的版本管理工具。Hexo依赖的nodejs肯定不能用一篇文章写，但是git作为一个代码管理工具，我觉得这一篇写足够了。所以以后不会再单独写git相关的文章，有需要记录的就像之前的hexo和markdown那样，都在这篇里面追加吧。 git的使用可以通过https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%91%BD%E4%BB%A4%E8%A1%8C学习，但是我使用git时可能就几个常用的操作，每次来这里翻看也麻烦，于是有了这篇。 笔记windows下安装git 下载合适版本 双击666 打开GitBash后发现这个太好了，由于其内置了mingw，里面几乎常用的linux命令都有了，下次再装windows系统的时候不再装gvim、putty、curl等乱七八糟的工具了，直接装git。 常用操作设置用户信息12$ git config --global user.name "John Doe"$ git config --global user.email johndoe@example.com 这一步应该是必须的，不然提交时不行。 帮助1$ git help 其实其他都是多余的，所有操作都能通过帮助解决 初始化仓库$ git init 添加及提交文件12$ git add *.c$ git commit -m &apos;说明&apos; 察看状态12$ git status$ git status -s #简要 忽略文件$ vim .gitignore 移出及移动文件12$ git rm test.txt$ git mv test.txt readme.md]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法笔记]]></title>
    <url>%2F2018%2F04%2F10%2FMarkdown%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[标题123456# H1## H2### H3#### H4##### H5###### H6 列表无序列表123- li- li- li 有序列表1231. li1. li1. li 链接直接连接1&lt;https://lcyasdlcy.github.io/&gt; 隐藏连接地址1[我的博客](https://lcyasdlcy.github.io/) 图片链接1![一张图片](https://lcyasdlcy.github.io/1.jpg) 引用123&gt; 引用1&gt; 引用2&gt; 引用3 强调粗体 **粗体**斜体 *斜体*删除 ~~删除~~分割线--- 表格 left center right 1 2 3 4 5 6 1234left|center|right-----|:---:|----:1|2|34|5|6]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用笔记]]></title>
    <url>%2F2018%2F04%2F10%2FHexo%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言我的博客站点建好了，之前写过一篇文章了。感觉很好，有总比没有强（聊胜于无）。 但是，访问几次我的博客后，自己都感觉不好意思了。 首页就把所有文章的内容都显示出来了，正常应该每篇文章只显示摘要信息吧？ home、archives、recent posts都是什么鬼，我们是中国人！ 正常博客的基本功能分类、标签、评论都去哪里了？ …… 既然用了hexo，就要相信他，上面这些对hexo来说都是小意思。本文会一一解决之。但是hexo毕竟只是个博客建站工具，除此别无他用，所以我计划只用这一篇文章记录hexo的使用，以后不再写相关的文章了，有需要记录的就这篇文章改吧。 下面进入hexo笔记正文。 笔记Hexo是什么 Hexo is a fast, simple &amp; powerful blog framework powered by Node.jshttps://hexo.io/ 在首页只显示每篇文章的摘要信息方式1在编写md文件内容时，在要显示的内容后、要隐藏的信息前加入一行&lt;!-- more --&gt; 方式2在md文件的fron-matter（每篇文章的开头部分）加入一项description，其值就是文章的摘要。 开启/关闭文章评论功能在front-matter中设置comments: true/false 为文章归档在front-matter中设置categories分类、设置tags标签。下面列出本文的front-matter：1234567title: Hexo使用笔记date: 2018-04-10 10:53:00tags: [tag1, tag2, tag3]categories: Hexocomments: truetoc: true #显示文章目录description: 使用Hexo搭建博客过程的问题笔记 怎么说好的toc、description等都不管用？换个主题试试 更改主题及语言下载主题1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 修改_post.yml12theme: nextlanguage: zh_Hans #应该是去找next主题下的zh_Hans.yml nani？评论还是不行，算了不管了，反正我也不是听人意见的人。有空参考一下https://www.zhihu.com/question/38797520这篇吧。 创建分类页、标签页12$ hexo new page categories$ hexo new page tags 修改categories/index.md12title: 分类type: &quot;categories&quot; 修改tags/index.md12title: 标签type: &quot;tags&quot; 最后别忘了hexo clean &amp; hexo g &amp; hexo d next主题设置头像拷贝要当头像的图片到themes/next/source/images目录下1cp drogba.pn themes/next/source/images 修改themes/next/_config.yml文件1avatar: /images/drogba.png next主题样式选择修改themes/next/_config.yml文件1234# Schemes#scheme: Musescheme: Mist#scheme: Pisces next主题菜单栏显示控制修改themes/next/_config.yml文件123456menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive 站内搜索安装相关插件12$ npm install hexo-generator-search --save$ npm install hexo-generator-searchdb --save 修改站配置_config.yml12345search: path: search.xml field: post format: html limit: 10000 修改主题配置themes/next/_config.yml12local_search: enable: true === 其他以后再补充===]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>tag1</tag>
        <tag>tag2</tag>
        <tag>tag3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我在github上的第一篇博文]]></title>
    <url>%2F2018%2F04%2F10%2F%E6%88%91%E5%9C%A8github%E4%B8%8A%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87%2F</url>
    <content type="text"><![CDATA[这是我在github上的第一篇博客文章，相比之前在博客园和CSDN上写的零散几篇，写在这里让我瞬间感觉档次提高不少。以后所有的技术相关的文章就在这里写吧。这篇写点什么呢？这个博客站点是用hexo搭建的，就先写一下搭建过程吧。 博客搭建过程windows下 windows7 64bitnode v8.9.3git version 2.15.1.windows.2 最终以失败告终，最后用hexo d往github上发布的时候出错，大概意思是/dev/tty不存在。不知道怎么处理，或者是自己没耐心。还是老实去linux下玩吧。 linux下linux下就简单了，大概记录一下操作步骤。环境准备： centos 7git是用yum安装的，没关心版本node v0.10.44 那么问题来了，hexo好像不支持这个版本的nodejs，我的nodejs还有别的用呢，怎么办？要不说linux下简单呢。且看如下操作步骤： 安装nodejsnvm是nodejs版本管理器，能任意切换nodejs版本，执行命令安装之。1$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh 或者wget到本地再运行也行，完事记得重启终端。 安装6版本的nodejs：nvm install 6安装8版本的nodejs：nvm install 8使用6版本的nodejs：nvm use 6 安装hexo1$ npm install hexo -g 创建博客站执行命令123$ mkdir myblog$ cd myblog$ hexo init 修改配置_config.yml123deploy: type: git repo: https://github.com/lcyasdlcy/lcyasdlcy.github.io.git 为避免每次发布都要输入用户名密码，可以将repo值写成如下格式：1https://username:password@github.com****** 更安全的方式当然还是用ssh公私钥，这里不说了写文章1$ hexo new post "我的第一篇博文" 或者直接到source/_posts目录下编写xxx.md文档，接下来就是考验markdown语法了。测试1$ hexo s 默认使用4000端口，访问http://localhost:4000看看。如果端口被占用了，使用hexo server -p 5000指定新的端口。 发布博客站到github安装自动部署发布工具hexo-deployer-git1$ npm install hexo-deployer-git --save 发布123$ hexo clean #清理$ hexo g #生成$ hexo d #部署 好了，以后每次想写文章了，重复上面的工作就可以了。]]></content>
  </entry>
</search>
