<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python入门之模块]]></title>
    <url>%2F2018%2F05%2F18%2Fpython%E5%85%A5%E9%97%A8%E4%B9%8B%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[如果写一个简单的测试程序，现在的知识差不多了。但是如果写个复杂程序，需要多人协同作业，这时候就必须用到模块了。python中模块相当于java中的类路径，用法也很像；相当于c语言中的头文件。本篇记录一下python中如何使用模块。 模块概念基本都是抄的这里的。 对于一个复杂的功能，为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。 在Python中，一个.py文件就称之为一个模块（Module）。即一个文件被看作一个独立的模块，一个模块也可以被看做是一个文件。模块文件名字不能是数字开头。 使用模块可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。但是也要注意，尽量不要与内置函数名字冲突。 模块分三种： 内置模块：如sys, os, subprocess, time, json 等； 自定义模块：自定义模块时要注意命名，不能和Python自带的模块名称冲突。例如，系统自带了sys模块，自己的模块就不可命名为sys.py，否则将无法导入系统自带的sys模块。 开源模块：公开的第三方模块， 如 https://pypi.python.org/pypi 。可以使用pip install 安装。 在python解释器内执行help(&#39;modules&#39;)可以查看python所有的模块。 模块导入Python允许导入其它模块以实现代码重用，从而也实现了将独立的代码文件组织成更大的程序系统。模块是被导入的，但模块也可以导入和使用其他模块，这些模块可以用Python或其他编程语言写成。 在导入模块时只能使用模块名，而不是使用带.py后缀的模块文件名。 模块导入方式import语句，用于导入整个模块，如：12import sys,osimport random as rd from-import语句，用于导入指定模块的部分属性，如：123from socket import *from sys import pathfrom os import path as ospath 导入模块时到哪里查找？是在sys.path指定的目录下查找。 那是不是只要把路径加入sys.path了就能找了呢，并不是这样，还需要__init__.py文件。直接上个例子吧。 目录结构12345678910111213module-test/├── a│ ├── __init__.py│ └── m.py├── b│ ├── __init__.py│ └── m.py├── __init__.py├── m.py├── test│ ├── __init__.py│ └── test1.py└── test0.py 然后直接上各文件代码吧，自己感受一下啊。 __init__.py是空的。 m.py内容都一样，贴一个的代码：1print 'm' test0.py123import mimport a.mimport b.m test1.py12345678import sys,osfilepath = os.path.abspath(__file__)filedir = os.path.dirname(filepath)basedir = os.path.dirname(filedir)sys.path.append(basedir)import mimport a.mimport b.m 安装第三方模块 使用命令pip install 模块名 下载源码包使用命令python setup.py install 前面写的django就是个第三方模块，参考之前那篇。]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python入门之函数式编程]]></title>
    <url>%2F2018%2F05%2F18%2Fpython%E5%85%A5%E9%97%A8%E4%B9%8B%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Python是一门多范式编程语言，它在很大程度上支持函数式编程。那么什么是函数式编程呢？我的理解是函数的输入和输出都可以是函数的编程方式。当然我理解可能是错的，或者是片面的，本篇就通过搜集一些网上关于python函数式编程的资料，以期能更深入理解下函数式编程。 函数式编程先来段引用，出自百度百科。 函数式编程是种编程方式，它将电脑运算视为函数的计算。函数编程语言最重要的基础是λ演算（lambda calculus），而且λ演算的函数可以接受函数当作输入（参数）和输出（返回值）。和指令式编程相比，函数式编程强调函数的计算比指令的执行重要。和过程化编程相比，函数式编程里函数的计算可随时调用。 函数编程具有如下五个鲜明特点： 函数是一等公民：函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。 只用表达式不用语句：表达式(expression)是一个单纯的运算过程，总是有返回值；语句(statement)是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。 没有副作用：副作用(side effect)指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。 不修改状态：上一点已经提到，函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点。 引用透明性：函数程序通常还加强引用透明性，即如果提供同样的输入，那么函数总是返回同样的结果。就是说，表达式的值不依赖于可以改变值的全局状态。 函数式变成具有以下优点： 代码简洁，开发快速 接近自然语言，易于理解 更方便的代码管理 易于”并发编程” 代码的热升级 Python函数式编程高阶函数输入（参数）可以为函数的函数是高阶函数。例如：123def add(a, b, f): return f(a) + f(b)add(-1, -2, abs) 上面的add函数为自定义的高阶函数。python提供了一些高阶函数，如：map、reduce、filter、sorted等，下面介绍之。 map 天下大势，分久必合，合久必分，这里的map就是分，举例：求1到100每个整数的平方。 我们传统的思维应该是这样的：12345l = range(1, 101)l1 = []for i in l: l1.append(i*i)print l1 用map应该是这样的：1234def sq(i) return i*il2 = map(sq, l)print l2 其思想就是将之前依次每个求平方变为分别求平方，至于map是怎么分别的我就不管了。 或有人说，就这个还用这么费劲，我有更简单的：12l3 = [i*i for i in l]print l3 这个代码量上是简单了，但是本质还是上面的第一种，这只是python为简化此类操作提供的列表生成式。 那接着举例子，看你还有什么简单写法，求1到100的整数之和。这个最简单的方法就是背过了，呵呵5050，我们来看用reduce的实现。 reduce map应了分，reduce就应了合。就上面例子我们看reduce怎么做：123def add(a, b): return a + bsum = reduce(add, l) 好了，这就是reduce的使用例子了。正常思维的写法就不上代码了，至于有没有像上面列表生成式那种简单的写法我是不知道。 filter filter就是过滤器了，从已有列表中过滤出满足条件的。接着上例子列出1到100的所有偶数，看filter是怎么做的：123def even(i): return i%2 == 0l4 = filter(event, l) 就这么简单，当然列表生成式也可以很简单。 sorted 下面我们来把1到100的整数顺序打乱，使用sorted进行排序。1234import randoml = range(1,101)random.shuffle(l)sorted(l) 这样会从小到大排序，当然原来的列表顺序是不变的，会输出新列表。 sorted(l, reverse=True)这样就可以从大到小排序。下面看怎么自定义排序方式：12345678def cmp(a, b): if a &gt; b: return -1 elif a &lt; b: return 1 else: return 0sorted(l, cmp=cmp) 要想从大到小排序，就在第一个参数大于第二个参数时返回负数，反之就那样。我来个更兼的写法，顺便引出匿名函数：1sorted(l, cmp=lambda x,y:y-x) 匿名函数先来个例子lambda x,y:x+y，这里lambda表示匿名函数，空格后冒号前表示匿名函数的参数，冒号后只能有一个表达式，不能有return，表达式的运算结果表示函数的返回值。这样例子的匿名函数就与下面等效：12def func(x, y): return x + y 匿名函数也可以没有参数，也可以作为返回值返回，例如：1234def build(x, y): return lambda: x*x + y*yf = build(3,4)c = f() #这时c是25 闭包内层函数引用了外层函数的变量，然后返回内层函数的情况，称为闭包（closure）。抄个网上的例子：12345678def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fsf1, f2, f3 = count() 可以试一下什么结果。 闭包的特点是返回的函数还引用了外层函数的局部变量，所以，要正确使用闭包，就要确保引用的局部变量在函数返回后不能变。 装饰器python的装饰器（decorator）本质是一个高阶函数，它接收被装饰的函数作为参数，返回一个新瀚抒，这个新函数内部执行了被装饰的函数。下面来个装饰器例子：123456def log(func): def wrapper(*args, **kw): print 'before call %s()...'%func.__name__ func(*args,**kw) print 'after call %s()...'%func.__name__ return wrapper 上面定义了一个装饰器log，下面定义两个函数：1234def hello(): print 'hello,world.'def add(a,b): print a+b 那么，如何用装饰器来装饰它们呢，请看：1234f1 = log(hello)f2 = log(add)f1()f2(3,4) 但是，正常是没有这样用的，一般这样就好了：123456789@logdef hello(): print 'hello,world.'@logdef add(a,b): print a+bhello()add(3,4) 这下就方便多了。 类装饰器类装饰器这个名字是我自己取的，应该是不对的。反正我想表达的意思是在定义一个类的方法时经常会用到的@property、@staticmethod、@classmethod等。直接看例子吧。 @property1234567891011121314class Square: def __init__(self,sideLen): self.sideLen = sideLen @property def perimeter(self): return self.sideLen*4 @property def area(self): return self.sideLen*self.sideLen#测试s = Square(5)print s.sideLenprint s.areaprint s.perimeter @staticmethod12345678class Foo: @staticmethod def spam(x,y,z): print x,y,z#测试Foo.spam(1,2,3)f = Foo()f.spam(3,2,1) @classmethod1234567891011class A: @classmethod def test(cls): print cls.__name__class B: pass#测试A.test()B.test()b=B()b.test() 说明就不说了，我抄的这篇 总结我看https://www.liaoxuefeng.com关于python函数式编程还有偏函数，先不记录了。]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[古诗文收集]]></title>
    <url>%2F2018%2F05%2F14%2Fgushiwen-collection%2F</url>
    <content type="text"><![CDATA[这篇放松一下心情，先不写编程相关的，就抄录一下历代传唱的诗文。下面按照作品的产生朝代记录收集它们，收集的依据主要是耳熟能详或录入中小学课文的，因为我对古诗文了理解也就是中小学生的水平。其中穿插了些个人的不成熟甚至不正确的看法，爱咋咋地。 先秦先秦文学的精华主要集中在春秋战国时期，所谓百花齐放，百家争鸣，但中华文明讲的诸子百家儒术独尊，所以这里抄录的诗文主要是儒家典籍四书五经中的。再加上几篇老庄的，以及历史课本中认为不存在的屈原的。 诗经既然是收集古诗文，先秦必然首推诗经。下面摘抄几首： 关雎 关关雎鸠，在河之洲。窈窕淑女，君子好逑。参差荇菜，左右流之。窈窕淑女，寤寐求之。求之不得，寤寐思服。悠哉悠哉，辗转反侧。参差荇菜，左右采之。窈窕淑女，琴瑟友之。参差荇菜，左右芼之。窈窕淑女，钟鼓乐之。 蒹葭 蒹葭苍苍，白露为霜。所谓伊人，在水一方。溯洄从之，道阻且长。溯游从之，宛在水中央。蒹葭萋萋，白露未晞。所谓伊人，在水之湄。溯洄从之，道阻且跻。溯游从之，宛在水中坻。蒹葭采采，白露未已。所谓伊人，在水之涘。溯洄从之，道阻且右。溯游从之，宛在水中沚。 采薇 采薇采薇，薇亦作止。曰归曰归，岁亦莫止。 靡室靡家，猃狁之故。不遑启居，猃狁之故。采薇采薇，薇亦柔止。曰归曰归，心亦忧止。 忧心烈烈，载饥载渴。我戍未定，靡使归聘。采薇采薇，薇亦刚止。曰归曰归，岁亦阳止。 王事靡盬，不遑启处。忧心孔疚，我行不来！彼尔维何？维常之华。彼路斯何？君子之车。 戎车既驾，四牡业业。岂敢定居？一月三捷。驾彼四牡，四牡骙骙。君子所依，小人所腓。 四牡翼翼，象弭鱼服。岂不日戒？猃狁孔棘！昔我往矣，杨柳依依。今我来思，雨雪霏霏。 行道迟迟，载渴载饥。我心伤悲，莫知我哀！ 桃夭 桃之夭夭，灼灼其华。之子于归，宜其室家。桃之夭夭，有蕡其实。之子于归，宜其家室。桃之夭夭，其叶蓁蓁。之子于归，宜其家人。 屈原把屈原放在孔孟老庄之前，不是因为其名气或者时代，而是因为这篇主要是抄录古诗文的，而孔孟老庄胜在思想，严格说他们的作品不能算古诗文。屈原诗作众多，最有名的当然是离骚了，但是离骚太长了，这里就不抄了。同样的原因后面如孔雀东南飞，长恨歌等也不抄了。下面抄一首中学课本上的： 九章.涉江 余幼好此奇服兮，年既老而不衰。带长铗之陆离兮，冠切云之崔嵬，被明月兮佩宝璐。世混浊而莫余知兮，吾方高驰而不顾。驾青虬兮骖白螭，吾与重华游兮瑶之圃。登昆仑兮食玉英，与天地兮比寿，与日月兮同光。哀南夷之莫吾知兮，旦余济乎江湘。乘鄂渚而反顾兮，欸秋冬之绪风。步余马兮山皋，邸余车兮方林。乘舲船余上沅兮，齐吴榜以击汰。船容与而不进兮，淹回水而疑滞。朝发枉陼兮，夕宿辰阳。苟余心其端直兮，虽僻远之何伤？入溆浦余儃佪兮，迷不知吾所如。深林杳以冥冥兮，乃猿狖之所居。山峻高而蔽日兮，下幽晦以多雨。霰雪纷其无垠兮，云霏霏其承宇。哀吾生之无乐兮，幽独处乎山中。吾不能变心以从俗兮，固将愁苦而终穷。接舆髡首兮，桑扈裸行。忠不必用兮，贤不必以。伍子逢殃兮，比干菹醢。与前世而皆然兮，吾又何怨乎今之人。余将董道而不豫兮，固将重昏而终身。乱曰：鸾鸟凤凰，日以远兮。燕雀乌鹊，巢堂坛兮。露申辛夷，死林薄兮。腥臊并御，芳不得薄兮。阴阳易位，时不当兮。怀信侘傺，忽乎吾将行兮。 孔子千古一圣登场，但孔子是立说不著书的，所谓编春秋修六经也是相传。论语也只是孔子说的，门徒们记录的。说到圣人门徒，子最欣赏的是颜回，颜回应该是深得孔子立说不著书思想的，我是不知道回写过什么。那么，如果来了。 如果颜回不早逝，子肯定是要托孤回的。如果托孤了回，曾子就要靠边站了。曾子靠边站了，还能写出《大学》么。曾子不教子思，子思还能写出《中庸》么。子思如果不写书，孟子应该也不会写《孟子》了。 如此看来，是颜回卒于孔子之前，才导致了儒家典籍的井喷，不然单靠群弟子，记善言的《论语》很难将子推向圣人宝座。说多了，开始摘抄： 论语十二章 子曰：“学而时习之，不亦说乎？有朋自远方来，不亦乐乎？人不知而不愠，不亦君子乎？”《学而》曾子曰：“吾日三省吾身：为人谋而不忠乎？与朋友交而不信乎？传不习乎？”《学而》子曰：“吾十有五而志于学，三十而立，四十而不惑，五十而知天命，六十而耳顺，七十而从心所欲，不逾矩。”《为政》子曰：“温故而知新，可以为师矣。”《为政》子曰：“学而不思则罔，思而不学则殆。”《为政》子曰：“贤哉，回也！一箪食，一瓢饮，在陋巷，人不堪其忧，回也不改其乐。贤哉，回也！”《雍也》子曰：“知之者不如好之者，好之者不如乐之者。”《雍也》子曰：“饭疏食饮水，曲肱而枕之，乐亦在其中矣。不义而富且贵，于我如浮云。”《述而》子曰：“三人行，必有我师焉。择其善者而从之，其不善者而改之。”《述而》子在川上曰：“逝者如斯夫，不舍昼夜。”《子罕》子曰：“三军可夺帅也， 匹夫不可夺志也。”《子罕》子夏曰：“博学而笃志，切问而近思，仁在其中矣。”《子张》 论语十则 子曰：“学而时习之，不亦说乎?有朋自远方来，不亦乐乎?人不知而不愠，不亦君子乎?”（《学而》）曾子曰：“吾日三省吾身：为人谋而不忠乎？与朋友交而不信乎？传不习乎？”（《学而》）子曰：“温故而知新，可以为师矣。”（《为政》）子曰：“学而不思则罔,思而不学则殆。”（《为政》）子曰：“由，诲女知之乎！知之为知之，不知为不知，是知也。”（《为政》）子曰：“见贤思齐焉，见不贤而内自省也。”（《里仁》）子曰：“三人行，必有我师焉。择其善者而从之，其不善者而改之。”（《述而》）曾子曰：“士不可以不弘毅，任重而道远。仁以为己任，不亦重乎？死而后已，不亦远乎？”（《泰伯》）子曰：“岁寒，然后知松柏之后凋也。”（《子罕》）子贡问曰：“有一言而可以终身行之者乎？”子曰：“其恕乎！己所不欲，勿施于人。”（《卫灵公》） 从上看来，如果曾子靠边站了，可能连《论语》也没有了。后世人还谈什么四书五经中华文明。 再抄一篇后世托名孔子所作的一篇。 大道之行也 大道之行也，天下为公，选贤与能，讲信修睦。故人不独亲其亲，不独子其子，使老有所终，壮有所用，幼有所长，矜、寡、孤、独、废疾者皆有所养，男有分，女有归。货恶其弃于地也，不必藏于己；力恶其不出于身也，不必为己。是故谋闭而不兴，盗窃乱贼而不作，故外户而不闭，是谓大同。 曾子上面说到，是子将掌门之位传给曾子后，才有了四书，可以说其对后世两千多年中华文明影响深远。下面摘抄一段曾子作品。 大学摘抄 大学之道，在明明德，在亲民，在止于至善。知止而后有定，定而后能静，静而后能安，安而后能虑，虑而后能得。物有本末，事有终始。知所先后，则近道矣。古之欲明明德于天下者，先治其国。欲治其国者，先齐其家。欲齐其家者，先修其身。欲修其身者，先正其心。欲正其心者，先诚其意。欲诚其意者，先致其知。致知在格物。物格而后知至，知至而后意诚，意诚而后心正，心正而后身修，身修而后家齐，家齐而后国治，国治而后天下平。自天子以至于庶人，一是皆以修身为本。其本乱而末治者否矣。其所厚者薄，而其所薄者厚，未之有也。此谓知本，此谓知之至也。所谓诚其意者，毋自欺也。如恶恶臭，如好好色，此之谓自谦。故君子必慎其独也。小人闲居为不善，无所不至，见君子而后厌然，掩其不善而著其善。 人之视己，如见其肺肝然，则何益矣。此谓诚于中，形于外，故君子必慎其独也。 曾子曰：“十目所视，十手所指，其严乎！”富润屋，德润身，心广体胖，故君子必诚其意。…… 曾子除了著书，立说也不惶多让，除了上面论语节选中提到的，再抄录一些： 论语.曾子相关 曾子曰：“忠者，其孝之本与？孝子不登高，不履危，痹亦弗凭；不苟笑，不苟訾，隐不命，临不指。故不在尤之中也。”曾子曰：“君子立孝，其忠之用，礼之贵。”曾子曰：“孝有三：大孝尊亲，其次不辱，其下能养。”曾子曰：”吾闻诸夫子：’人未有自致者也必也，亲丧乎‘。”曾子曰：”吾闻诸夫子：’孟庄子之孝也，其他可能也，其不改父之臣与父之政，是难能也。”曾子曰：”鸟之将死，其鸣也哀；人之将死，其言也善。君子所贵乎道者三：动容貌，斯远暴慢矣；正颜色，斯近信矣；出辞气，斯远鄙倍矣。笾豆之事，则有司存。”曾子曰：”以能问于不能，以多问于寡，有若无，实若处，犯而不校，昔者吾友尝从事于斯矣。”曾子曰：”君子思不出其位。”曾子曰：”堂堂乎张也！难与并为仁矣。”曾子曰：”可以托六尺之孤，可以寄百里之命，临大节而不可夺也——君子人欤？君子人也。”曾子曰：”慎终追远，民德归厚矣。”曾子曰：”君子以文会友，以友辅仁。”子曰：”参乎！吾道一以贯之。”曾子曰：”唯。”子出，门人问曰：”何谓也？”曾子曰：”夫子之道，忠恕而已矣。“ 我的想法（曾子影响了中华文明）可能太过极端，下面摘一段比较中肯的： 1曾子师从孔子，积极推行儒家主张，传播儒家思想。孔子的孙子孔伋（字子思）师从参公，又传授给孟子。因之，曾参上承孔子之道，下启思孟学派，对孔子的儒学学派思想既有继承，又有发展和建树。曾参是孔子学说的主要继承人和传播者，在儒家文化中具有承上启下的重要地位。曾参以他的建树，终于走进大儒殿堂，与孔子、颜子（颜回）、子思、孟子比肩共称为五大圣人。 孟子孟子就不多说了，历史地位在那摆着，孟子者，七篇止，讲道德，说仁义，直接抄录。 生于忧患，死于安乐 舜发于畎亩之中，傅说举于版筑之间，胶鬲举于鱼盐之中，管夷吾举于士，孙叔敖举于海，百里奚举于市。故天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。人恒过，然后能改；困于心，衡于虑，而后作；征于色，发于声，而后喻。入则无法家拂士，出则无敌国外患者，国恒亡。然后知生于忧患而死于安乐也。 鱼我所欲也 鱼，我所欲也；熊掌，亦我所欲也，二者不可得兼，舍鱼而取熊掌者也。生，亦我所欲也；义，亦我所欲也。二者不可得兼，舍生而取义者也。生亦我所欲，所欲有甚于生者，故不为苟得也。死亦我所恶，所恶有甚于死者，故患有所不辟也。如使人之所欲莫甚于生，则凡可以得生者何不用也。使人之所恶莫甚于死者，则凡可以辟患者何不为也！由是则生而有不用也；由是则可以辟患而有不为也。是故所欲有甚于生者，所恶有甚于死者。非独贤者有是心也，人皆有之，贤者能勿丧耳。一箪食，一豆羹，得之则生，弗得则死。呼尔而与之，行道之人弗受；蹴尔而与之，乞人不屑也。万钟则不辩礼义而受之，万钟于我何加焉！为宫室之美，妻妾之奉，所识穷乏者得我与？乡为身死而不受，今为宫室之美为之；乡为身死而不受，今为妻妾之奉为之；乡为身死而不受，今为所识穷乏者得我而为之：是亦不可以已乎？此之谓失其本心。 得道多助，失道寡助 天时不如地利，地利不如人和。三里之城，七里之郭，环而攻之而不胜。夫环而攻之，必有得天时者矣，然而不胜者，是天时不如地利也。城非不高也，池非不深也，兵革非不坚利也，米粟非不多也，委而去之，是地利不如人和也。故曰，域民不以封疆之界，固国不以山溪之险，威天下不以兵革之利。得道者多助，失道者寡助。寡助之至，亲戚畔之。多助之至，天下顺之。以天下之所顺，攻亲戚之所畔，故君子有不战，战必胜矣。 荀子 提到孟子，不能不提荀子，毕竟司马迁是将二人并列一篇的。至于其地位，直接引用网上对比孔孟的感受一下： 荀子的思想偏向于经验以及人事方面，是从社会脉络方面出发，重视社会秩序，反对神秘主义的思想，重视人为的努力。孔子中心思想为“仁”，孟子中心思想为“义”，荀子继二人后提出“礼”、“法”，重视社会上人们行为的规范。以孔子为圣人，但反对孟子和子思为首的“思孟学派”哲学思想，认为子弓与自己才是继承孔子思想的学者。荀子认为人与生俱来就想满足欲望，若欲望得不到满足便会发生争执，因此主张人性有恶，须要由圣王及礼法的教化，来“化性起伪”使人格提高。与孔、孟相比，荀子的思想则具有更多的现实主义倾向。他在重视礼义道德教育的同时，也强调了政法制度的惩罚作用。 劝学摘抄 君子曰：学不可以已。青，取之于蓝，而青于蓝；冰，水为之，而寒于水。木直中绳，輮以为轮，其曲中规。虽有槁暴，不复挺者，輮使之然也。故木受绳则直，金就砺则利，君子博学而日参省乎己，则知明而行无过矣。吾尝终日而思矣，不如须臾之所学也；吾尝跂而望矣，不如登高之博见也。登高而招，臂非加长也，而见者远；顺风而呼，声非加疾也，而闻者彰。假舆马者，非利足也，而致千里；假舟楫者，非能水也，而绝江河。君子生非异也，善假于物也。积土成山，风雨兴焉；积水成渊，蛟龙生焉；积善成德，而神明自得，圣心备焉。故不积跬步，无以至千里；不积小流，无以成江海。骐骥一跃，不能十步；驽马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。蚓无爪牙之利，筋骨之强，上食埃土，下饮黄泉，用心一也。蟹六跪而二螯，非蛇鳝之穴无可寄托者，用心躁也。 原来这些是从劝学里面四处挑的，难怪上学时背诵的时候感觉不连贯。 一篇不足以编目，那就把荀子的弟子韩非的一篇也在这里抄录一下。 智子疑邻 宋有富人，天雨墙坏。其子曰：“不筑，必将有盗。”其邻人之父亦云。暮而果大亡其财，其家甚智其子，而疑邻人之父。 老庄老庄就是老子和庄子了，他们在道家的地位就好比孔孟在儒家的地位。二人分别都有大作传世–道德经、南华经，道德经很长，大概有五千字故又称五千言文，南华经就更长了，所以这里只能摘抄其中的一小点，感受一下。 道德经.第一章 道可道，非常道；名可名，非常名。无名，万物之始，有名，万物之母。故常无欲，以观其妙，常有欲，以观其徼。此两者，同出而异名，同谓之玄，玄之又玄，众妙之门。 道德经.第四十二章 道生一，一生二，二生三，三生万物。万物负阴而抱阳，冲气以为和。天下之所恶，唯孤、寡、不谷，而王公以为自名也。故物或损之而益，或益之而损。觐殷死，议而教人。强梁者不得其死，我将以为学父。 逍遥游一段 北冥有鱼，其名为鲲。鲲之大，不知其几千里也。化而为鸟，其名为鹏。鹏之背，不知其几千里也，怒而飞，其翼若垂天之云。是鸟也，海运则将徙于南冥。南冥者，天池也。《齐谐》者，志怪者也。《谐》之言曰：“鹏之徙于南冥也，水击三千里，抟扶摇而上者九万里，去以六月息者也。”野马也，尘埃也，生物之以息相吹也。天之苍苍，其正色邪？其远而无所至极邪？其视下也，亦若是则已矣。且夫水之积也不厚，则其负大舟也无力。覆杯水于坳堂之上，则芥为之舟；置杯焉则胶，水浅而舟大也。风之积也不厚，则其负大翼也无力。故九万里，则风斯在下矣，而后乃今培风；背负青天而莫之夭阏者，而后乃今将图南。 其他先秦还有那么多好诗文，这里都要划到其他里了，实在是受传统学校教育的影响，除了儒家其他家的诗文好像也没有什么号召力。下面就摘抄几篇进课本的短文。 两小儿辩日 孔子东游，见两小儿辩日，问其故。一儿曰：“我以日始出时去人近，而日中时远也。”一儿以日初出远，而日中时近也。一儿曰：“日初出大如车盖，及日中则如盘盂，此不为远者小而近者大乎？”一儿曰：“日初出沧沧凉凉，及其日中如探汤，此不为近者热而远者凉乎？”孔子不能决也。两小儿笑曰：“孰为汝多知乎？” 还是孔子，圣人就是不一样。 学弈 弈秋，通国之善弈者也。使弈秋诲二人弈，其一人专心致志，惟弈秋之为听；一人虽听之，一心以为有鸿鹄将至，思援弓缴而射之。虽与之俱学，弗若之矣。为是其智弗若与？曰：非然也。 愚公移山 太行、王屋二山，方七百里，高万仞。本在冀州之南，河阳之北。北山愚公者，年且九十，面山而居。惩山北之塞，出入之迂也。聚室而谋曰：“吾与汝毕力平险，指通豫南，达于汉阴，可乎？”杂然相许。其妻献疑曰：“以君之力，曾不能损魁父之丘，如太行、王屋何？且焉置土石？”杂曰：“投诸渤海之尾，隐土之北。”遂率子孙荷担者三夫，叩石垦壤，箕畚运于渤海之尾。邻人京城氏之孀妻有遗男，始龀，跳往助之。寒暑易节，始一反焉。河曲智叟笑而止之曰：“甚矣，汝之不惠。以残年余力，曾不能毁山之一毛，其如土石何？”北山愚公长息曰：“汝心之固，固不可彻，曾不若孀妻弱子。虽我之死，有子存焉；子又生孙，孙又生子；子又有子，子又有孙；子子孙孙无穷匮也，而山不加增，何苦而不平？”河曲智叟亡以应。操蛇之神闻之，惧其不已也，告之于帝。帝感其诚，命夸娥氏二子负二山，一厝朔东，一厝雍南。自此，冀之南，汉之阴，无陇断焉。 写到这里突然发现，这其他多是成语故事，那么叶公好龙、郑人买履、邯郸学步、狐假虎威、画蛇添足、......有好多，也不知道是不是先秦的作品，还是不抄了吧。另外如曹刿论战、烛之武退秦师、完璧归赵、扁鹊见蔡桓公、唐雎不辱使命等历史事件相关的也不抄了。 先秦诗文就先到这里吧。 两汉怎么算两汉，按人物生活的年代最后一个皇帝退位算，这样曹操就也算两汉的了（他二子不算）。两汉时期的诗文作者，进中小学课本最多的应该是司马迁，因为有史家之绝唱，无韵之离骚压阵。另外，文首推贾生，诗首推孟德。这章还是以人物划分，让我先罗列一下：贾谊、司马迁、曹操、诸葛亮、其他。咦，好像没东汉什么事，算了就这样吧。 贾谊贾谊一生很短，但无碍其历史地位，历来被推崇备至。过秦论、论积贮疏都是课文中要背诵的，但这里抄录还是觉得不合适，因为都太长了。但都把贾生单独列出来了，不能什么都不写吧。那就把后世关于贾生的有名诗文作品抄录一下吧。 滕王阁序一段 嗟乎，时运不齐，命途多舛。冯唐易老，李广难封。屈贾谊于长沙，非无圣主；窜梁鸿于海曲，岂乏明时？所赖君子见机，达人知命。老当益壮，宁移白首之心？穷且益坚，不坠青云之志。酌贪泉而觉爽，处涸辙以犹欢。北海虽赊，扶摇可接；东隅已逝，桑榆非晚。孟尝高洁，空余报国之情；阮籍猖狂，岂效穷途之哭！ 李商隐.贾生 宣室求贤访逐臣，贾生才调更无伦。可怜夜半虚前席，不问苍生问鬼神。 王安石.贾生 一时谋议略施行，谁道君王薄贾生。爵位自高言尽废，古来何啻万公卿。 毛泽东.贾生 贾生才调世无伦，哭泣情怀吊屈文。梁王堕马寻常事，何用哀伤付一生。 司马迁这里该抄什么呢？都那么长。还是抄录一些名句吧。其实名句也太多，抄不完，更详细的见这篇。 司马迁史记名句 前事之不忘，后事之师也。家贫则思良妻，国乱则思良相。一沐三捉发，一饭三吐哺。仓廪实而知礼节，衣食足而知荣辱。士为知己者死，女为说己者容。智者千虑，必有一失；愚者千虑，必有一得。其身正，不令而行；其身不正，虽令不从。鸟之将死，其鸣也哀；人之将死，其言也善。不鸣则已，一鸣惊人。 再节选一点非史记的，感受一下司马公的文采： 报任安书摘抄 夫人情莫不贪生恶死，念父母，顾妻子，至激于义理者不然，乃有所不得已也。今仆不幸，早失父母，无兄弟之亲，独身孤立，少卿视仆于妻子何如哉？且勇者不必死节，怯夫慕义，何处不勉焉！仆虽怯懦，欲苟活，亦颇识去就之分矣，何至自沉溺缧绁之辱哉！且夫臧获婢妾，犹能引决，况仆之不得已乎？所以隐忍苟活，幽于粪土之中而不辞者，恨私心有所不尽，鄙陋没世，而文采不表于后也。古者富贵而名摩灭，不可胜记，唯倜傥非常之人称焉。盖文王拘而演《周易》；仲尼厄而作《春秋》；屈原放逐，乃赋《离骚》；左丘失明，厥有《国语》；孙子膑脚，《兵法》修列；不韦迁蜀，世传《吕览》；韩非囚秦，《说难》《孤愤》；《诗》三百篇，大底圣贤发愤之所为作也。此人皆意有所郁结，不得通其道，故述往事、思来者。乃如左丘无目，孙子断足，终不可用，退而论书策，以舒其愤，思垂空文以自见。 曹操话不多说，直接抄录。 短歌行 对酒当歌，人生几何！譬如朝露，去日苦多。慨当以慷，忧思难忘。何以解忧？唯有杜康。青青子衿，悠悠我心。但为君故，沉吟至今。呦呦鹿鸣，食野之苹。我有嘉宾，鼓瑟吹笙。明明如月，何时可掇？忧从中来，不可断绝。越陌度阡，枉用相存。契阔谈讌，心念旧恩。月明星稀，乌鹊南飞。绕树三匝，何枝可依？山不厌高，水不厌深。周公吐哺，天下归心。 再来两首三句半。 观沧海 东临碣石，以观沧海。水何澹澹，山岛竦峙。树木丛生，百草丰茂。秋风萧瑟，洪波涌起。日月之行，若出其中；星汉灿烂，若出其里。幸甚至哉，歌以咏志。 龟虽寿 神龟虽寿，犹有竟时。腾蛇乘雾，终为土灰。老骥伏枥，志在千里。烈士暮年，壮心不已。盈缩之期，不但在天；养怡之福，可得永年。幸甚至哉，歌以咏志。 诸葛亮单凭一篇出师表，也应该为诸葛亮单列。记得上学时最喜欢背的古文，一是出师表，二是醉翁亭记，两篇都把之乎者也文言句式应用到了极致，而出师表尤甚，背诵时稍有不慎就会出错。但这里还是不想抄出师表，太长了。抄个诸葛武侯的短文： 诫子书 夫君子之行，静以修身，俭以养德。非淡泊无以明志，非宁静无以致远。夫学须静也，才须学也。非学无以广才，非志无以成学。淫慢则不能励精，险躁则不能冶性。年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及！ 下面是诗圣对武侯的歌颂，就是不知道名字对不对，内容也不一定准确（我对杜甫是认真的，别人的我可能会去复制，但杜甫的我都是硬背）： 八阵图 功盖三分国，名成八阵图。江流石不转，遗恨失吞吴。 武侯庙 遗庙丹青落，空山草木长。犹闻辞后主，不复卧南阳。 咏怀古迹 诸葛大名垂宇宙，宗臣遗庙肃清高。三分割据纡筹策，万古云霄一羽毛。伯仲之间见伊吕，指挥若定失萧曹。运移汉祚终难复，志决身坚军务劳。 蜀相 丞相祠堂何处寻，锦官城外柏森森。映阶碧草自春色，隔叶黄鹂空好音。三顾频烦天下计，两朝开济老臣心。出师未捷身先死，长使英雄泪满襟。 我跟英雄没关系吧，怎么一读这首也有热泪盈眶的冲动。 再来一首刘禹锡歌颂其祖上的诗，其中捎带了武侯： 蜀先主庙 天地英雄气，千秋尚凛然。势分三足鼎，业复五铢钱。得相能开国，生儿不像贤。凄凉蜀故妓，来舞魏宫前。 其他写到这里，突然发现问题了：我这明明是抄录古诗文的，即古代的诗歌和文章，但是几乎所有文章都很长，看来就都是诗歌了。算了继续抄诗吧，两汉时期其他的诗文也不少（就叫诗文吧，虽然可能没有文）。 项羽.垓下歌 力拔山兮气盖世。时不利兮骓不逝。骓不逝兮可奈何！虞兮虞兮奈若何！ 刘邦.大风歌 大风起兮云飞扬，威加海内兮归故乡，安得猛士兮守四方！ 青青园中葵 青青园中葵，朝露待日晞。阳春布德泽，万物生光辉。常恐秋节至，焜黄华叶衰。百川东到海，何时复西归？少壮不努力，老大徒伤悲！ 司马相如.凤求凰其一 有美一人兮，见之不忘。一日不见兮，思之如狂。凤飞翱翔兮，四海求凰。无奈佳人兮，不在东墙。将琴代语兮，聊写衷肠。何时见许兮，慰我彷徨。愿言配德兮，携手相将。不得於飞兮，使我沦亡。 卓文君.白头吟 皑如山上雪，皎若云间月。闻君有两意，故来相决绝。今日斗酒会，明旦沟水头。躞蹀御沟上，沟水东西流。凄凄复凄凄，嫁娶不须啼。愿得一人心，白首不相离。竹竿何袅袅，鱼尾何簁簁！男儿重意气，何用钱刀为！ 江南 江南可采莲，莲叶何田田，鱼戏莲叶间。鱼戏莲叶东，鱼戏莲叶西，鱼戏莲叶南，鱼戏莲叶北。 迢迢牵牛星 迢迢牵牛星，皎皎河汉女。纤纤擢素手，札札弄机杼。终日不成章，泣涕零如雨。河汉清且浅，相去复几许。盈盈一水间，脉脉不得语。 上邪 上邪，我欲与君相知，长命无绝衰。山无陵，江水为竭。冬雷震震，夏雨雪。天地合，乃敢与君绝。 北方有佳人 北方有佳人，绝世而独立。一顾倾人城，再顾倾人国。宁不知倾城与倾国？佳人难再得。 好了，两汉诗文就先到这里。 魏晋南北朝这一时期的诗文我觉得没有什么好分组的了，就是陶渊明及其他。是不是身处外族侵略时代，文人们大都写不出什么好作品了。 陶渊明陶潜公诗文双绝，我觉得历史上能称得上诗文双绝的就那么几个：欧阳修、王安石、苏轼，其他如韩、柳这样的百代文宗都不能称诗文双绝，其他人更别想。当然我这里不是说诗文双绝的就比只重诗或文的厉害或地位高（论文学地位高肯定是李杜第一然后其他），只是想说陶潜公能独撑这个时代，如果没有他，这个时代的诗文应该可以直接忽略掉了。话不多说直接开抄： 桃花源记 这里不抄这篇了，回顾上学时学的古文，该篇应该是背的最熟的，虽是古文，但内容通俗易懂，基本不用看翻译。单论这点，陶渊明之前的贾谊、诸葛亮比不了，之后的韩愈、柳宗元也比不了。这里去除史文罗列一下以前课本中的古文看看：过秦论、出师表、陈情表、桃花源记、滕王阁序、陋室铭、阿房宫赋、马说、师说、捕蛇者说、小石潭记、岳阳楼记、醉翁亭记、秋声赋、六国论、石钟山记、赤壁赋、游褒禅山记、卖橘者言、送东阳马生序、项脊轩志、五人墓碑记……想到了这些，说多了。这些都不抄录了。好了后面可能都剩下古诗了，可能会穿插一些古文摘抄。 开始正式抄录陶渊明诗文。 五柳先生传 先生不知何许人也，亦不详其姓字，宅边有五柳树，因以为号焉。闲静少言，不慕荣利。好读书，不求甚解；每有会意，便欣然忘食。性嗜酒，家贫不能常得。亲旧知其如此，或置酒而招之；造饮辄尽，期在必醉。既醉而退，曾不吝情去留。环堵萧然，不蔽风日；短褐穿结，箪瓢屡空，晏如也。常著文章自娱，颇示己志。忘怀得失，以此自终。赞曰：黔娄之妻有言：“不戚戚于贫贱，不汲汲于富贵。”其言兹若人之俦乎？衔觞赋诗，以乐其志，无怀氏之民欤？葛天氏之民欤？ 归去来兮 归去来兮，田园将芜胡不归？既自以心为形役，奚惆怅而独悲？悟已往之不谏，知来者之可追。实迷途其未远，觉今是而昨非。舟遥遥以轻飏，风飘飘而吹衣。问征夫以前路，恨晨光之熹微。乃瞻衡宇，载欣载奔。僮仆欢迎，稚子候门。三径就荒，松菊犹存。携幼入室，有酒盈樽。引壶觞以自酌，眄庭柯以怡颜。倚南窗以寄傲，审容膝之易安。园日涉以成趣，门虽设而常关。策扶老以流憩，时矫首而遐观。云无心以出岫，鸟倦飞而知还。景翳翳以将入，抚孤松而盘桓。归去来兮，请息交以绝游。世与我而相违，复驾言兮焉求？悦亲戚之情话，乐琴书以消忧。农人告余以春及，将有事于西畴。或命巾车，或棹孤舟。既窈窕以寻壑，亦崎岖而经丘。木欣欣以向荣，泉涓涓而始流。善万物之得时，感吾生之行休。已矣乎！寓形宇内复几时。曷不委心任去留？胡为乎遑遑欲何之？富贵非吾愿，帝乡不可期。怀良辰以孤往，或植杖而耘耔。登东皋以舒啸，临清流而赋诗。聊乘化以归尽，乐夫天命复奚疑！ 饮酒 结庐在人境，而无车马喧。问君何能尔？心远地自偏。采菊东篱下，悠然见南山。山气日夕佳，飞鸟相与还。此中有真意，欲辨已忘言。 归园田居 少无适俗韵，性本爱丘山。误落尘网中，一去三十年。羁鸟恋旧林，池鱼思故渊。开荒南野际，守拙归园田。方宅十余亩，草屋八九间。榆柳荫后檐，桃李罗堂前。暧暧远人村，依依墟里烟。狗吠深巷中，鸡鸣桑树颠。户庭无尘杂，虚室有余闲。久在樊笼里，复得返自然。 归园田居 种豆南山下，草盛豆苗稀。晨兴理荒秽，带月荷锄归。道狭草木长，夕露沾我衣。衣沾不足惜，但使愿无违。 杂诗 人生无根蒂，飘如陌上尘。分散逐风转，此已非常身。落地为兄弟，何必骨肉亲！得欢当作乐，斗酒聚比邻。盛年不重来，一日难再晨。及时当勉励，岁月不待人。 读山海经 精卫衔微木，将以填沧海。刑天舞干戚，猛志固常在。同物既无虑，化去不复悔。徒设在昔心，良辰讵可待。 其他陶渊明抄了这么多，其他该抄多少？好像魏晋时期都找不到，就先来两篇曹氏弟兄的吧。 曹植.白马篇 白马饰金羁，连翩西北驰。借问谁家子，幽并游侠儿。少小去乡邑，扬声沙漠垂。宿昔秉良弓，楛矢何参差。控弦破左的，右发摧月支。仰手接飞猱，俯身散马蹄。狡捷过猴猿，勇剽若豹螭。边城多警急，虏骑数迁移。羽檄从北来，厉马登高堤。长驱蹈匈奴，左顾凌鲜卑。弃身锋刃端，性命安可怀？父母且不顾，何言子与妻！名编壮士籍，不得中顾私。捐躯赴国难，视死忽如归！ 曹丕.燕歌行 秋风萧瑟天气凉，草木摇落露为霜，群燕辞归鹄南翔。念君客游思断肠，慊慊思归恋故乡，君何淹留寄他方？贱妾茕茕守空房，忧来思君不敢忘，不觉泪下沾衣裳。援琴鸣弦发清商，短歌微吟不能长。明月皎皎照我床，星汉西流夜未央。牵牛织女遥相望，尔独何辜限河梁。 南北朝时期最有名的肯定是乐府双璧之一的木兰诗了，因为太熟悉这里就不抄录了。来几篇南北朝其他的： 敕勒歌 敕勒川，阴山下。天似穹庐，笼盖四野。天苍苍，野茫茫。风吹草低见牛羊。 谢朓.王孙游 绿草蔓如丝，杂树红英发。无论君不归，君归芳已歇。 王籍.入若耶溪 艅艎何泛泛，空水共悠悠。阴霞生远岫，阳景逐回流。蝉噪林逾静，鸟鸣山更幽。此地动归念，长年悲倦游。 郦道元.三峡 自三峡七百里中，两岸连山，略无阙处。重岩叠嶂，隐天蔽日。自非亭午夜分，不见曦月。至于夏水襄陵，沿溯阻绝。或王命急宣，有时朝发白帝，暮到江陵，其间千二百里，虽乘奔御风，不以疾也。春冬之时，则素湍绿潭，回清倒影。绝巘多生怪柏，悬泉瀑布，飞漱其间，清荣峻茂，良多趣味。每至晴初霜旦，林寒涧肃，常有高猿长啸，属引凄异，空谷传响，哀转久绝。故渔者歌曰：“巴东三峡巫峡长，猿鸣三声泪沾裳。” 吴均.与朱元思书 风烟俱净，天山共色。从流飘荡，任意东西。自富阳至桐庐一百许里，奇山异水，天下独绝。水皆缥碧，千丈见底。游鱼细石，直视无碍。急湍甚箭，猛浪若奔。夹岸高山，皆生寒树，负势竞上，互相轩邈，争高直指，千百成峰。泉水激石，泠泠作响；好鸟相鸣，嘤嘤成韵。蝉则千转不穷，猿则百叫无绝。鸢飞戾天者，望峰息心；经纶世务者，窥谷忘反。横柯上蔽，在昼犹昏；疏条交映，有时见日。 好了，魏晋南北朝就抄到这里吧。后面因为隋朝太短，也没什么可抄的，直接跳过，进入中华诗歌盛世–唐朝。 唐在这章我该抄什么呢？大小李杜王孟刘白韩柳郊岛高岑我也不知道了。就算只录短诗也会累死。先引入首百代文宗赞扬李杜的： 李杜文章在，光焰万丈长。不知群儿愚，那用故谤伤。蚍蜉撼大树，可笑不自量。伊我生其后，举颈遥相望。夜梦多见之，昼思反微茫。徒观斧凿痕，不瞩治水航。想当施手时，巨刃磨天扬。垠崖划崩豁，乾坤摆雷硠。惟此两夫子，家居率荒凉。…… 先定基调，再胡乱抄吧，想到什么抄什么，好诗太多，没有头绪。那就先上最厉害的吧。 李白还有什么好说的呢，李白斗酒诗百篇，直接从酒相关的开始吧。先背几首，不知道名字和内容是不是对： 将进酒 君不见，黄河之水天上来，奔流到海不复回。君不见，高堂明镜悲白发，朝如青丝暮成雪。人生得意须尽欢，莫使金樽空对月。天生我才必有用，千金散尽还复来。烹羊宰牛且为乐，会须一饮三百杯。岑夫子，丹丘生，将进酒，杯莫停。与君歌一曲，请君为我倾耳听：钟鼓馔玉何足贵，但愿长醉不复醒。古来圣贤皆寂寞，唯有饮者留其名。陈王昔时宴平乐，斗酒十千恣欢谑。主人何为言少钱，径须沽取对君酌。五花马，千金裘，呼儿将出换美酒，与尔同销万古愁。 行路难 金樽清酒斗十千，玉盘珍馐值万钱。停杯投箸不能食，拔剑四顾心茫然。欲渡黄河冰塞川，将登太行雪漫天。闲来垂钓坐溪上，忽复乘舟梦日边。行路难，行路难，多歧路，今安在？长风破浪会有时，直挂云帆济沧海。 宣州谢脁楼饯别校书书云 弃我去者，昨日之日不可留，乱我心者，今日之日多烦忧。长风万里送秋雁，对此可以酣高楼。蓬莱文章建安骨，中间小谢又清发。俱怀逸兴壮思飞，欲上青天览明月。抽刀断水水更流，举杯浇愁愁更愁。人生在世不称意，明朝散发弄扁舟。 月下独酌 花间一壶酒，独酌无相亲。举杯邀明月，对影成三人。月既不解饮，影徒随我身。暂伴月将影，行乐须及春。我歌月徘徊，我舞影零乱。醒时同交欢，醉后各分散。永结无情游，相期邈云汉。 突然发现，能背几首长点的，短的反而都记不起来了，算了，开抄。 静夜思 床前明月光，疑是地上霜。举头望明月，低头思故乡。 敬亭山 众鸟高飞尽，孤云独去闲。相看两不厌，只有敬亭山。 夜宿山寺 危楼高百尺，手可摘星辰。不敢高声语，恐惊天上人。 卷珠帘 美人卷珠帘，深坐蹙蛾眉。但见泪痕湿，不知心恨谁。 黄鹤楼送孟浩然之广陵 故人西辞黄鹤楼，烟花三月下扬州。孤帆远影碧空尽，唯见长江天际流。 望庐山瀑布 日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺，疑是银河落九天。 赠汪伦 李白乘舟将欲行，忽闻岸上踏歌声。桃花潭水深千尺，不及汪伦送我情。 闻王昌龄左迁龙标遥有此寄 杨花落尽子规啼，闻道龙标过五溪。我寄愁心与明月，随风直到夜郎西。 望天门山 天门中断楚江开，碧水东流至此回。两岸青山相对出，孤帆一片日边来。 春夜洛城闻笛 谁家玉笛暗飞声，散入春风满洛城。此夜曲中闻折柳，何人不起故园情。 早发白帝城 朝辞白帝彩云间，千里江陵一日还。两岸猿声啼不住，轻舟已过万重山。 送友人 青山横北郭，白水绕东城。此地一为别，孤蓬万里征。浮云游子意，落日故人情。挥手自兹去，萧萧班马鸣。 渡荆门送别 渡远荆门外，来从楚国游。山随平野尽，江入大荒流。月下飞天镜，云生结海楼。仍怜故乡水，万里送行舟。 子夜吴歌·秋歌 长安一片月，万户捣衣声。秋风吹不尽，总是玉关情。何日平胡虏，良人罢远征。 关山月 明月出天山，苍茫云海间。长风几万里，吹度玉门关。汉下白登道，胡窥青海湾。由来征战地，不见有人还。戍客望边邑，思归多苦颜。高楼当此夜，叹息未应闲。 太多了，抄不过来了，以一首李白不擅长的七律完结吧。 凤凰台 凤凰台上凤凰游，凤去台空江自流。吴宫花草埋幽径，晋代衣冠成古丘。三山半落青天外，二水中分白鹭洲。总为浮云能蔽日，长安不见使人愁。 杜甫如果提到诗人，随口说出三个，相信大部分会说李白、杜甫、白居易。如果提到唐诗，肯定大多数人会想到唐诗三百首。那么问题严重了，唐诗三百首中杜甫诗的数量要落下李白白居易之和还好几圈，质量更是没的说。我认为杜甫的诗就是最好的，没毛病。 甫有时会心情舒畅： 绝句 两个黄鹂鸣翠柳，一行白鹭上青天。窗含西岭千秋雪，门泊东吴万里船。 江畔独步寻花 黄四娘家花满蹊，千朵万朵压枝低。流连戏蝶时时舞，自在娇莺恰恰啼。 春夜喜雨 好雨知时节，当春乃发生。随风潜入夜，润物细无声。野径云俱黑，江船火独明。晓看红湿处，花重锦官城。 甫也有远大抱负： 望岳 岱宗夫如何，齐鲁青未了。造化钟神秀，阴阳割昏晓。荡胸生层云，决眦入归鸟。会当凌绝顶，一览众山小。 前出塞一首 挽弓当挽强，用箭当用长。射人先射马，擒贼先擒王。杀人亦有限，列国自有疆。苟能制侵陵，岂在多杀伤。 甫是白的小迷弟： 春日忆李白 白也诗无敌，飘然思不群。清新庾开府，俊逸鲍参军。渭北春天树，江东日暮云。何时一樽酒，重与细论文。 天末怀李白 凉风起天末，君子意如何。鸿雁几时到，江湖秋水多。文章憎命达，魑魅喜人过。应共冤魂语，投诗赠汨罗。 梦李白 浮云终日行，游子久不至。三夜频梦君，情亲见君意。告归常局促，苦道来不易。江湖多风波，舟楫恐失坠。出门搔白首，若负平生志。冠盖满京华，斯人独憔悴。孰云网恢恢，将老身反累。千秋万岁名，寂寞身后事。 还有好多…… 甫最崇拜的古人是孔明：这就不抄了，前面都有了。 甫待人很真诚： 赠卫八处士 人生不相见，动如参与商。今夕复何夕，共此灯烛光。少壮能几时，鬓发各已苍。访旧半为鬼，惊呼热中肠。焉知二十载，重上君子堂。昔别君未婚，儿女忽成行。怡然敬父执，问我来何方。问答乃未已，儿女罗酒浆。夜雨剪春韭，新炊间黄粱。主称会面难，一举累十觞。十觞亦不醉，感子故意长。明日隔山岳，世事两茫茫。 客至 舍南舍北皆春水，但见群鸥日日来。花径不曾缘客扫，蓬门今始为君开。盘飧市远无兼味，樽酒家贫只旧醅。肯与邻翁相对饮，隔篱呼取尽馀杯。 江南逢李龟年 岐王宅里寻常见，崔九堂前几度闻。正是江南好风景，落花时节又逢君。 赠花卿 锦城丝管日纷纷，半入江风半入云。此曲只应天上有，人间能得几回闻。 甫的杂体诗与白不分轩轾： 茅屋为秋风所破歌 八月秋高风怒号，卷我屋上三重茅。茅飞渡江洒江郊，高者挂罥长林梢，下者飘转沉塘坳。南村群童欺我老无力，忍能对面为盗贼，公然抱茅入竹去。唇焦口燥呼不得，归来倚杖自叹息。俄顷风定云墨色，秋天漠漠向昏黑。布衾多年冷似铁，娇儿恶卧踏里裂。床头屋漏无干处，雨脚如麻未断绝。自经丧乱少睡眠，长夜沾湿何由彻？安得广厦千万间，大庇天下寒士俱欢颜，风雨不动安如山！呜呼！何时眼前突兀见此屋，吾庐独破受冻死亦足！ 兵车行 车辚辚，马萧萧，行人弓箭各在腰。耶娘妻子走相送，尘埃不见咸阳桥。牵衣顿足阑道哭，哭声直上干云霄。道傍过者问行人，行人但云点行频。或从十五北防河，便至四十西营田。去时里正与裹头，归来头白还戍边。边亭流血成海水，武皇开边意未已。君不闻汉家山东二百州，千村万落生荆杞。纵有健妇把锄犁，禾生陇亩无东西。况复秦兵耐苦战，被驱不异犬与鸡。长者虽有问，役夫敢申恨。且如今年冬，未休关西卒。县官急索租，租税从何出。信知生男恶，反是生女好。生女犹是嫁比邻，生男埋没随百草。君不见青海头，古来白骨无人收。新鬼烦冤旧鬼哭，天阴雨湿声啾啾。 甫的五言诗亘古绝今： 石壕吏 暮投石壕村，有吏夜捉人。老翁逾墙走，老妇出门看。吏呼一何怒，妇啼一何苦。听妇前致词，三男邺城戍。一男附书至，二男新战死。存者且偷生，死者长已矣。室中更无人，惟有乳下孙。有孙母未去，出入无完裙。老妪力虽衰，请从吏夜归。急应河阳役，犹得备晨炊。夜久语声绝，如闻泣幽咽。天明登前途，独与老翁别。 春望 国破山河在，城春草木深。感时花溅泪，恨别鸟惊心。烽火连三月，家书抵万金。白头搔更短，浑欲不胜簪。 月夜忆舍弟 戍鼓断人行，秋边一雁声。露从今夜白，月是故乡明。有弟皆分散，无家问死生。寄书长不达，况乃未休兵。 旅夜书怀 细草微风岸，危樯独夜舟。星垂平野阔，月涌大江流。名岂文章著，官应老病休。飘飘何所似，天地一沙鸥。 登岳阳楼 昔闻洞庭水，今上岳阳楼。吴楚东南坼，乾坤日夜浮。亲朋无一字，老病有孤舟。戎马关山北，凭轩涕泗流。 甫的七言律诗秒杀众生包括白： 闻官军收河南河北 剑外忽传收蓟北，初闻涕泪满衣裳。却看妻子愁何在？漫卷诗书喜欲狂。白日放歌须纵酒，青春作伴好还乡。即从巴峡穿巫峡，才下襄阳向洛阳。 登高 风急天高猿啸哀，渚清沙白鸟飞回。无边落木萧萧下，不尽长江滚滚来。万里悲秋常作客，百年多病独登台。艰难苦恨繁霜鬓，潦倒新停浊酒杯。 咏怀古迹.昭君墓 群山万壑赴荆门，生长明妃尚有村。一去紫台连朔漠，独留青冢向黄昏。画图省识春风面，环佩空归月夜魂。千载琵琶作胡语，分明怨恨曲中论。 面对这样的杜甫，我还能说什么。 李商隐大李杜完了必须是小李杜，白老先靠后。为什么，后面再说。直接开抄，先来小李，因为他收到唐诗三百首里的诗要比小杜多。 我有时候感觉自己很像小李，为什么？因为我很多时候也不知道写的文章该取什么名字。(^~^) 无题 锦瑟无端五十弦，一弦一柱思华年。庄生晓梦迷蝴蝶，望帝春心托杜鹃。沧海月明珠有泪，蓝田日暖玉生烟。此情可待成追忆，只是当时已惘然。 无题 相见时难别亦难，东风无力百花残。春蚕到死丝方尽，蜡炬成灰泪始干。晓镜但愁云鬓改，夜吟应觉月光寒。蓬山此去无多路，青鸟殷勤为探看。 无题 昨夜星辰昨夜风，画楼西畔桂堂东。身无彩凤双飞翼，心有灵犀一点通。隔座送钩春酒暖，分曹射覆蜡灯红。嗟余听鼓应官去，走马兰台类转蓬。 小李还有很多取不出题目的，先不录了。录点别的爱情诗： 夜雨寄北 君问归期未有期，巴山夜雨涨秋池。何当共剪西窗烛，却话巴山夜雨时。 暮秋独游曲江 荷叶生时春恨生，荷叶枯时秋恨成。深知身在情长在，怅望江头江水声。 写人写物更不在话下： 荷花 世间花叶不相伦，花入金盆叶作尘。惟有绿荷红菡萏，卷舒开合任天真。此花此叶长相映，翠减红衰愁杀人。 霜月 初闻征雁已无蝉，百尺楼高水接天。青女素娥俱耐冷，月中霜里斗婵娟。 嫦娥 云母屏风烛影深，长河渐落晓星沉。嫦娥应悔偷灵药，碧海青天夜夜心。 来一首李商隐少有的五言诗，作为结束。 乐游原 向晚意不适，驱车登古原。夕阳无限好，只是近黄昏。 杜牧小杜是个矛盾体，放荡不羁爱自由的外表下有一个忧国忧民治国平天下的心。他与李白、王勃、李商隐这些大才是有区别的，他们是真的文人，都会在自己的作品中抒发自己的怀才不遇，但他们的才只是文才而不是治国之才。但小杜不一样，他更像贾谊，是真的治国之才，只是没有好机遇，但他好像也没有抱怨过。这里不抄阿房宫赋，来几篇耳熟能详的小杜诗作感受一下。 先看小杜怎么放荡不羁爱自由的： 遣怀 潦倒江湖载酒行，楚腰纤细掌中轻。十年一觉扬州梦，赢得青楼薄幸名。 清明 清明时节雨纷纷，路上行人欲断魂。借问酒家何处有，牧童遥指杏花村。 山行 远上寒山石径斜，白云生处有人家。停车坐爱枫林晚，霜叶红于二月花。 秋夕 银烛秋光冷画屏，轻罗小扇扑流萤。天阶夜色凉如水，卧看牵牛织女星。 再看小杜怎么心怀天下的： 题乌江亭 胜败兵家事不期，包羞忍耻是男儿。江东子弟多才俊，卷土重来未可知。 赤壁 折戟沉沙铁未销，自将磨洗认前朝。东风不与周郎便，铜雀春深锁二乔。 过华清宫 长安回望绣成堆，山顶千门次第开。一骑红尘妃子笑，无人知是荔枝来。 泊秦淮 烟笼寒水月笼纱，夜泊秦淮近酒家。商女不知亡国恨，隔江犹唱后庭花。 江南春 千里莺啼绿映红，水村山郭酒旗风。南朝四百八十寺，多少楼台烟雨中。 寄扬州韩绰判官 青山隐隐水迢迢，秋尽江南草未凋。二十四桥明月夜，玉人何处教吹箫。 最后再来首爱情诗： 赠别一 多情却似总无情，惟觉樽前笑不成。蜡烛有心还惜别，替人垂泪到天明。 赠别二 聘聘袅袅十三余，豆蔻梢头二月初。春风十里扬州路，卷上珠帘总不如。 王维王维的作品大概可用四字概括：山、月、送、思，直接来看： 山中与裴秀才迪书 近腊月下，景气和畅，故山殊可过。足下方温经，猥不敢相烦，辄便往山中，憩感配寺，与山僧饭讫而去。北涉玄灞，清月映郭。夜登华子冈，辋水沦涟，与月上下。寒山远火，明灭林外。深巷寒犬，吠声如豹。村墟夜舂，复与疏钟相间。此时独坐，僮仆静默，多思曩昔，携手赋诗，步仄径，临清流也。当待春中，草木蔓发，春山可望，轻鲦出水，白鸥矫翼，露湿青皋，麦陇朝雊，斯之不远，倘能从我游乎？非子天机清妙者，岂能以此不急之务相邀。然是中有深趣矣！无忽。因驮黄檗人往，不一，山中人王维白。 山居秋暝 空山新雨后，天气晚来秋。明月松间照，清泉石上流。竹喧归浣女，莲动下渔舟。随意春芳歇，王孙自可留。 山中 荆溪白石出，天寒红叶稀。山路元无雨，空翠湿人衣。 竹里馆 独坐幽篁里，弹琴复长啸。深林人不知，明月来相照。 鹿柴 空山不见人，但闻人语响。返景入深林，复照青苔上。 鸟鸣涧 人闲桂花落，夜静春山空。月出惊山鸟，时鸣春涧中。 送元二使安西 渭城朝雨浥轻尘，客舍青青柳色新。劝君更尽一杯酒，西出阳关无故人。 山中送别 山中相送罢，日暮掩柴扉。春草明年绿，王孙归不归？ 送别 下马饮君酒，问君何所之。君言不得意，归卧南山陲。但去莫复问，白云无尽时。 九月九日忆山东兄弟 独在异乡为异客，每逢佳节倍思亲。遥知兄弟登高处，遍插茱萸少一人。 相思 红豆生南国，春来发几枝。愿君多采撷，此物最相思。 杂诗 君自故乡来，应知故乡事。来日绮窗前，寒梅著花未？ 如果我们认为王维只会写这些，那就错了，一身转战三千里，一剑曾当百万师何等霸气。来两首边塞诗： 观猎 风劲角弓鸣，将军猎渭城。草枯鹰眼疾，雪尽马蹄轻。忽过新丰市，还归细柳营。回看射雕处，千里暮云平。 使至塞上 单车欲问边，属国过居延。征蓬出汉塞，归雁入胡天。大漠孤烟直，长河落日圆。萧关逢候骑，都护在燕然。 最后来一首，以应诗佛之名： 终南别业 中岁颇好道，晚家南山陲。兴来每独往，胜事空自知。行到水穷处，坐看云起时。偶然值林叟，谈笑无还期。 孟浩然前面说杜甫爱李白，那李白爱谁呢？这里不是我八卦，人白自己都说了：吾爱孟夫子。这里的孟夫子不是与孔夫子并称的孟子，是孟浩然。下面是八卦了：甫爱白，白爱浩，浩爱维，维爱秀才迪，这是一个单相思生物链，从这点也能理解李白和王维两个同时代的绝世高手为什么老死不相往来了。扯远了，看孟浩然如何爱王维： 留别王维 寂寂竟何待，朝朝空自归。欲寻芳草去，惜与故人违。当路谁相假，知音世所稀。只应守寂寞，还掩故园扉。 这里有必要引一下李白为什么爱孟浩然： 李白.赠孟浩然 吾爱孟夫子，风流天下闻。红颜弃轩冕，白首卧松云。醉月频中圣，迷花不事君。高山安可仰，徒此揖清芬。 原来白爱的是浩的放荡不羁爱自由。 孟浩然生活虽然洒脱自由，但写诗可不像李白杜甫的那样自由，有名的基本都是五言，或绝或律，自然工整，请看： 春晓 春眠不觉晓，处处闻啼鸟。夜来风雨声，花落知多少。 宿建德江 移舟泊烟渚，日暮客愁新。野旷天低树，江清月近人。 过故人庄 故人具鸡黍，邀我至田家。绿树村边合，青山郭外斜。开轩面场圃，把酒话桑麻。待到重阳日，还来就菊花。 临洞庭湖赠张丞相 八月湖水平，涵虚混太清。气蒸云梦泽，波撼岳阳城。欲济无舟楫，端居耻圣明。坐观垂钓者，徒有羡鱼情。 田家元日 昨夜斗回北，今朝岁起东。我年已强仕，无禄尚忧农。桑野就耕父，荷锄随牧童。田家占气候，共说此年丰。 刘禹锡汉景帝阁下玄孙，中山靖王之后这不仅适用刘备，同样适用刘禹锡。先来一篇耳熟能详的： 陋室铭 山不在高，有仙则名。水不在深，有龙则灵。斯是陋室，惟吾德馨。苔痕上阶绿，草色入帘青。谈笑有鸿儒，往来无白丁。可以调素琴，阅金经。无丝竹之乱耳，无案牍之劳形。南阳诸葛庐，西蜀子云亭。孔子云：何陋之有？ 再来几首豪气干云的，来应诗豪之名： 秋词 自古逢秋悲寂寥，我言秋日胜春朝。晴空一鹤排云上，便引诗情到碧霄。 望洞庭 湖光秋月两相和，潭面无风镜未磨。遥望洞庭山水色，白银盘里一青螺。 浪淘沙 九曲黄河万里沙，浪淘风簸自天涯。如今直上银河去，同到牵牛织女家。 竹枝词 杨柳青青江水平，闻郎江上踏歌声。东边日出西边雨，道是无晴却有晴。 乌衣巷 朱雀桥边野草花，乌衣巷口夕阳斜。旧时王谢堂前燕，飞入寻常百姓家。 赏牡丹 庭前芍药妖无格，池上芙蕖净少情。唯有牡丹真国色，花开时节动京城。 再游玄都观 百亩庭中半是苔，桃花净尽菜花开。种桃道士归何处，前度刘郎今又来。 最后来首刘禹锡赠乐天的诗，以引出白居易： 酬乐天扬州初逢席上见赠 巴山楚水凄凉地，二十三年弃置身。怀旧空吟闻笛赋，到乡翻似烂柯人。沉舟侧畔千帆过，病树前头万木春。今日听君歌一曲，暂凭杯酒长精神。 白居易之所以把白居易放如此靠后，我也是支持普遍的说法，如果白老没有长恨歌与琵琶行两篇长诗传世，那么他在唐代诗人中的地位是入不了前十的。再说了，韩愈和柳宗元都更靠后了，人也没意见。好了，两篇不抄，抄点白老其他的看看。 草 离离原上草，一岁一枯荣。野火烧不尽，春风吹又生。远芳侵古道，晴翠接荒城。又送王孙去，萋萋满别情。 钱塘湖春行 孤山寺北贾亭西，水面初平云脚低。几处早莺争暖树，谁家新燕啄春泥。乱花渐欲迷人眼，浅草才能没马蹄。最爱湖东行不足，绿杨阴里白沙堤。 卖炭翁 卖炭翁，伐薪烧炭南山中。满面尘灰烟火色，两鬓苍苍十指黑。卖炭得钱何所营？身上衣裳口中食。可怜身上衣正单，心忧炭贱愿天寒。夜来城外一尺雪，晓驾炭车辗冰辙。牛困人饥日已高，市南门外泥中歇。翩翩两骑来是谁？黄衣使者白衫儿。手把文书口称敕，回车叱牛牵向北。一车炭，千余斤，宫使驱将惜不得。半匹红绡一丈绫，系向牛头充炭直。 暮江吟 一道残阳铺水中，半江瑟瑟半江红。可怜九月初三夜，露似真珠月似弓。 南浦别 南浦凄凄别，西风袅袅秋。一看肠一断，好去莫回头。 问刘十九 绿蚁新醅酒，红泥小火炉。晚来天欲雪，能饮一杯无？ 大林寺桃花 人间四月芳菲尽，山寺桃花始盛开。长恨春归无觅处，不知转入此中来。 忆江南词二首 江南好，风景旧曾谙。日出江花红胜火，春来江水绿如蓝。能不忆江南？江南忆，最忆是杭州。山寺月中寻桂子，郡亭枕上看潮头。何日更重游！ 边塞韩柳其他宋元明清]]></content>
  </entry>
  <entry>
    <title><![CDATA[从Python到Django入门]]></title>
    <url>%2F2018%2F05%2F11%2Fpython27-to-django-primer%2F</url>
    <content type="text"><![CDATA[上一篇写socket实例的时候切身感受到了python的简单，于是最近想写一些关于python的文章。那就像之前的那些文章那样，整个入门教程吧。 前言写这篇基本是没有自己的思想的，纯粹是为了学习python，所以下面的内容基本都是从别处搬来的。网上有两篇写的很好的python学习的中文教程，一篇是廖雪峰的，一篇是Vamei的。这两篇对我学习python帮助巨大，但我这篇不想抄他们的。 我要抄的是一本叫做Python Web Development with Django书上的，这本书是外国人写的介绍Django开发Web程序的（书比较老了，写例子时要改成较新的），这里直接照搬其第一部分，作为Python的入门文章，所以有了这篇的题目。 Python练习Python是编程新手的最好的语言，因为它足够简单。 直接上个代码感受下吧。 12345&gt;&gt;&gt; print 'hello, world.'&gt;&gt;&gt; for word in ['capitalize','these','words']:... print word.upper()&gt;&gt;&gt; for i in range(0,5):... print i 基础注释 123# this entire line is a commentfoo = 1 # short comment: assign int 1 to 'foo'print 'Python and %s are number %d' % ('Django,foo) 变量及赋值 12foo = 'bar'foo = 10 运算符：算数运算符+-*/等，赋值运算符+=,-=,*=等（不支持++,–），关系运算符&lt;,&gt;=,==,!=等，逻辑运算符and,or,not 123show_output = Trueif show_output and foo==1: print 'hello' 标准类型布尔型 1234567891011&gt;&gt;&gt; download_complete = False&gt;&gt;&gt; bool(download_complete)False&gt;&gt;&gt; bool(-1.23)True&gt;&gt;&gt; bool(0.0)False&gt;&gt;&gt; bool("")False&gt;&gt;&gt; bool([None,0])True 数值型：两种主要的数值类型int和float 12345678910111213141516171819202122&gt;&gt;&gt; 1/20&gt;&gt;&gt; 1.0/2.00.5&gt;&gt;&gt; 1//20&gt;&gt;&gt; 1.0//2.00&gt;&gt;&gt; int('123')123&gt;&gt;&gt; int(45.67)45&gt;&gt;&gt; round(1.16,1) #四舍五入1.2&gt;&gt;&gt; fload(10)10.0&gt;&gt;&gt; ord('a')97&gt;&gt;&gt; chr(65)A&gt;&gt;&gt; divmod(15,6) #除余(2,3) 序列和迭代 字符串 1234567891011121314151617181920212223242526272829&gt;&gt;&gt; s='Python'&gt;&gt;&gt; s'Python'&gt;&gt;&gt; s[0]'P'&gt;&gt;&gt; s[4]'o'&gt;&gt;&gt; s[-1]'n'&gt;&gt;&gt; s[1:4]'yth'&gt;&gt;&gt; s[2:4]'th'&gt;&gt;&gt; s[:4]'Pyth'&gt;&gt;&gt; s[3:]'hon'&gt;&gt;&gt; s[:]'Python'&gt;&gt;&gt; str(s)'Python'&gt;&gt;&gt; 'Python and'+' '+'Django are cool''Python and Django are cool'&gt;&gt;&gt; '-'*40'----------------------------------------'&gt;&gt;&gt; 'an' in 'Django'True&gt;&gt;&gt; 'xyz' not in 'Django'True 列表 1234567891011121314151617181920212223242526272829303132333435363738&gt;&gt;&gt; book=['Python','Development',8]&gt;&gt;&gt; book.append(2008)&gt;&gt;&gt; book['Python', 'Development', 8, 2008]&gt;&gt;&gt; book.insert(1,'Web')&gt;&gt;&gt; book['Python', 'Web', 'Development', 8, 2008]&gt;&gt;&gt; book.insert(1,'Web')&gt;&gt;&gt; book['Python', 'Web', 'Development', 8, 2008]&gt;&gt;&gt; book[3]8&gt;&gt;&gt; 'Python' in bookTrue&gt;&gt;&gt; 'Django' in bookFalse&gt;&gt;&gt; book.remove(8)&gt;&gt;&gt; book.pop(-1)2008&gt;&gt;&gt; book['Python', 'Web', 'Development']&gt;&gt;&gt; book*2['Python', 'Web', 'Development', 'Python', 'Web', 'Development']&gt;&gt;&gt; book.extend(['with','Django'])&gt;&gt;&gt; book['Python', 'Web', 'Development', 'with', 'Django']&gt;&gt;&gt; book.sort()&gt;&gt;&gt; book['Development', 'Django', 'Python', 'Web', 'with']&gt;&gt;&gt; data=[x+1 for x in range(10)]&gt;&gt;&gt; data[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&gt;&gt;&gt; even_nums=[x for x in range(10) if x%2==0]&gt;&gt;&gt; even_nums[0, 2, 4, 6, 8]&gt;&gt;&gt; even_nums=(x for x in range(10000) if x%2==0)&gt;&gt;&gt; even_nums&lt;generator object &lt;genexpr&gt; at 0x0265FF58&gt; 字符串函数 123456789101112131415161718192021222324252627&gt;&gt;&gt; s='Django is cool'&gt;&gt;&gt; s.split()['Django', 'is', 'cool']&gt;&gt;&gt; words=s.split()&gt;&gt;&gt; ' '.join()&gt;&gt;&gt; ' '.join(words)'Django is cool'&gt;&gt;&gt; '-'.join(words)'Django-is-cool'&gt;&gt;&gt; s.upper()'DJANGO IS COOL'&gt;&gt;&gt; s.upper().isupper()True&gt;&gt;&gt; s.title()'Django Is Cool'&gt;&gt;&gt; s.capitalize()'Django is cool'&gt;&gt;&gt; s.count('o')3&gt;&gt;&gt; s.find('go')4&gt;&gt;&gt; s.find('xxx')-1&gt;&gt;&gt; s.startswith('Python')False&gt;&gt;&gt; s.replace('Django','Python')'Python is cool' 字符串其他 1234567891011121314&gt;&gt;&gt; mystr=u'This is unicode'&gt;&gt;&gt; mystru'This is unicode'&gt;&gt;&gt; print mystrThis is unicode&gt;&gt;&gt; str(mystr)'This is unicode'&gt;&gt;&gt; hi='''hi... there'''&gt;&gt;&gt; hi'hi\nthere'&gt;&gt;&gt; print hihithere 元组 1234567891011121314&gt;&gt;&gt; a=("one","two")&gt;&gt;&gt; a[0]'one'&gt;&gt;&gt; b=("just-one")&gt;&gt;&gt; b[0]'j'&gt;&gt;&gt; b=("just-one",)&gt;&gt;&gt; b[0]'just-one'&gt;&gt;&gt; c='just-one',&gt;&gt;&gt; c('just-one',)&gt;&gt;&gt; c[0]'just-one' 字典 1234567891011121314151617181920212223242526272829303132333435&gt;&gt;&gt; book=&#123;'title':'Python Web Development','year':2008&#125;&gt;&gt;&gt; book&#123;'year': 2008, 'title': 'Python Web Development'&#125;&gt;&gt;&gt; 'year' in bookTrue&gt;&gt;&gt; 2008 in bookFalse&gt;&gt;&gt; book.get('pub','N/A')'N/A'&gt;&gt;&gt; book['pub']='Wesley'&gt;&gt;&gt; book.get('pub','N/A')'Wesley'&gt;&gt;&gt; for key in book:... print key,':',book[key]...year : 2008pub : Wesleytitle : Python Web Development&gt;&gt;&gt; del book['year']&gt;&gt;&gt; book&#123;'pub': 'Wesley', 'title': 'Python Web Development'&#125;&gt;&gt;&gt; len(book)2&gt;&gt;&gt; for k in book.keys():print k...pubtitle&gt;&gt;&gt; for v in book.values():print v...WesleyPython Web Development&gt;&gt;&gt; for i in book.items():print i...('pub', 'Wesley')('title', 'Python Web Development') 流程控制条件判断 1234567data = raw_input('Enter "y" or "n": ')if data[0] == 'y': print 'yes'elif data[0] == 'n': print 'no'else: print 'Invalid key entered' 循环 1234567i = 0while i &lt; 5: print i i += 1data = (123, 'abc', 3.14)for i,value in enumerate(data): print i,value 异常捕获12345678try: process_some_data()except (TypeError, ValueError), e: print "ERROR: you provide invalid data", eexcept ArithmeticError, e: print "ERROR: some math error occurred", eexcept Exception, e: print "ERROR: you provide invalid data", e finally 12345try: get_mutex() do_some_stuff()finally: free_mutex() 省事的写法 123456try: passexcept: passfinally: pass 抛出异常 123456789def foo(must_be_positive_int): """foo() -- take positive integer and process it""" # check if integer if not isinstance(must_be_positive_int, int): raise TypeError("ERROR foo(): must pass in an integer!") # check if positive if must_be_positive_int &lt; 1: raise ValueError("ERROR foo(): integer must be greater than zero!") # normal processing here 文件操作12345678f = open('1.txt', 'w')f.write('foo\n')f.write('bar\n')f.close()f = open('1.txt', 'r')for line in f: print line.rstrip()f.close() 函数函数声明和调用 123def foo(x): print xfoo(12) 一个有用的函数 123456789101112import httplibdef check_web_server(host, port, path): h = httplib.HTTPConnection(host, port) h.request('GET', path) resp = h.getresponse() print 'HTTP Response:' print ' status =', resp.status print ' reason =', resp.reason print 'HTTP Headers:' for hdr in resp.getheaders(): print ' %s: %s' % hdrcheck_web_server(port=80, path='/', host='www.python.org') 一个默认参数的例子 12345678910&gt;&gt;&gt; def func(arg=[]):... arg.append(1)... print arg...&gt;&gt;&gt; func()[1]&gt;&gt;&gt; func()[1, 1]&gt;&gt;&gt; func()[1, 1, 1] 函数引用 12345678def bar(): print 'bar'bar()baz = barbaz()func_list = [bar, baz]for f in func_list: f() 匿名函数 12345&gt;&gt;&gt; starList=[('bruce','li'),('jack','cheng'),('jet','li'),('danniel','yin')]&gt;&gt;&gt; sorted(starList)[('bruce', 'li'), ('danniel', 'yin'), ('jack', 'cheng'), ('jet', 'li')]&gt;&gt;&gt; sorted(starList, key=lambda star:star[1])[('jack', 'cheng'), ('bruce', 'li'), ('jet', 'li'), ('danniel', 'yin')] 可变参数 1234567891011121314151617181920212223242526&gt;&gt;&gt; def fun1(a,b,c):... print a,b,c...&gt;&gt;&gt; fun1(1,2,3)1 2 3&gt;&gt;&gt; l=['a','b','c']&gt;&gt;&gt; fun1(*l)a b c&gt;&gt;&gt; d=&#123;'a':1,'b':2,'c':3&#125;&gt;&gt;&gt; fun1(**d)1 2 3# 上面是传递参数的一种方式不是可变参数# 下面看真正的可变参数&gt;&gt;&gt; def fun2(*args,**kwargs):... print args... print kwargs...&gt;&gt;&gt; fun2(1,2,3)(1, 2, 3)&#123;&#125;&gt;&gt;&gt; fun2(1,2,3,a='1',b='2',c='3')(1, 2, 3)&#123;'a': '1', 'c': '3', 'b': '2'&#125;&gt;&gt;&gt; fun2(*l,**d)('a', 'b', 'c')&#123;'a': 1, 'c': 3, 'b': 2&#125; 装饰器 1234567891011121314151617181920&gt;&gt;&gt; def foo():... print 'foo run'...&gt;&gt;&gt; foo()foo run&gt;&gt;&gt; def log(func):... def wrapper():... print '%s() call begin'%func.__name__... func()... print '%s() call end'%func.__name__... return wrapper...&gt;&gt;&gt; @log... def foo1():... print 'foo1 run'...&gt;&gt;&gt; foo1()foo1() call beginfoo1 runfoo1() call end 面向对象类定义 12345678910111213141516class AddressBookEntry(object): version = 0.1 def __init__(self, name, phone): self.name = name self.phone = phone def update_phone(self, phone): self.phone = phone# 创建对象john = AddressBookEntry('John Doe', '408-555-1212')jane = AddressBookEntry('Jane Doe', '650-555-1212')# 实例调用john.update_phone('510-555-1212')john.phone# 动态实例属性john.xxx = 'abc'john.xxx 类继承 12345class EmployeeAddressBookEntry(AddressBookEntry): def __init__(self, name, phone, id, social): AddressBookEntry.__init__(self, name, phone) self.empid = id self.ssn = social 内部类 123class MyClass(object): class InnerClass: pass 总结以上是Python的入门教程，后面介绍Django入门。 Django快速上手Django声称自己是目前最完美的Web开发框架。本章整一个使用Django建立Blog站点的例子，看看Django到底怎么完美了。 安装我的python版本 12C:\Users\Administrator&gt;python --versionPython 2.7.12 常用安装方式 12&gt; pip install Django #安装最新版本&gt; pip install Django==1.8.2 #安装指定版本 我的网络不行，于是我是这么装的 12#解压安装包Django-1.8.2.tar.gz&gt; python setup.py install 验证安装是否成功 12&gt; python -c "import django;print django.VERSION"(1, 8, 2, 'final', 0) 搭建博客前面一直是在windows下写的，到这里突然发现在windows下来回切换目录还挺费劲，于是转到linux下了。这是我linux的环境： 1234$ python -VPython 2.7.5$ python -c 'import django;print django.get_version()'1.11.6 下面是建立博客站点的过程。 创建工程执行如下命令创建工程mysite： 1$ django-admin startproject mysite 创建成功后看看工程目录结构 12345678$ tree mysitemysite├── manage.py└── mysite ├── __init__.py ├── settings.py ├── urls.py └── wsgi.py 相关文件在后面会用到，这里就不介绍了。 运行开发服务执行命令运行工程。 12$ cd mysite$ python manage.py runserver 执行后会显示如下信息： 1234May 11, 2018 - 08:15:26Django version 1.11.6, using settings &apos;mysite.settings&apos;Starting development server at http://127.0.0.1:8000/Quit the server with CONTROL-C. 创建博客应用执行命令创建博客应用。 1$ python manage.py startapp blog 这时会在工程目录mysite下生成出一个blog应用目录，默认也建立好了几个文件。 创建模型创建模型就是到blog目录下修改models.py文件，修改内容如下： vim blog/models.py12345678910# -*- coding: utf-8 -*-from __future__ import unicode_literalsfrom django.db import models# Create your models here.class BlogPost(models.Model): title = models.CharField(max_length=150) body = models.TextField() timestamp = models.DateTimeField() 设置数据库首先要对mysite/settings.py做一处修改，加入blog应用。 123456789INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'blog',] 然后还是修改该配置文件，修改数据库（这里用的是默认的sqlite3）： 123456DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), &#125;&#125; 创建相关表执行命令： 12$ python manage.py migrate$ python manage.py makemigrations 这样会根据之前创建的模型自动创建数据库表。 admin修改blog/admin.py，修改如下： 1234567891011# -*- coding: utf-8 -*-from __future__ import unicode_literalsfrom django.contrib import adminfrom .models import BlogPost# Register your models here.#admin.site.register(BlogPost)class BlogPostAdmin(admin.ModelAdmin): list_display = ('title', 'timestamp')admin.site.register(BlogPost, BlogPostAdmin) 执行命令创建超级用户： 1$ python manage.py createsuperuser 查看mysite/urls.py下是否有相应记录。 123456from django.conf.urls import urlfrom django.contrib import adminurlpatterns = [ url(r'^admin/', admin.site.urls),] 这样后就可以用创建的用户登录网站进行BlogPost数据表管理了http://localhost:8000/admin。 制作博客显示页在blog目录下创建templates目录，在其下创建模板文件。 base.html12345678910111213&lt;html&gt;&lt;style type="text/css"&gt;body &#123; color: #efd; background: #453; padding: 0 5em; margin: 0 &#125;h1 &#123; padding: 2em 1em; background: #675 &#125;h2 &#123; color: #bf8; border-top: 1px dotted #fff; margin-top: 2em &#125;p &#123; margin: 1em 0 &#125;&lt;/style&gt;&lt;body&gt;&lt;h1&gt;mysite.example.com&lt;/h1&gt;&#123;% block content %&#125;&#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; archive.html12345678&#123;% extends "base.html" %&#125;&#123;% block content %&#125;&#123;% for post in posts %&#125;&lt;h2&gt;&#123;&#123; post.title &#125;&#125;&lt;/h2&gt;&lt;p&gt;&#123;&#123; post.timestamp &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; post.body &#125;&#125;&lt;/p&gt;&#123;% endfor %&#125;&#123;% endblock %&#125; 编写视图方法，修改blog/views.py文件： 1234567891011# -*- coding: utf-8 -*-from __future__ import unicode_literalsfrom django.shortcuts import renderfrom .models import BlogPost# Create your views here.def archive(request): posts = BlogPost.objects.all() ctx = &#123;'posts': posts&#125; return render(request, 'archive.html', ctx) 修改mysite/urls.py，添加访问路径。 1234urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^blog/', include('blog.urls')),] 修改blog/urls.py文件，添加访问路径。 123urlpatterns = [ url(r'^blog/', 'blog.views.archive'),] 好了，可以访问了，输入网址http://localhost:8000/blog/ 开始]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[socket简单实例的不同语言实现]]></title>
    <url>%2F2018%2F05%2F10%2Fsocket%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B%E7%9A%84%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[先描述一个场景：服务端监听8888端口，接收客户端发送来的消息，服务端打印客户端地址后，把接收到的消息原样发回客户端，客户端收到服务端发回的消息后打印出来。使用socket的TCP和UDP分别实现一个。下面看不同语言下都是怎么实现的。 C实现TCP tcp-server.c12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;int main()&#123; int listenfd; int connfd; int len; struct sockaddr_in servaddr; struct sockaddr_in cliaddr; int sin_size; char buf[BUFSIZ]; memset(&amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(8888); listenfd = socket(AF_INET, SOCK_STREAM, 0); bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); listen(listenfd, 10); sin_size = sizeof(cliaddr); connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;sin_size); printf("accept client %s\n", inet_ntoa(cliaddr.sin_addr)); len = recv(connfd, buf, BUFSIZ, 0); send(connfd, buf, len, 0); close(connfd); close(listenfd); return 0;&#125; tcp-client.c123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;int main()&#123; int connfd; int len; struct sockaddr_in servaddr; char buf[BUFSIZ]; memset(&amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = inet_addr("127.0.0.1"); servaddr.sin_port = htons(8888); connfd = socket(AF_INET, SOCK_STREAM, 0); connect(connfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); send(connfd, "hello", strlen("hello"), 0); len = recv(connfd, buf, BUFSIZ, 0); printf("receive: %s\n", buf); close(connfd); return 0;&#125; UDP udp-server.c123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;int main()&#123; int sockfd; int len; struct sockaddr_in servaddr; struct sockaddr_in cliaddr; int sin_size; char buf[BUFSIZ]; memset(&amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(8888); sockfd = socket(AF_INET, SOCK_DGRAM, 0); bind(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); sin_size = sizeof(cliaddr); printf("wait for a packet\n"); len = recvfrom(sockfd, buf, BUFSIZ, 0, (struct sockaddr *)&amp;cliaddr, &amp;sin_size); printf("receive packet from %s\n", inet_ntoa(cliaddr.sin_addr)); sendto(sockfd, buf, len, 0, (struct sockaddr *)&amp;cliaddr, sizeof(cliaddr)); close(sockfd); return 0;&#125; udp-client.c123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;int main()&#123; int sockfd; int len; struct sockaddr_in servaddr; int sin_size; char buf[BUFSIZ]; memset(&amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = inet_addr("127.0.0.1"); servaddr.sin_port = htons(8888); sockfd = socket(AF_INET, SOCK_DGRAM, 0); sin_size = sizeof(servaddr); len = sendto(sockfd, "hello", strlen("hello"), 0, (struct sockaddr *)&amp;servaddr, sin_size); recvfrom(sockfd, buf, BUFSIZ, 0, (struct sockaddr *)&amp;servaddr, &amp;sin_size); printf("receive packet: %s\n", buf); close(sockfd); return 0;&#125; Java实现TCP TcpServer.java12345678910111213141516171819import java.net.*;import java.io.*;public class TcpServer &#123; public static void main(String[] args) throws Exception &#123; ServerSocket server = new ServerSocket(8888); Socket socket = server.accept(); String ip = socket.getInetAddress().getHostAddress(); System.out.println(ip); InputStream is = socket.getInputStream(); byte[] buf = new byte[1024]; is.read(buf, 0, buf.length); String info = new String(buf); OutputStream os = socket.getOutputStream(); byte[] data = info.getBytes(); os.write(data, 0, data.length); socket.close(); server.close(); &#125;&#125; TcpClient.java12345678910111213141516import java.net.*;import java.io.*;public class TcpClient &#123; public static void main(String[] args) throws Exception &#123; Socket socket = new Socket("127.0.0.1", 8888); OutputStream os = socket.getOutputStream(); byte[] data = "hello".getBytes(); os.write(data); InputStream is = socket.getInputStream(); byte[] buf = new byte[1024]; is.read(buf, 0, buf.length); String reply = new String(buf); System.out.println(reply); socket.close(); &#125;&#125; UDP UdpServer.java12345678910111213141516import java.net.*;public class UdpServer &#123; public static void main(String[] args) throws Exception &#123; DatagramSocket server = new DatagramSocket(8888); byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf, buf.length); server.receive(packet); String info = new String(buf, 0, packet.getLength()); InetAddress address = packet.getAddress(); int port = packet.getPort(); byte[] data = info.getBytes(); packet = new DatagramPacket(data, data.length, address, port); server.send(packet); server.close(); &#125;&#125; UdpClient.java1234567891011121314151617import java.net.*;public class UdpClient &#123; public static void main(String[] args) throws Exception &#123; InetAddress address = InetAddress.getByName("127.0.0.1"); int port = 8888; byte[] data = "hello".getBytes(); DatagramPacket packet = new DatagramPacket(data, data.length, address, port); DatagramSocket client = new DatagramSocket(); client.send(packet); byte[] buf = new byte[1024]; packet = new DatagramPacket(buf, buf.length); client.receive(packet); String reply = new String(buf, 0, packet.getLength()); System.out.println(reply); client.close(); &#125;&#125; Python实现TCP tcp-server.py12345678910import sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.bind(('', 8888))s.listen(8)conn,addr = s.accept()print addr[0]buf = conn.recv(1024)conn.send(buf)conn.close()s.close() tcp-client.py1234567import sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect(('127.0.0.1',8888))s.send('hello')data = s.recv(1024)print datas.close() UDP udp-server.py123456import sockets = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)s.bind(('',8888))data,addr = s.recvfrom(1024)s.sendto(data, addr)s.close() udp-client.py123456import sockets = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)s.sendto('hello', ('127.0.0.1',8888))data = s.recv(1024)print datas.close() 总结不同语言实现相同功能，从代码量来看，肯定是python最少。为减轻工作量，有必要学习python。]]></content>
      <categories>
        <category>语言对比</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>c</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gdb学习笔记]]></title>
    <url>%2F2018%2F05%2F09%2Fgdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[接连两篇笔记vim和makefile，vim可以看作是程序的编辑，makefile可以看作程序的编译，那么是时候再整一篇程序调试的文章了。linux下调试c/c++程序的命令是gdb，下面就记录一下gdb的常用操作。 常用调试命令只有用gcc -g生成的程序才能调试。 命令 说明 backtrace(bt) 查看堆栈 finish 运行完当前函数 frame(f) 帧号 选择栈帧 info(i) locals 查看当前栈帧局部变量值 list(l) 行号 列出源码 next(n) 执行下一行 print(p) 打印表达式的值 quit(q) 退出gdb调试环境 set var 修改变量的值 start 执行程序，在main的第一行语句前停下 step(s) 执行下一步（进入函数） kill 终止正在调试的程序 break(b) 行号 断点 break 函数名 断点 break 文件名:行号 断点 continue(c) 从当前位置开始继续执行 delete breakpoints 断点号 删除断点 display 变量名 跟踪某个变量 disable breakpoints 断点号 禁用断点 enable 断点号 启用断点 info(i) breakpoints 查看断点 run(r) 重新运行程序 undisplay 跟踪显示号 取消跟踪 watch 设置观察点 info(i) watchpoints 查看观察点 x x/7b input//从input变量处打印7个存储单元的内容 shell cmd 执行命令 set args 设置参数 show args 查看参数 show paths 查看程序运行路径 set environment varname=val 设置环境变量 show environment varname 查看环境变量 cd 切换目录 pwd 查看当前目录 info program 查看程序状态 clear 行号n 清除第n行上的断点 help 帮助 启动调试方法 gdb gdb core gdb 调试core文件查看系统是否支持dump core功能： 123$ ulimit -c或$ ulimit -a 配置系统使其支持生成core： 1$ ulimit -c unlimited gdb调试core文件： 1$ gdb a.out my.core 总结上面就是个简单的入门，要想深入还是要上网搜。]]></content>
      <categories>
        <category>linux.c</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>笔记</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[makefile学习笔记]]></title>
    <url>%2F2018%2F05%2F09%2Fmakefile%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[linux下开发c/c++程序需要写makefile，makefile是用来组织和构建工程的。其实不只编写c/c++程序要写makefile，所有语言的开发都可以写makefile，甚至所有的事情都可以。本篇就简要记录下写makefile常用操作。 make命令执行命令make时会在当前目录下寻找名称为makefile或Makefile的文件去执行，要指定执行哪个文件，需要执行如下命令： 1$ make -f Makefile.1 可以在运行make命令时定义变量，如：make CFLAGS=-O2 编写规则基本规则makefile由一组规则组成，每条规则的格式是： 123target ...: prerequisites ... command ... 例如： 123目标: 条件1 条件2 命令1 命令2 目标和条件之间的关系是：要更新目标必须先更新它所有的条件。有一个条件更新则目标也要被更新。 命令列表每行必须以tab开头。 常用的目标名： all #执行主要的编译工作，通常为缺省目标； install #执行编译后的安装工作； clean #清理编译结构； 隐含规则如果一个目标分开写多条规则，则只有其中一条规则允许有命令列表，否则以最后一条规则的命令列表执行。 隐含规则可以用make -p命令查看，例如省略了命令列表的规则就利用了隐含规则。 我们写makefile时不利用隐含规则也能完成相应工作，只不过就多写些罢了。 特殊变量 $@ #表示规则中的目标； $&lt; #表示规则中的第一个条件； $^ #表示规则中的所有条件； $? #表示规则中所有比目标新的条件； 实例源码设有如下源码文件： a.h1234#ifndef _A_H_#define _A_H_void hello_a();#endif b.h1234#ifndef _B_H_#define _B_H_void hello_b();#endif a.c123456#include "a.h"#include &lt;stdio.h&gt;void hello_a()&#123; printf("hello,a\n");&#125; b.c123456#include "b.h"#include &lt;stdio.h&gt;void hello_b()&#123; printf("hello,b\n");&#125; main.c12345678#include "a.h"#include "b.h"int main(void)&#123; hello_a(); hello_b(); return 0;&#125; 写makefile上面的源码如何通过makefile组织并构建工程呢？下面是普通写法： 123456main: main.o a.o b.o gcc -o $@ $^.c.o: gcc -c $&lt;clean: rm -f *.o main 上面的写法对c++代码一样有效，就是把gcc换成g++，把.c.o换成.cpp.o就可以。 高级一些的写法： 12345678910111213CC=gccCFLAGS = -Wall -O2CFLAGS += -I./ -L./LFLAGS = -lpthread -lmSRCS = a.c \ b.c \ main.cOBJS=$(SRCS:.c=.o)EXEC=testall:$(OBJS) $(CC) $(CFLAGS) $(OBJS) -o $(EXEC) $(LFLAGS)clean: rm -f $(EXEC) $(OBJS) 总结以上记录的这些作为入门已经够了，要想更深入学习可以网上搜索跟我一起写Makefile，跟高手学习更好。]]></content>
      <categories>
        <category>linux.c</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>笔记</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim使用笔记]]></title>
    <url>%2F2018%2F05%2F09%2Fvim%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[对常在linux下写代码的人来说，编辑器首推vim和emacs。emacs号称神的编辑器，我觉得这是因为它是GNU大神Stallman开发的缘故，我也用过一段时间emacs，但是一般系统安装时都默认不会安装它，于是后来不常用了。而vim一般系统上都会带着，那这篇就记录一下号称编辑器之神的vim的常见使用方法。 常用配置linux下的配置vim ~/.vimrc 123456789syntax on #语法高亮set nocompatible #去掉vi一致性模式set number #显示行号set autoindent #自动对齐set smartindent #智能对齐set cindent #c语言风格对齐set tabstop=4 #设置tab键为4空格set shiftwidth=4 #自动缩进时为4空格set textwidth=0 #设置不自动换行 windows下的配置下面是我在windows下使用vim时的终极配置，主要解决UTF8文件乱码问题。 vim %VIMHOME%/_vimrc 123456789101112set encoding=utf-8set fileencodings=utf-8,gbk,cp936language messages zh_CN.utf-8source $VIMRUNTIME/delmenu.vimsource $VIMRUNTIME/menu.vimset termencoding=cp936#解决终端乱码set nobackupset aiset siset ciset ts=4set sw=4 其它配置其实vim配置文件中是以双引号注释的，我写这篇文章的时候加双引号老是语法高亮，于是我就用了linux下的常用注释方式。 有些配置写在配置文件中不是很合适，因为在文档编辑过程中可能经常修改，这里列出来。 123456789set nu #显示行号set nonu #关闭行号set paste #设为粘贴模式，粘贴时不自动缩进set nopaste #关闭粘贴模式set ff? #显示当前文件格式set ff=unix #将文件转换成unix格式set ff=dos #将文件转换为dos格式set ignorecase|ic #设置查找时忽略大小写set noignorecase|noic #查找时不忽略大小写 常用操作移动光标 操作 说明 hjkl 前下上右 ctrl-f,ctrl-b 向下、向上翻页 0,$ 移动到行的最前、最后 ^ 移动到一行除空白外的最前 G,nG,gg 移动到最后、第n、第一行 zz,zt,zb 光标所在的行居中、上、下 一般模式下输入数字n回车 向下移动n行 搜索和替换 操作 说明 /word 搜索单词word n,N 向下、向上搜 :n1,n2s/w1/w2/g 替换n1-n2行间的w1为w2 :1,$s/w1/w2/g 替换所有 :%s/w1/w2/g 替换所有 :%s/word//gn 统计word出现次数 正则表达式批量注释ctrl+v 进入列编辑模式,向下或向上移动光标,把需要注释的行的开头标记起来,然后按大写的I(shift+i),再插入注释符,比如”//“,再按Esc,就会全部注释了 ctrl+v,进入列编辑模式,横向选中列的个数(如”//“注释符号,需要选中两列),然后按d, 就会删除注释符号 windows下为ctrl+q 批量缩进：v进入可视模式，选择要缩进的代码块，&gt;缩进、&lt;缩回 查找选中的内容 v h/j/k/l y / ctrl-r 0 复制粘贴删除等操作 操作 说明 x,X 向后、向前删除一个字符 nx 向后删除n个字符 dd,ndd 删除1行、n行 yy,nyy 复制1行、n行 p,P 在光标后、前粘贴 u 撤销 ctrl-r 重做 . 重复上个动作 模式切换一般模式到编辑模式使用vim打开一个文件时默认进入一般模式。 操作 说明 i,I 插入 a,A 增加 o,O 新行 r,R 取代模式 按下esc键 退出编辑模式 一般模式到命令模式在一般模式下按下:键即可进入命令模式。命令模式下的常见操作有： 操作 说明 :w,:q,:wq,:q!,:x 保存、退出 :w filename 另存为 :r filename 读入到当前 :e filename 编辑另一个文件 :! cmd 执行命令cmd :set xxx 设置xxx项，如:set tw=0 编程时常用操作 操作 说明 % 括号匹配 ctrl-p 自动补全 :cd /p/p1/ 切换目录 :pwd 当前工作目录 :ls 当前打开的所有文件 :bd 关闭当前文件 shift+v 视图，用于选择文本 ggVGyy 全选复制 ctrl+6 两个打开的文件间切换 :bn 下一个文件 :bp 上一个文件 b1~n 切换至第n个打开的文件 :sp 水平分割窗口 :vsp 垂直分割窗口 :close 关闭分割窗口 ctrl+w+h/j/k/l 切换至前/下/上/后的窗口 ctrl+ww 一次向后切换 = 格式化选中内容 gu,gU 转换成小写、大写 J 合并下一行 :g/^/m0 倒置文件内容 :10,20s#^#//#g 用//注释10到20行 :10,20s#^//##g 删除10到20行的注释// 剪贴板使用将系统剪贴板内容粘贴进当前buffer中：在编辑模式下按shift+insert :reg #查看剪贴板内容 选中文本，”+y复制到系统剪贴板，”+p将系统剪贴板内容粘贴到普通模式下的光标所在处 更多操作 操作 说明 :E 浏览目录 :bn/bp/bl/bf 向后/向前/最后/第一个缓冲区切换 :He(!) 在下（上）面分屏浏览目录 :Ve(!) 在左（右）边分屏浏览目录 :Te tab页浏览文件 gt 下一个tab页 gT 上一个tab页 {i}gt 到第i个tab页 tabs 查看所有tab页编号-名 guu 把一行全部变成小写 gUU 把一行全部变成大写 ga 查看光标处字符的ascii码 g8 查看光标处字符的utf8编码 */# 查找光标处的单词 ctrl-o 向后回退光标移动 ctrl-l 向前追赶光标移动 ‘’ 两个单引号，跳转到光标上次停靠 :cw 在分屏中显示命令结果 gd 高亮显示光标处的单词 ctrl-w,q 退出当前窗口 :edit ++enc=cp936 buffer设为gb2312查看 :edit ++enc=utf-8 buffer设为utf-8查看 cw change word c0 改变当前到行首 c$ 改变当前到行尾 z回车 当前行置顶 z. 当前行置中 z- 当前行置底 H/M/L 移动光标到当前屏的上/中/下 回车 移动光标到下一行首字符 - 移动光标到上一行首字符 ^ 移动光标到第一个非空字符 :resize +10 调整split窗口大小 :vertical resize -10 调整vertical split窗口大小 ci”,( 在“”或（）中输入 f字符 向后条到本行下一个字符]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tinyxml2使用学习]]></title>
    <url>%2F2018%2F05%2F08%2Ftinyxml2%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[平时做c/c++开发时经常需要解析xml文件，linux一般就用libxml2做，但是更多时候写的代码需要在linx下跑也要在windows下跑，即使在windows有可能是vc写的还有可能是qt写的。这时解析xml就不那么方便。这里推荐一个tinyxml2开源库，使用了它，解析xml会轻松很多。 tinyxml2的使用比较简单，从官网指定的github地址上下载两个文件（tinyxml2.h、tinyxml2.cpp），然后项目中用到时加入就行了。 这篇文章直接上一个实例，通过这个实例应该可以学会如何使用tinyxml2进行xml的常用操作。 道生一，一生二，二生三，三生万物 废话少说，直接贴代码。 这是提前写好的xml文件：user.xml 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;users&gt; &lt;user name="aaa" age="33"/&gt; &lt;user name="bbb" age="22"/&gt;&lt;/users&gt; 这是实例代码文件：test1.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include "tinyxml2.h"using namespace tinyxml2;using namespace std;int main()&#123; cout&lt;&lt;"tinyxml2 test1."&lt;&lt;endl; cout&lt;&lt;"--------------------------"&lt;&lt;endl; cout&lt;&lt;"read from file."&lt;&lt;endl; cout&lt;&lt;"--------------------------"&lt;&lt;endl; XMLDocument doc; if (doc.LoadFile("./user.xml") != 0) &#123; cout&lt;&lt;"load xml file failed."&lt;&lt;endl; return 1; &#125; doc.Print(); cout&lt;&lt;"--------------------------"&lt;&lt;endl; cout&lt;&lt;"read from memory."&lt;&lt;endl; cout&lt;&lt;"--------------------------"&lt;&lt;endl; FILE *fp = fopen("user.xml", "r"); if (fp == NULL) &#123; cout&lt;&lt;"open file failed."&lt;&lt;endl; return 1; &#125; fseek(fp, 0, SEEK_END); int len = ftell(fp); cout&lt;&lt;"file length is "&lt;&lt;len&lt;&lt;endl; char *buf = (char*)malloc(len+1); memset(buf, 0, len+1); fseek(fp, 0, SEEK_SET); fread(buf, len, 1, fp); //printf("%s\n", buf); XMLDocument doc1; doc1.Parse(buf); free(buf); doc1.Print(); cout&lt;&lt;"--------------------------"&lt;&lt;endl; cout&lt;&lt;"get xml declaration"&lt;&lt;endl; cout&lt;&lt;"--------------------------"&lt;&lt;endl; XMLNode *decl = doc1.FirstChild(); XMLDeclaration *declaration = decl-&gt;ToDeclaration(); cout&lt;&lt;declaration-&gt;Value()&lt;&lt;endl; cout&lt;&lt;"--------------------------"&lt;&lt;endl; cout&lt;&lt;"add xml element"&lt;&lt;endl; cout&lt;&lt;"--------------------------"&lt;&lt;endl; XMLElement *root = doc1.RootElement(); XMLElement *userNode = doc1.NewElement("user"); userNode-&gt;SetAttribute("name", "ccc"); userNode-&gt;SetAttribute("age", "11"); root-&gt;InsertEndChild(userNode); userNode = doc1.NewElement("user"); userNode-&gt;SetAttribute("name", "xiaoming"); userNode-&gt;SetAttribute("age", "22"); XMLElement *descNode = doc1.NewElement("description"); XMLText *descText = doc1.NewText("xiaoming is a good boy"); descNode-&gt;InsertEndChild(descText); userNode-&gt;InsertEndChild(descNode); root-&gt;InsertEndChild(userNode); doc1.Print(); cout&lt;&lt;"--------------------------"&lt;&lt;endl; cout&lt;&lt;"find xml element"&lt;&lt;endl; cout&lt;&lt;"--------------------------"&lt;&lt;endl; XMLElement *userNode1 = root-&gt;FirstChildElement("user"); while (userNode1 != NULL) &#123; const char *name = userNode1-&gt;Attribute("name"); cout&lt;&lt;name&lt;&lt;endl; if (strcmp(name, "xiaoming") == 0) &#123; XMLElement *descNode1 = userNode1-&gt;FirstChildElement("description"); cout&lt;&lt;descNode1-&gt;GetText()&lt;&lt;endl; &#125; userNode1 = userNode1-&gt;NextSiblingElement(); &#125; cout&lt;&lt;"--------------------------"&lt;&lt;endl; cout&lt;&lt;"save xml element to file"&lt;&lt;endl; cout&lt;&lt;"--------------------------"&lt;&lt;endl; doc1.SaveFile("user1.xml"); cout&lt;&lt;"save ok"&lt;&lt;endl; return 0;&#125; 因为这个例子是一点点写成的，每修改一点就调用g++编译还比较费劲，就写了个makefile 12test1: test1.cpp tinyxml2.cpp g++ -o $@ $^ 这是执行测试程序后生出来的user1.xml 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;users&gt; &lt;user name="aaa" age="33"/&gt; &lt;user name="bbb" age="22"/&gt; &lt;user name="ccc" age="11"/&gt; &lt;user name="xiaoming" age="22"&gt; &lt;description&gt;xiaoming is a good boy&lt;/description&gt; &lt;/user&gt;&lt;/users&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[主流开发语言如何实现回调]]></title>
    <url>%2F2018%2F05%2F03%2Fcallback%E4%B8%BB%E6%B5%81%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[回调函数是很多流行开发语言都支持的，本文介绍一下各种语言都是怎么支持回调函数的。 什么是回调函数关于回调函数是什么，直接上一段引用： A callback function is a function passed into another function as an argument, which is then invoked inside the outer function to complete some kind of routine or action. 英语不好的我也大概知道什么意思：回调函数是一个函数，这个函数能作为参数传给另一个函数，另一个函数内部可以执行它。这个定义应该是javascript对回调函数的定义，其他语言也一个意思。 下面就介绍一下各种开发语言如何实现回调函数的。 Javascript回调函数，js肯定首当其冲，不多说，直接上代码。 1234567function callback_fun() &#123; alert('hello, world.');&#125;function func1(cbf) &#123; cbf();&#125;func1(callback_fun); 回调函数有什么用处？我觉得就是用于应用解耦，便于遵循开闭原则进行代码开发。 做js开发的肯定用过jquery，jquery对回调函数应用到了令人发指的地步，可以说是无处不回调。看代码： 12345$(document).ready(function() &#123; $('#hello').click(function() &#123; alert('hello, world.'); &#125;);&#125;); 三行代码，连用两个回调函数，不知道jquery除了回调还会什么。 Python说js最擅长回调，python肯定第一个不服，就上面的例子，代码写的跟js一样多就算我输。 12345def callback_fun(): print 'hello, world.'def func1(cbf): cbf()func1(callback_fun) 怎么样，是不是比js少。 C/C++对于回调，C语言同样不甘示弱，但为什么有人对C的回调函数不理解呢？先看代码： 123456789void callback_fun(int n) &#123; printf("hello, world. %d\n", n);&#125;void func1(void cbf(int)) &#123; cbf(2);&#125;main() &#123; func1(callback_fun);&#125; 上面例子除了由于c语言定义变量时要指定类型外，其他没有什么麻烦的，无非就是记住回调函数作为参数时的写法。但事实真的是这样么？接着修改例子func1： 12345void func1(void cbf(int)) &#123; void (*f)(int); f = cbf; f(2);&#125; 必须写成这样，如果写成void f(int)是不行的。这是由于c语言中函数在定义的时候默认就是指针，但在声明变量时需要显式说明（这样描述我自己都理解不了，以后再说吧）。所以正规的回调函数写法应该这样： 123void func1(void (*cbf)(int)) &#123; (*cbf)(2);&#125; 但是这样写出来的回调函数却不符合我们平时写c代码的思维习惯，一般都是变量类型 变量名的形式。下面写一个符合正常习惯的回调例子。 1234567891011typedef void (*CALLBACK)(int);void cb_fun(int n) &#123; printf("%d\n", n);&#125;void func2(CALLBACK cbf) &#123; CALLBACK f = cbf; (*f)(4);&#125;main() &#123; func2(cb_fun);&#125; 用了一下typedef就使代码顺畅多了。 JavaJava是不支持函数回调的，因为Java中就根本没有函数这一说，在C/C++中函数是必须定义在全局的，类中那是方法，Java是不允许在类之外定义别任何变量，包括函数。但是这不影响java中使用回调，且在java中回调无处不在。写个例子： 123456789101112131415class Callback &#123; public void run() &#123; System.out.println("hello, world."); &#125;&#125;public class Test &#123; public void start(Callback cb) &#123; cb.run(); &#125; public static void main() &#123; Test t = new Test(); Callback cb = new Callback(); t.start(cb); &#125;&#125; 怎么样，想到了什么？多线程类Thread。我们常说的java实现多线程的方式有两种一是继承Thread，二是实现Runnable，其本质就一种就是执行Thread的start方法。只不过一是调用的重写的run而二是回调的实现的run而已。 总结以上是记录了我常用的开发语言的回调，以后用到别的语言再补充吧。]]></content>
  </entry>
  <entry>
    <title><![CDATA[C语言程序调用java代码]]></title>
    <url>%2F2018%2F04%2F26%2Fc-call-java%2F</url>
    <content type="text"><![CDATA[在计算机世界里，有些事是java不能办到的，而没有事是c/c++不能办到的，例如操作硬件设备。所以java调用c/c++是常有的事，而无所不能的c应该不常调用java。但实际情况也不尽然，如android系统（linux系统包装了java界面）里有时会有c程序执行完某功能后要通知java界面。这篇就记录一下c如何调用java。我这篇的代码基本都是抄的这篇，只是我简化修改了下，算是个笔记吧。 java代码 Person.java1234567891011121314public class Person &#123; private static String staticInfo = "this is a person"; private String name = "aaa"; public int age = 20; public static String getStaticInfo() &#123; return staticInfo; &#125; public String getName() &#123; return "aaa"; &#125; public int getAge() &#123; return age; &#125;&#125; 我为了追求例子简单写了这样一个不规范的代码，先说说哪里不规范： 声明成员变量的时候直接赋值了； 没写set方法； 没写构造函数；这样写出来的java代码平时可能没什么不妥，但是如果通过jni操作它，可能就会出现各种问题，有的问题我这篇最后都不知道怎么解决。所以以后写java代码时一定要规范！ 下面记录一个命令，用来查看java类签名：1javap -private -s Person java调用java测试 Main.java12345678public class Main &#123; public static void main(String[] args) &#123; Person p = new Person(); System.out.println(Person.getStaticInfo()); System.out.println(p.getName()); System.out.println(p.getAge()); &#125;&#125; 这里的java代码间的调用，确实没感觉出Person.java代码写的有何不妥。 c调用java测试C调用java的测试代码是这样的： main.c12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;jni.h&gt;int main()&#123; printf("c call java test.\n"); JavaVM *jvm = 0; JNIEnv *env = 0; JavaVMInitArgs jvm_args; JavaVMOption opt[1]; opt[0].optionString = "-Djava.class.path=."; memset(&amp;jvm_args, 0, sizeof(jvm_args)); jvm_args.version = JNI_VERSION_1_6; jvm_args.nOptions = 1; jvm_args.options = opt; long jvm_stat = JNI_CreateJavaVM(&amp;jvm, (void**)&amp;env, &amp;jvm_args); jclass cls = (*env)-&gt;FindClass(env, "Person"); jmethodID static_method = (*env)-&gt;GetStaticMethodID(env, cls, "getStaticInfo", "()Ljava/lang/String;"); jstring staticInfo = (jstring)(*env)-&gt;CallStaticObjectMethod(env, cls, static_method); const char *strInfo = (*env)-&gt;GetStringUTFChars(env, staticInfo, 0); printf("%s\n", strInfo); (*env)-&gt;ReleaseStringUTFChars(env, staticInfo, strInfo); jobject person = (*env)-&gt;AllocObject(env, cls); jmethodID get_name = (*env)-&gt;GetMethodID(env, cls, "getName", "()Ljava/lang/String;"); jstring name = (jstring)(*env)-&gt;CallObjectMethod(env, person, get_name); const char *strName = (*env)-&gt;GetStringUTFChars(env, name, 0); printf("%s\n", strName); (*env)-&gt;ReleaseStringUTFChars(env, name, strName); jfieldID age_field = (*env)-&gt;GetFieldID(env, cls, "name", "I"); (*env)-&gt;SetIntField(env, person, age_field, 33); jmethodID get_age = (*env)-&gt;GetMethodID(env, cls, "getAge", "()I"); jint age = (*env)-&gt;CallIntMethod(env, person, get_age); printf("%ld\n", age); return 0;&#125; 由于我的Person代码写的不正规，导致用c调用的时候有的问题现在也没解决，如上面代码中最后打印的age是0。如果是正规的java代码是好解决的。 makefilejava代码间调用是没必要写makefile的，但是c调用java的代码在编译运行的时候要设好几个地方，还是直接上一个makefile吧。 makefile123456789JDKHOME = /opt/jdk1.7.0_79LIBJVM = $(JDKHOME)/jre/lib/amd64/server/libjvm.soINCS = -I$(JDKHOME)/include -I$(JDKHOME)/include/linuxmain: gcc $(INCS) main.c $(LIBJVM) -Wl,-rpath=$(JDKHOME)/jre/lib/amd64/server javac *.javaclean: rm a.out *.o *.class *.log 其他jni的文章先写到这里吧。以后要深入学习可以看这篇：https://blog.csdn.net/honjane/article/details/53959587]]></content>
      <categories>
        <category>Jni</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jni调用已有的c语言库]]></title>
    <url>%2F2018%2F04%2F25%2Fjni%E8%B0%83%E7%94%A8%E5%B7%B2%E6%9C%89%E7%9A%84c%E8%AF%AD%E8%A8%80%E5%BA%93%2F</url>
    <content type="text"><![CDATA[上一篇写了jni如何操作java对象，但是实际应用中一般不会这样干。我们使用jni的主要用途是调用现成的c语言好的动态库或静态库，那本文以linux下的c语言库为例子，介绍一下jni如何调用已经写好的c语言库。 c语言库下面是一个c语言库的例子，直接贴代码。 mystr.h123void print_str();char* get_info();char* hello(char *name); mystr.c12345678910111213141516171819202122#include "mystr.h"#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void print_str()&#123; printf("中华人民共和国万岁，世界人民大团结万岁！\n");&#125;char* get_info()&#123; static char info[100]; strcpy(info, "我是中国人！"); return info;&#125;char* hello(char *name)&#123; char *s = "你好啊，"; char *buf = (char*)malloc(strlen(name)+strlen(s)+1); strcpy(buf, s); strcat(buf, name); return buf;&#125; mynum.h1int get_num1(); mynum.c12345#include "mynum.h"int get_num1()&#123; return 1;&#125; 生成动态库12$ gcc -fPIC -c mystr.c mynum.c$ gcc -shared -o libtest3.so mystr.o mynum.o 这个是分解动作，可以合成一个命令，看后面的makefile怎么写吧。 生成静态库12$ gcc -c mystr.c mynum.c$ ar cr libtest3.a mystr.o mynum.o 这是两个不同的命令，ar其实就是把.o文件打包（解包命令是这样的：ar -x libtest3.a），但是这样打出来的.a文件是不能被jni调用的（我现在是不会）。什么样的静态库文件能被jni调用呢？还是看后面的makefile文件。 Jni直接贴代码。 MyJni.java123456public class MyJni &#123; public native void printStr(); public native int getNum1(); public native String getInfo(); public native String hello(String name);&#125; MyJniImpl.c123456789101112131415161718192021222324252627282930#include "MyJni.h"#include "mystr.h"#include "mynum.h"#include &lt;stdlib.h&gt;JNIEXPORT void JNICALL Java_MyJni_printStr(JNIEnv *e, jobject o)&#123; print_str();&#125;JNIEXPORT jint JNICALL Java_MyJni_getNum1(JNIEnv *e, jobject o)&#123; return get_num1();&#125;JNIEXPORT jstring JNICALL Java_MyJni_getInfo(JNIEnv *env, jobject obj)&#123; char *info = get_info(); return (*env)-&gt;NewStringUTF(env, info);&#125;JNIEXPORT jstring JNICALL Java_MyJni_hello(JNIEnv *env, jobject obj, jstring name)&#123; const jbyte *strName = (*env)-&gt;GetStringUTFChars(env, name, 0); char *helloInfo = hello((char*)strName); (*env)-&gt;ReleaseStringUTFChars(env, name, strName); jstring info = (*env)-&gt;NewStringUTF(env, helloInfo); free(helloInfo); return info;&#125; 说明几点个人看法（不一定对） java只能加载jni动态库 jni遵循自己的内存自己释放的原则，但是需要手动调用，所以写jni代码的时候应该GetStringUTFChars和ReleaseStringUTFChars要成对出现 上面例子中故意没有遵循谁申请谁释放原则，在jni实现中调了free 测试直接贴代码。 main.c1234567891011#include "mystr.h"#include "mynum.h"#include &lt;stdio.h&gt;int main()&#123; print_str(); printf("%d\n", get_num1()); printf("%s\n", get_info()); printf("%s\n", hello("小明")); return 0;&#125; Main.java123456789101112public class Main &#123; static &#123; System.loadLibrary("myjni"); &#125; public static void main(String[] args) &#123; MyJni mj = new MyJni(); mj.printStr(); System.out.println(mj.getNum1()); System.out.println(mj.getInfo()); System.out.println(mj.hello("小明")); &#125;&#125; 正常情况这两个c和java的代码输出应该是一样的。 makefile123456789101112131415161718JDKHOME = $(JAVA_HOME)JNIINC = -I$(JDKHOME)/include -I$(JDKHOME)/include/linuxmain: lib_a jni_lib gcc main.c -L. -ltest3 javac Main.javalib_so: gcc -fPIC -shared -o libtest3.so mystr.c mynum.clib_a: gcc -fPIC -c mystr.c mynum.c ar cr libtest3.a mystr.o mynum.o rm mystr.o mynum.ojni_h: javac MyJni.java javah MyJnijni_lib: gcc $(JNIINC) -fPIC -shared -o libmyjni.so MyJniImpl.c -L. -ltest3clean: rm *.class *.o a.out libmyjni.so libtest3.so libtest3.a 把上面的main依赖的lib_a改成lib_so，可以分别测试jni调用c的静态库和动态库，如果不行就把静态库编译时也加上-fPIC重新编译下再说哦。因为别的我还不会(^o^)]]></content>
      <categories>
        <category>Jni</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jni操作Java对象]]></title>
    <url>%2F2018%2F04%2F24%2Fjni-operate-java-object%2F</url>
    <content type="text"><![CDATA[上一篇写了一下java使用jni的入门，这篇写一下如何通过jni操作java对象。用eclipse开发的不一定会开发java，就像上篇例子那样，离开eclipse只能写个helloworld，如果写个大型的java工程可能就不行了。本文也顺带记录一下不用eclipse怎么组织一个java工程。 工程结构这篇想手敲还挺费劲，由于命令较多，搞不好会有遗漏，还是写个makefile直接粘贴吧。工程结构很简单，如下：12345678910111213141516171819/root/devel/java/test2├── classes│ ├── a│ │ ├── b│ │ │ ├── c│ │ │ │ └── PersonJni.class│ │ │ └── Person.class│ │ └── Hello.class│ ├── a_b_c_PersonJni.h│ └── libperson.so└── src ├── a │ ├── b │ │ ├── c │ │ │ └── PersonJni.java │ │ └── Person.java │ └── Hello.java ├── makefile └── PersonJniImpl.c 我这个组织结构不一定合理，我的原则是需要手敲的所谓代码都放到src目录下，所有生成的东西都放到classes目录下。 写makefile123456789101112JDKHOME = /opt/jdk1.7.0_79INCS = -I$(JDKHOME)/include -I$(JDKHOME)/include/linuxall: #javac a/Hello.java -d ../classes #javac a/b/Person.java -d ../classes find . -name &apos;*.java&apos; -exec javac &#123;&#125; -d ../classes \; cd ../classes &amp;&amp; javah a.b.c.PersonJni gcc $(INCS) -fPIC -shared -o ../classes/libperson.so PersonJniImpl.cclean: #find . -name &apos;*.class&apos; | xargs -I&#123;&#125; rm &#123;&#125; find ../classes -name &apos;*.class&apos; -exec rm &#123;&#125; \; rm ../classes/libperson.so -f 这里的makefile是为了方便写这篇文章组织的，没有按照规范写，以后再写makefile的东西吧。 写java代码不多说了，直接贴代码 Person.java123456789101112131415161718192021222324252627package a.b;public class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; public String toString() &#123; return name + ":" + age; &#125; public static String getInfo() &#123; return "这是一个人"; &#125;&#125; PersonJni.java12345678910package a.b.c;import a.b.Person;public class PersonJni &#123; public native void test(); public native String getName(Person p); public native int getAge(Person p); public native String getInfo(); public native Person constructPerson(String name, int age); public native void setNameAge(Person p, String name, int age);&#125; Hello.java123456789101112131415161718192021package a;import a.b.Person;import a.b.c.PersonJni;public class Hello &#123; static &#123; System.loadLibrary("person"); &#125; public static void main(String[] args) &#123; Person p1 = new Person("小明", 22); System.out.println("hello, " + p1); PersonJni pj = new PersonJni(); pj.test(); System.out.println(pj.getName(p1)); System.out.println(pj.getAge(p1)); System.out.println(pj.getInfo()); Person p2 = (Person)pj.constructPerson("小红", 20); System.out.println("hello, " + p2); pj.setNameAge(p2, "小刚", 33); System.out.println("hello, " + p2); &#125;&#125; 写c代码写c代码之前要先make一下，这样能生成对应jni的头文件，然后就可以编写PersonJniImpl.c了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include "../classes/a_b_c_PersonJni.h"JNIEXPORT void JNICALL Java_a_b_c_PersonJni_test(JNIEnv *env, jobject obj)&#123; printf("this is jni test.\n");&#125;JNIEXPORT jstring JNICALL Java_a_b_c_PersonJni_getName(JNIEnv *env, jobject o, jobject p)&#123; jclass personClass = (*env)-&gt;GetObjectClass(env, p); jmethodID getName = (*env)-&gt;GetMethodID(env, personClass, "getName", "()Ljava/lang/String;"); jstring name = (jstring)(*env)-&gt;CallObjectMethod(env, p, getName); //const char *str = (*env)-&gt;GetStringUTFChars(env, name, 0); //return (*env)-&gt;NewStringUTF(env, str); return name;&#125;JNIEXPORT jint JNICALL Java_a_b_c_PersonJni_getAge(JNIEnv *env, jobject o, jobject p)&#123; jclass personClass = (*env)-&gt;GetObjectClass(env, p); jmethodID getAge = (*env)-&gt;GetMethodID(env, personClass, "getAge", "()I"); jint age = (*env)-&gt;CallIntMethod(env, p, getAge); return age;&#125;JNIEXPORT jstring JNICALL Java_a_b_c_PersonJni_getInfo(JNIEnv *env, jobject o)&#123; jclass personClass = (*env)-&gt;FindClass(env, "a/b/Person"); jmethodID getInfo = (*env)-&gt;GetStaticMethodID(env, personClass, "getInfo", "()Ljava/lang/String;"); jstring info = (jstring)(*env)-&gt;CallStaticObjectMethod(env, personClass, getInfo); return info;&#125;JNIEXPORT jobject JNICALL Java_a_b_c_PersonJni_constructPerson(JNIEnv *env, jobject o, jstring name, jint age)&#123; jclass personClass = (*env)-&gt;FindClass(env, "a/b/Person"); jmethodID personConstructMethod = (*env)-&gt;GetMethodID(env, personClass, "&lt;init&gt;", "(Ljava/lang/String;I)V"); jobject person = (*env)-&gt;NewObject(env, personClass, personConstructMethod, name, age); return person;&#125;JNIEXPORT void JNICALL Java_a_b_c_PersonJni_setNameAge(JNIEnv *env, jobject o, jobject p, jstring name, jint age)&#123; jclass personClass = (*env)-&gt;GetObjectClass(env, p); jmethodID setName = (*env)-&gt;GetMethodID(env, personClass, "setName", "(Ljava/lang/String;)V"); (*env)-&gt;CallVoidMethod(env, p, setName, name); jmethodID setAge = (*env)-&gt;GetMethodID(env, personClass, "setAge", "(I)V"); (*env)-&gt;CallVoidMethod(env, p, setAge, age);&#125; 这里需要强调一下，c和c++的jni实现的写法是不一样的。每个写一行对比一下吧。 c写法：1(*env)-&gt;GetObjectClass(env, p); c++写法：1env-&gt;GetObjectClass(p); 只要牵涉env指针操作的都是这个规律 编译、测试切换到makefile所在的目录，执行如下命令：1234$ make$ cd ../classes$ export LD_LIBRARY_PATH=.$ java a.Hello 测试结果：12345678Picked up _JAVA_OPTIONS: -Xmx2048m -XX:MaxPermSize=512m -Djava.awt.headless=truehello, 小明:22this is jni test.小明22这是一个人hello, 小红:20hello, 小刚:33 咦，结果中第一行是什么鬼？其实它是因为我设了一个_JAVA_OPTIONS的环境变量后出现的，因为我之前编译hadoop相关的的东西时，由于要求jvm内存很大，而默认的不能满足，所以设置了它。先不管，以后有时间再说个中含义吧。 附：打jar包通过上面的操作可以知道怎么组织java工程了，但是，我们平时执行java程序时一般不会拿一堆class文件去执行，一般都会打成个jar包。下面记录一下把上面生成的类文件打成jar包并能正常执行输出测试结果的过程。 假设现在还在makefile文件所在的src目录，执行如下命令：123$ cd ../classes$ tar cf hello.jar a #创建带自动生成的MANIFEST.MF文件的jar，这是执行测试是不行的，提示找不到主类$ tar xf hello.jar #解压包 修改解压出来的META-INF/MANIFEST.MF，修改内容如下（记住最后有个空行）：123Manifest-Version: 1.0Created-By: 1.7.0_79 (Oracle Corporation)Main-Class: a.Hello 前两行是打包时自动生成的，Main-Class: a.Hello是修改时添上的，意在指定主类（即main函数入口类）。 再执行如下命令重新打包，并测试执行：12$ jar cvfm hello1.jar META-INF/MANIFEST.MF a #经过这样打包就能找到主类了$ jar -jar hello1.jar #执行测试程序 经过以上操作，jar打包就完成了。]]></content>
      <categories>
        <category>Jni</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java通过jni调用c入门]]></title>
    <url>%2F2018%2F04%2F23%2Fjava-call-c-by-jni%2F</url>
    <content type="text"><![CDATA[JNI（Java Native Interface）是java平台的一部分，它允许java和其他语言写的代码交互。本篇记录java调用c函数的过程，通过一个helloworld程序说明在不同平台下是如何实现java调用c的。 过程记录编写java本地接口直接上代码：123public class HelloJni &#123; public native void sayHello();&#125; 如果要将一个方法作为本地方法，必须声明该方法为native，且不能实现。编译：javac HelloJni 编写本地接口的实现通过上述操作会生成一个HelloJni.h头文件，内容就不贴上来了。下面是本地接口的c语言实现：12345678/*HelloJniImpl.c*/#include &lt;jni.h&gt;#include "HelloJni.h"JNIEXPORT void JNICALLJava_HelloJni_sayHello(JNIEnv *env, jobject obj)&#123; printf("hello, world.\n");&#125; 生成动态库不同系统的不同编译环境下，生成动态库的方式是不一样的，下面记录几种常用的方式。 windows下用vc生成进入cmd执行命令：1&gt; cl -I%java_home%\include -I%java_home%\include\win32 -LD HelloJni.c -Fehello.dll 生成hello.dll动态库文件，供java本地调用。 windows下用mingw生成进入GitBash执行命令：1$ gcc -Wall -D_JNI_IMPLEMENTATION_ -Wl,--kill-at -I/c/Java/jdk/include -I/c/java/jdk/include/win32 -shared -o hello.dll HelloJni.c 其中-Wall -D_JNI_IMPLEMENTATION_不是必须的，但-Wl,--kill-at是必须的，否则生成的dll无法被java调用。 linux下生成linux下就相对简单一些，跟普通的动态库生成没有区别，上命令：1$ gcc -I$&#123;JAVA_HOME&#125;/include -I$&#123;JAVA_HOME&#125;/include/linux -fPIC -shared -o libhello.so HelloJni.c 注意linux下java根据动态库名字找的时候会拼上前缀lib，所以为了测试代码一致，直接生成libhello.so文件。 编写java测试程序直接上代码：123456789public class HelloWorld &#123; static &#123; System.loadLibrary("hello"); &#125; public static void main(String[] args) &#123; HelloJni hj = new HelloJni(); hj.sayHello(); &#125;&#125; 使用static块加载相应名称的动态库。12$ javac HelloWorld #编译$ java HelloWorld #测试运行 我的环境是64位win7，开始用的是64位jdk，但编译动态库用的是32位mingw，这样运行测试时提示64位环境不能调用32位动态库。换成32位jdk就好了。 另外，windows下是会在程序运行目录下自动寻找动态库，但linux下不会自动寻找程序当前目录，我一般的做法是export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.，这样做是为了让程序也找当前目录。 其他这篇文章是一个java调用c函数的入门，实际用途不大，例如调用的函数sayHello既没有返回值也没有参数，我们编写代码时一般不会写这样的函数。这就涉及到了相关数据类型的对应及转换问题。等再写一篇介绍吧。这里先贴上基本数据类型的对应关系。java|jni|c:—|:—|:—boolean|jboolean|unsigned charbyte|jbyte|charchar|jchar|unsigned shortshort|jshort|shortint|jint|longlong|jlong|__int64float|jfloat|floatdouble|jdouble|double]]></content>
      <categories>
        <category>Jni</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下qt开发环境搭建]]></title>
    <url>%2F2018%2F04%2F23%2Fwin7-qt-env-setup%2F</url>
    <content type="text"><![CDATA[Qt开发可以直接命令行进行，一般步骤是：写代码、编写工程文件.pro、qmake、make。对于习惯了vs、eclipse这样的IDE工具的开发人员，就必要用到qtcreator了。平时linux下用桌面环境很少，那么这篇介绍一下windows下如何搭建qt的IDE开发环境。 环境准备下面是我的环境 操作系统：windows7 64位 调试器：gdb-7.5-i686_WinXP.zip 编译器：MinGW-gcc440_1.zip QtCreator: qt-creator-opensource-windows-x86-4.0.3.exe Qt：qt-win-opensource-4.8.5-mingw.exe 搭建过程下面是我的qt开发环境搭建过程，我按如下顺序来的（不知道其他顺序行不）： 解压gdb-7.5-i686_WinXP.zip到c:\Qt\gdb-7.5-i686_WinXP 解压MinGW-gcc440_1.zip到c:\Qt\mingw 设置环境变量set path=%path%;c:\Qt\mingw\bin 安装qt-creator，路径是C:\Qt\qtcreator-4.0.3 安装qt，路径是C:\Qt\4.8.5，选择mingwc:\Qt\mingw 配置环境 选择菜单工具/选项/构建和运行/qt版本/，添加qmake路径c:/Qt/4.8.5/bin/qmake.exe 编译器路径经过如上步骤后应该能自动检测到，如果没有可以手动添加，选择菜单工具/选项/构建和运行/编译器，添加编译器路径C:\Qt\mingw\bin\g++.exe 不使用自动发现的调试器，手动添加工具/选项/构建和运行/Debuggers，添加调试器路径C:\Qt\gdb-7.5-i686_WinXP\gdb-i686-pc-mingw32.exe CMake选择C:\Qt\qtcreator-4.0.3\bin\jom.exe，据说可以提高编译速度 在构建套件中添加新套件，选择相应的编译器、调试器、qt版本、CMake Tool等 测试常用操作 vi编辑方式alt+vv，左手拇指按住alt键然后连按两次v键]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[REST接口调用客户端开发库例子]]></title>
    <url>%2F2018%2F04%2F13%2Frest-api-call-client%2F</url>
    <content type="text"><![CDATA[最近在写微服务相关的东西，微服务对外公布的rest api如何让不同语言的开发者方便调用呢？本文简单实现了个rest接口客户端调用库，可简单满足vc、qt、java开发者通过指定网关及其代理的微服务名访问具体的rest接口的需求。 vcvc下用的是大名鼎鼎的libcurl库封装rest调用，libcurl怎么用vc编译看上一篇文章，下面直接上代码吧 restcli.h123456789101112131415161718192021222324252627282930313233#ifndef RESTCLI_H#define RESTCLI_H#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class RestClient&#123;public: RestClient(); RestClient(string address, int port, string serviceName); void SetAuth(string appKey, string appSecret); void SetTimeout(int connTimeout, int timeout); bool Get(string path, string &amp;result); bool Post(string path, string &amp;result, string postData="");protected: void genBasePath(); void genAuthParam(); string getUrl(string path);private: string address; int port; string serviceName; string appKey; string appSecret; int connTimeout; int timeout; string basePath; string authParam;&#125;;#endif // RESTCLI_H restcli.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include "restcli.h"#include "curl.h"#include &lt;sstream&gt;static int writer(char *data, size_t size, size_t nmemb, std::string *writerData)&#123; if(writerData == NULL) return 0; writerData-&gt;append(data, size*nmemb); return size * nmemb;&#125;RestClient::RestClient()&#123; this-&gt;address = "localhost"; this-&gt;port = 80; this-&gt;serviceName = ""; this-&gt;appKey = ""; this-&gt;appSecret = ""; this-&gt;connTimeout = -1; this-&gt;timeout = -1; genBasePath(); genAuthParam();&#125;RestClient::RestClient(string address, int port, string serviceName)&#123; this-&gt;address = address; this-&gt;port = port; this-&gt;serviceName = serviceName; this-&gt;appKey = ""; this-&gt;appSecret = ""; this-&gt;connTimeout = -1; this-&gt;timeout = -1; genBasePath(); genAuthParam();&#125;void RestClient::genBasePath()&#123; ostringstream osPort; osPort&lt;&lt;this-&gt;port; this-&gt;basePath = "http://" + this-&gt;address + ":" + osPort.str() + "/"; if (this-&gt;serviceName.size() &gt; 0) this-&gt;basePath += this-&gt;serviceName + string("/");&#125;void RestClient::genAuthParam()&#123; if (appKey.size() &gt; 0) &#123; authParam = "appKey=" + appKey + "&amp;appSecret=" + appSecret; &#125;&#125;string RestClient::getUrl(string path)&#123; string url = basePath + path; if (authParam.size() == 0) return url; int pos = path.find("?"); if (pos &gt;= 0) &#123; url += "&amp;" + authParam; &#125; else &#123; url += "?" + authParam; &#125; return url;&#125;void RestClient::SetAuth(string appKey, string appSecret)&#123; this-&gt;appKey = appKey; this-&gt;appSecret = appSecret;&#125;void RestClient::SetTimeout(int connTimeout, int timeout)&#123; this-&gt;connTimeout = connTimeout; this-&gt;timeout = timeout;&#125;bool RestClient::Get(string path, string &amp;result)&#123; CURLcode code; CURL* curl = curl_easy_init(); if (curl == NULL) return false; string url = getUrl(path); curl_easy_setopt(curl, CURLOPT_URL, url.c_str()); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writer); curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;result); curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1); curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, this-&gt;connTimeout); curl_easy_setopt(curl, CURLOPT_TIMEOUT, this-&gt;timeout); code = curl_easy_perform(curl); curl_easy_cleanup(curl); if(code != CURLE_OK) return false; return true;&#125;bool RestClient::Post(string path, string &amp;result, string postData)&#123; CURLcode code; CURL* curl = curl_easy_init(); if (curl == NULL) return false; curl_easy_setopt(curl, CURLOPT_URL, getUrl(path).c_str()); curl_easy_setopt(curl, CURLOPT_POST, 1); curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postData.c_str()); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writer); curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;result); curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1); curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, this-&gt;connTimeout); curl_easy_setopt(curl, CURLOPT_TIMEOUT, this-&gt;timeout); code = curl_easy_perform(curl); curl_easy_cleanup(curl); if(code != CURLE_OK) return false; return true;&#125; qt之所以用libcurl进行http请求处理的一个重要原因就是为了想在vc下和qt下可以复用一套代码，所以qt的代码和vc的是一样的。具体qt的工程文件x.pro怎么写见上一篇文章 javajava处理http请求就简单多了，如果是springMVC工程下直接用个restTemplate就完成了，下面还是用java下最普遍使用的httpclient库实现。我建立maven工程，引入httpclient依赖4.5.5 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151public class RestClient &#123; String address = "localhost"; int port = 80; String serviceName = ""; String appKey = ""; String appSecret = ""; int connTimeout = -1; int timeout = -1; String basePath = ""; String authParam = ""; public RestClient() &#123; genBasePath(); genAuthParam(); &#125; public RestClient(String address, int port, String serviceName) &#123; this.address = address; this.port = port; this.serviceName = serviceName; genBasePath(); genAuthParam(); &#125; public void SetAuth(String appKey, String appSecret) &#123; this.appKey = appKey; this.appSecret = appSecret; &#125; public void SetTimeout(int connTimeout, int timeout) &#123; this.connTimeout = connTimeout; this.timeout = timeout; &#125; public boolean Get(String path, StringBuilder result) &#123; boolean ret = false; CloseableHttpClient httpClient = HttpClients.createDefault(); RequestConfig requestConfig = RequestConfig.custom() .setConnectTimeout(connTimeout) .setConnectionRequestTimeout(connTimeout) .setSocketTimeout(timeout).setRedirectsEnabled(true).build(); String url = getUrl(path); HttpGet httpGet = new HttpGet(url); httpGet.setConfig(requestConfig); try &#123; HttpResponse httpResponse = httpClient.execute(httpGet); int statusCode = httpResponse.getStatusLine().getStatusCode(); String s = EntityUtils.toString(httpResponse.getEntity(), "UTF-8"); if (statusCode == 200) &#123; result.append(s); ret = true; &#125; else &#123; ret = false; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; httpClient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return ret; &#125; public boolean Post(String path, StringBuilder result, String postData) &#123; boolean ret = false; CloseableHttpClient httpClient = HttpClients.createDefault(); RequestConfig requestConfig = RequestConfig.custom() .setConnectTimeout(connTimeout) .setConnectionRequestTimeout(connTimeout) .setSocketTimeout(timeout).setRedirectsEnabled(true).build(); String url = getUrl(path); HttpPost httpPost = new HttpPost(url); httpPost.setConfig(requestConfig); List&lt;BasicNameValuePair&gt; list = new ArrayList&lt;BasicNameValuePair&gt;(); String[] params = postData.split("&amp;"); for (String param : params) &#123; String[] nv = param.split("="); if (nv.length == 2) &#123; list.add(new BasicNameValuePair(nv[0], nv[1])); &#125; &#125; try &#123; UrlEncodedFormEntity entity = new UrlEncodedFormEntity(list, "UTF-8"); httpPost.setEntity(entity); HttpResponse httpResponse = httpClient.execute(httpPost); int statusCode = httpResponse.getStatusLine().getStatusCode(); String s = EntityUtils.toString(httpResponse.getEntity(), "UTF-8"); if (statusCode == 200) &#123; result.append(s); ret = true; &#125; else &#123; ret = false; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return ret; &#125; private String getUrl(String path) &#123; String url = basePath + path; if (authParam.length() == 0) return url; int pos = path.indexOf("?"); if (pos &gt;= 0) &#123; url += "&amp;" + authParam; &#125; else &#123; url += "?" + authParam; &#125; return url; &#125; private void genAuthParam() &#123; if (appKey.length() &gt; 0) &#123; authParam = "appKey=" + appKey + "&amp;appSecret=" + appSecret; &#125; &#125; private void genBasePath() &#123; if (port == 80) &#123; this.basePath = "http://" + this.address + "/"; &#125; else &#123; this.basePath = "http://" + this.address + ":" + port + "/"; &#125; if (this.serviceName.length() &gt; 0) this.basePath += this.serviceName + "/"; &#125; public static void testGet() throws Exception &#123; CloseableHttpClient httpClient = HttpClients.createDefault(); HttpGet httpGet = new HttpGet("http://www.baidu.com/"); HttpResponse httpRes = httpClient.execute(httpGet); String result = EntityUtils.toString(httpRes.getEntity(), "UTF-8"); System.out.println(result); httpClient.close(); &#125; public static void main(String[] args) throws Exception &#123; // RestClient.testGet(); RestClient rc = new RestClient("www.baidu.com", 80, ""); StringBuilder sb = new StringBuilder(""); boolean b = rc.Get("", sb); System.out.println(b); System.out.println(sb); &#125;&#125; 建maven工程的一个重要原因是想封装的rest访问库只要提供一个jar包就可以，如果普通工程恐怕要附带提供其他如httpclient.jar的包。~标记一下以后写maven的文章~ 参考文章*下面这些文章是我写上面这些时看过的，记录下来以备后看libcurl https://curl.haxx.se/libcurl/c/libcurl-tutorial.html https://blog.csdn.net/mao834099514/article/details/54947853 https://blog.csdn.net/lijinqi1987/article/details/53925835 https://www.cnblogs.com/jikexianfeng/p/6055024.html https://www.cnblogs.com/lidabo/p/4583061.html https://blog.csdn.net/ilovec1/article/details/52039672 https://blog.csdn.net/educast/article/details/47099607 qt https://blog.csdn.net/u012234115/article/details/71295785 httpclient https://www.cnblogs.com/c9999/p/6636415.html https://www.cnblogs.com/wutongin/p/7778996.html https://www.cnblogs.com/veitch-623/p/6259008.html https://blog.csdn.net/micro_hz/article/details/53157738]]></content>
      <categories>
        <category>Curl</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[curl入门教程]]></title>
    <url>%2F2018%2F04%2F12%2Fcurl-primer%2F</url>
    <content type="text"><![CDATA[平时进行文件传输的时候一般首先想到的是搭建文件传输服务器（这里不讨论微信QQ飞鸽），常见的文件传输服务器一般是ftp、http、samba。windows下一般就是登陆上相关服务器Ctrl-C或者右键另存为，但是习惯了linux命令行操作后会想到wget和curl，这里要说的是curl，因为最近写代码时用到了libcurl，再就是wget好像只能下载用。 curl命令用法Curl作为数据传输工具强到令人发指，下面先引用两段： curl是利用URL语法在命令行方式下工作的开源文件传输工具。它被广泛应用在Unix、多种Linux发行版中，并且有DOS和Win32、Win64下的移植版本。百度百科curl命令是一个利用URL规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称curl为下载工具。作为一款强力工具，curl支持包括HTTP、HTTPS、ftp等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。做网页处理流程和数据检索自动化，curl可以祝一臂之力。linux命令大全 curl命令的使用方法就参考上面提到的两篇文章吧。下面记录一下在微服务大行其道的今天如何用curl进行RESTful接口调用 测试REST接口请求方法为get：1$ curl -X GET -i &apos;http://localhost/person?id=1&apos; 请求方法为post：1curl -X POST -i &apos;http://localhost/person?id=1&apos; 带post字段的请求：1curl -X POST -i http://localhost/person --data &apos;name=aaa&amp;age=33&apos; 带http头字段的请求：1curl -X POST -H &apos;Content-Type: application/json&apos; -i http://localhost/person --data &apos;&#123;name:&quot;aaa&quot;,age:33,children:[&quot;x&quot;,&quot;y&quot;,&quot;z&quot;]&#125;&apos; 这些命令用做测试REST足够了，但是要在程序中调用就要用到libcurl了 windows下编译curl我写在简书上的文章 下载curl目前最新版本是7.59.0，要下载其他版本的可以到https://curl.haxx.se/download/?C=M;O=D vc编译我的开发环境是vs2008，对应vc9，在源码curl-7.59.0\projects\Windows\VC9目录下有相关工程文件，用vs2008打开就能编译，这里不写了。 命令行编译方法：12$ cd curl-7.59.0/winbuild$ nmake /f Makefile.vc mode=static vc=9 ENABLE_IDN=no debug=no 成功后在curl-7.59.0/builds/libcurl-vc9-x86-release-static-ipv6-sspi-winssl产生相关文件。 测试curl，curl http://www.baidu.com 测试libcurl： 用vs2008建立vc工程，编写测试代码 引入libcurl_a.lib 增加宏定义CURL_STATICLIB 修改运行时库/md 更多例子代码 mingw编译libcurl以前要单独安装mingw，现在有了git方便多了。123打开GitBash$ cd curl-7.59.0$ mingw32-make mingw32 完成后在lib目录下有3个文件，分别是： libcurl.a 静态库 libcurl.dll 动态库 libcurldll.a 动态倒入库 测试一下抄来的12$ gcc -I../../include -L../../lib simple.c -lcurldll$ gcc -I../../include -L../../lib simple.c -DCURL_STATICLIB -lcurl -lws2_32 -lwldap32 qt下使用libcurl这是我qt工程文件修改的部分：123INCLUDEPATH += D:/aaa_lcy/tmp/my-curl/curl-7.59.0/include/curlLIBS += D:/aaa_lcy/tmp/my-curl/curl-7.59.0/lib/libcurl.a -lws2_32 -lwldap32DEFINES += CURL_STATICLIB 其他linux下就不说了，mingw本身就是模拟linux]]></content>
      <categories>
        <category>Curl</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTTP文件传输]]></title>
    <url>%2F2018%2F04%2F11%2FHTTP%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%2F</url>
    <content type="text"><![CDATA[前言最近在用libcurl写REST接口调用的东西，联想到之前做的HTTP文件传输，又想到在windows下没有搭建成功hexo发布github环境。于是突然有个挺别致的想法：在我的工作机win7下写文章，写好后通过http上传到我的centos7上，然后再在centos上用hexo发布。 怎么样，是不是很别致？写一篇博客文章有N种简单方法，偏偏选这种绕来绕去的方法。算了，权当通过这种方式为近来的工作做笔记了。 搭建HTTP传输服务器要通过http进行文件传输，首先要有文件传输服务器。搭建http服务器第一反应会出现一大堆工具：windows自带的IIS、apache、tomcat、nginx等。这里不想说IIS，一是不想写windows下的工具，再就是图形界面的操作不截图不好说明，不会截图。这里也不想说nginx，因为nginx有别的主要功能，做文件传输服务器太浪费了。（标记一下以后专门写nginx的文章） 一种最简单的方式直接贴命令12$ python -m SimpleHTTPServer #默认开80端口，如果80在用执行下面这个指定一个端口$ python -m SimpleHTTPServer 8000 就一条命令的事，也没有什么配置，想在哪个目录下开服务就在那个目录下执行该命令，实在是简单。 但是，不允许写入文件。 apache httpd在linux下的http服务器首先想到的肯定是apache（也只能想到他），毕竟有大名鼎鼎的LAMP（标记一下以后专门写LAMP的文章）。修改配置文件/etc/httpd/conf/httpd.conf，这是centos7上的配置，其他linux下不知道是不是这个位置。1234567&lt;Directory &quot;/var/www/html/upload&quot;&gt; Dav On AllowOverride None Options All Order allow,deny Allow from all&lt;/Directory&gt; 不知道这些配置都是什么意思，就是从网上抄来的 执行命令chmod 777 /var/www/html/upload，看来777还是比666要管用。777是什么意思呢？就是二进制的111111111，表示所有用户的读写执行权限都开放，所以以后遇到目录读写权限的问题一律777（其实对http文件传输服务器来说666一样好使） apache tomcat用java做web开发肯定第一时间想到的是tomcat了。修改tomcat的conf下的web.xml，在servlet标签下添加如下配置项1234&lt;init-param&gt; &lt;param-name&gt;readonly&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; 意思很明显了，不能只读，我也不知道具体是哪个目录，反正就这样写了。然后建一个web项目，在其WebContent目录下建一个upload目录。（没有亲测，这是从别人那里抄来的） curl命令测试HTTP文件传输测试下载12$ curl -o 1.jpg http://ip/upload/a.jpg #指定名$ curl -O http://ip/upload/a.jpg #原名 测试上传1$ curl -T a.jpg http://localhost/upload/ 我在windows下传到linux下的中文内容的文件怎么处理？1$ iconv -f gbk -t utf-8 1.md &gt; 2.md 我在windows下传到linux下的中文名称的文件怎么处理？12$ convmv -f gbk -t utf-8 *.md #不直接转，只显示给人看$ convmv -f gbk -t utf-8 *.md --notest #直接转了 这个问题参考的这篇 java代码测试HTTP文件上传]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git学习笔记]]></title>
    <url>%2F2018%2F04%2F11%2FGit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言Git是一个开源的分布式的版本管理工具。Hexo依赖的nodejs肯定不能用一篇文章写，但是git作为一个代码管理工具，我觉得这一篇写足够了。所以以后不会再单独写git相关的文章，有需要记录的就像之前的hexo和markdown那样，都在这篇里面追加吧。 git的使用可以通过https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%91%BD%E4%BB%A4%E8%A1%8C学习，但是我使用git时可能就几个常用的操作，每次来这里翻看也麻烦，于是有了这篇。 笔记windows下安装git 下载合适版本 双击666 打开GitBash后发现这个太好了，由于其内置了mingw，里面几乎常用的linux命令都有了，下次再装windows系统的时候不再装gvim、putty、curl等乱七八糟的工具了，直接装git。 常用操作设置用户信息12$ git config --global user.name "John Doe"$ git config --global user.email johndoe@example.com 这一步应该是必须的，不然提交时不行。 帮助1$ git help 其实其他都是多余的，所有操作都能通过帮助解决 初始化仓库$ git init 添加及提交文件12$ git add *.c$ git commit -m &apos;说明&apos; 察看状态12$ git status$ git status -s #简要 忽略文件$ vim .gitignore 移出及移动文件12$ git rm test.txt$ git mv test.txt readme.md]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法笔记]]></title>
    <url>%2F2018%2F04%2F10%2FMarkdown%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[标题123456# H1## H2### H3#### H4##### H5###### H6 列表无序列表123- li- li- li 有序列表1231. li1. li1. li 链接直接连接1&lt;https://lcyasdlcy.github.io/&gt; 隐藏连接地址1[我的博客](https://lcyasdlcy.github.io/) 图片链接1![一张图片](https://lcyasdlcy.github.io/1.jpg) 引用123&gt; 引用1&gt; 引用2&gt; 引用3 强调粗体 **粗体**斜体 *斜体*删除 ~~删除~~分割线--- 表格 left center right 1 2 3 4 5 6 1234left|center|right-----|:---:|----:1|2|34|5|6]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用笔记]]></title>
    <url>%2F2018%2F04%2F10%2FHexo%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言我的博客站点建好了，之前写过一篇文章了。感觉很好，有总比没有强（聊胜于无）。 但是，访问几次我的博客后，自己都感觉不好意思了。 首页就把所有文章的内容都显示出来了，正常应该每篇文章只显示摘要信息吧？ home、archives、recent posts都是什么鬼，我们是中国人！ 正常博客的基本功能分类、标签、评论都去哪里了？ …… 既然用了hexo，就要相信他，上面这些对hexo来说都是小意思。本文会一一解决之。但是hexo毕竟只是个博客建站工具，除此别无他用，所以我计划只用这一篇文章记录hexo的使用，以后不再写相关的文章了，有需要记录的就这篇文章改吧。 下面进入hexo笔记正文。 笔记Hexo是什么 Hexo is a fast, simple &amp; powerful blog framework powered by Node.jshttps://hexo.io/ 在首页只显示每篇文章的摘要信息方式1在编写md文件内容时，在要显示的内容后、要隐藏的信息前加入一行&lt;!-- more --&gt; 方式2在md文件的fron-matter（每篇文章的开头部分）加入一项description，其值就是文章的摘要。 开启/关闭文章评论功能在front-matter中设置comments: true/false 为文章归档在front-matter中设置categories分类、设置tags标签。下面列出本文的front-matter：1234567title: Hexo使用笔记date: 2018-04-10 10:53:00tags: [tag1, tag2, tag3]categories: Hexocomments: truetoc: true #显示文章目录description: 使用Hexo搭建博客过程的问题笔记 怎么说好的toc、description等都不管用？换个主题试试 更改主题及语言下载主题1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 修改_post.yml12theme: nextlanguage: zh_Hans #应该是去找next主题下的zh_Hans.yml nani？评论还是不行，算了不管了，反正我也不是听人意见的人。有空参考一下https://www.zhihu.com/question/38797520这篇吧。 创建分类页、标签页12$ hexo new page categories$ hexo new page tags 修改categories/index.md12title: 分类type: &quot;categories&quot; 修改tags/index.md12title: 标签type: &quot;tags&quot; 最后别忘了hexo clean &amp; hexo g &amp; hexo d next主题设置头像拷贝要当头像的图片到themes/next/source/images目录下1cp drogba.pn themes/next/source/images 修改themes/next/_config.yml文件1avatar: /images/drogba.png next主题样式选择修改themes/next/_config.yml文件1234# Schemes#scheme: Musescheme: Mist#scheme: Pisces next主题菜单栏显示控制修改themes/next/_config.yml文件123456menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive 站内搜索安装相关插件12$ npm install hexo-generator-search --save$ npm install hexo-generator-searchdb --save 修改站配置_config.yml12345search: path: search.xml field: post format: html limit: 10000 修改主题配置themes/next/_config.yml12local_search: enable: true === 其他以后再补充===]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>tag1</tag>
        <tag>tag2</tag>
        <tag>tag3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我在github上的第一篇博文]]></title>
    <url>%2F2018%2F04%2F10%2F%E6%88%91%E5%9C%A8github%E4%B8%8A%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87%2F</url>
    <content type="text"><![CDATA[这是我在github上的第一篇博客文章，相比之前在博客园和CSDN上写的零散几篇，写在这里让我瞬间感觉档次提高不少。以后所有的技术相关的文章就在这里写吧。这篇写点什么呢？这个博客站点是用hexo搭建的，就先写一下搭建过程吧。 博客搭建过程windows下 windows7 64bitnode v8.9.3git version 2.15.1.windows.2 最终以失败告终，最后用hexo d往github上发布的时候出错，大概意思是/dev/tty不存在。不知道怎么处理，或者是自己没耐心。还是老实去linux下玩吧。 linux下linux下就简单了，大概记录一下操作步骤。环境准备： centos 7git是用yum安装的，没关心版本node v0.10.44 那么问题来了，hexo好像不支持这个版本的nodejs，我的nodejs还有别的用呢，怎么办？要不说linux下简单呢。且看如下操作步骤： 安装nodejsnvm是nodejs版本管理器，能任意切换nodejs版本，执行命令安装之。1$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh 或者wget到本地再运行也行，完事记得重启终端。 安装6版本的nodejs：nvm install 6安装8版本的nodejs：nvm install 8使用6版本的nodejs：nvm use 6 安装hexo1$ npm install hexo -g 创建博客站执行命令123$ mkdir myblog$ cd myblog$ hexo init 修改配置_config.yml123deploy: type: git repo: https://github.com/lcyasdlcy/lcyasdlcy.github.io.git 为避免每次发布都要输入用户名密码，可以将repo值写成如下格式：1https://username:password@github.com****** 更安全的方式当然还是用ssh公私钥，这里不说了写文章1$ hexo new post "我的第一篇博文" 或者直接到source/_posts目录下编写xxx.md文档，接下来就是考验markdown语法了。测试1$ hexo s 默认使用4000端口，访问http://localhost:4000看看。如果端口被占用了，使用hexo server -p 5000指定新的端口。 发布博客站到github安装自动部署发布工具hexo-deployer-git1$ npm install hexo-deployer-git --save 发布123$ hexo clean #清理$ hexo g #生成$ hexo d #部署 好了，以后每次想写文章了，重复上面的工作就可以了。]]></content>
  </entry>
</search>
